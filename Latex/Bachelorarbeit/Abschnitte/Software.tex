\chapter{Software}
\label{sec:Software}
\pagestyle{scrheadings}
\section{DAVE Entwicklungsumgebung}

Das Programm DAVE\textsuperscript{TM} (Digital Application Virtual Engineer) wird von Infineon Technologies AG entwickelt. Sie basiert auf der Entwicklungsumgebung oder \ac{IDE} \enquote{eclipse\index{eclipse}} die von der Eclipse Foundation entwickelt wird. Eine \ac{IDE} beschreibt dabei allgemein ein Programm zur Softwareentwicklung, welches die einzelnen dazu notwendigen Tools gesammelt zur Verfügung stellt. Dies sind vor allem der Compiler\index{Compiler} , der Linker, und der Debugger auf die im folgenden noch eingegangen werden soll %TODO: auch wirklich machen , GNU C compiler
%cite c als erste prog sprache
DAVE\textsuperscript{TM} greift bei der Programmierung von Mikrocontrollern der XMC-Serie auf die so genannten XMC Libraries zurück die von Infineon ebenfalls zur Verfügung gestellt werden.  Auf diese soll ebenfalls im weiteren Verlauf  eingegangen werden. Ein weiteres Feature in der \ac{IDE} sind die sogenannten DAVE\textsuperscript{TM} APPs. Mit diesen soll es die Programmierung des Mikrocontrollers durch ein \ac{GUI} ermöglicht werden. Dazu werden für  mögliche von der Hardware zu verrichtende Teilaufgaben APPs von Infineon bereitgestellt. Durch das Einfügen der entsprechenden APPs in das Projekt können diese angepasst und miteinander grafisch verschalten werden. So wird der spätere Programmablauf im Mikrocontroller und dessen Aufgaben festgelegt. Nachdem vom Programmierer nun noch die Pins ebenfalls grafisch den Aufgaben zugeordnet werden, generiert  DAVE\textsuperscript{TM}  den Programmcode mit den in den Apps enthaltenen Informationen%\cite{DAVEQuickStart}.
Mithilfe des DAVE\textsuperscript{TM} \ac{SDK} können nicht nur die Parameter der APPs beim programmieren , sonder auch diese selbst grundlegend angepasst werden und das entwickeln eigener APPs ist möglich%\cite{DAVE-Version-4}.
Im Verlauf dieser Arbeit wurden DAVE\textsuperscript{TM}  APPs jedoch nur in einem bereits existierenden Softwareprojekt für ein RelaxKit genutzt, mit welchem  Signale zum Testen der Empfänger an die Basisstation gesendet wurden. In der Basisstation selbst wurden die APPs\index{APP} jedoch nicht benutzt.


\section{verwendete Peripherie des XMC4500}
Der XMC4500-Baustein enthält diverse funktionelle Blocke die mit einer Bus Matrix an die ARM Cortex M4 \ac{CPU} angebunden sind. Dieser Aufbau soll den Prozessor entlasten und im Programmablauf Ressourcen freihalten für andere Operationen.%System Block Diagram aus Datenblatt einfügen und zitieren
Für die Basisstation waren vor allem der \ac{USIC}, der \ac{USB} sowie der \ac{ETH} die bedeutende Peripherie. Von besonderer Bedeutung sind jedoch die \acp{GPIO}. %wird plural richtig gebildet?
\subsection{GPIO}
Die \acp{GPIO} werden im so genannten PORTS-Modul der XMC-Architektur gesteuert. In dieser lassen sich die Treiberstufen für die entsprechenden Pins des Mikrocontroller regeln. Dieses Modul ist ebenfalls über die Peripheriebrücke PBA1 an die Bus Matrix \index{Bus Matrix} und somit den Cortex M4 Kern angebunden.  %Programmable port driver control module (PORTS) Abkürzung richtg?dann einfügen
%Bild StructureDigitalPin einbinden
%beschreiben wie pins belegt sind, wann GPIO bzw wann module (s. Pinbelegung) auf Pins liegen ( bei POSIF Kapitel beschreiben
Das Modul stellt für jeden Pin die erste Funktionsauswahl bereit. Im \enquote{Port Input/Output Control Register} des Moduls wird für jeden Pin festgelegt ob er als Eingang oder Ausgang belegt ist. Das momentane elektrische Potential am Eingang wird dann mit einem Schmitt-Trigger in ein binäres logisches Signal übersetzt. Ist der Pin ein Eingang, so kann dieser dort zusätzlich invertiert werden. Wird ein Pin des XMC als Ausgang konfiguriert, so kann gewählt werden, ob es sich um einen \ac{GPIO}-Pin handelt, dessen Status von der Software direkt festgelegt wird. Dabei kann ausgewählt werden ob das logische Ausgangssignal durch den einen Treiber in Open-Drain Konfiguration oder durch Push-Pull erzeugt werden soll. Zur Nutzung eines Ausgangs mit der Im Mikrocontroller verfügbaren Peripherie sind diese direkt mit den entsprechenden Modulen verbunden. Dadurch kann das Modul selbst den elektrischen Zustand am Eingang auslesen und verwerten\cite{XMC-Reference}. 
Auch das weitere Verhalten von Pins, wie etwa  beim Anschalten, bevor die Versorgungsspannung ein gültiges Level erreicht hat, lassen sich im PORTS-Modul anpassen.
\subsection{USIC}
Die \acp{IC} der XMC-Familie verfügen über ein Modul zu Kommunikation über diverse serielle Protokolle, den \ac{USIC}. Dieses ist programmierbar und erlaubt damit eine individuelle Verwendung, kann aber gleichzeitig die notwendigen Arbeiten für den Prozessor übernehmen. Der XMC4500 verfügt über insgesamt sechs \ac{USIC}-Kanäle und kann somit mehrere Protokolle gleichzeitig verweden. Die Mikrocontroller unterstützen somit die folgenden Protokolle UART/SCI, SPI in einfach, doppelt und quad-Ausführung, IIC/I2C, IIS/I2S und LIN. Für diese Arbeit wurde alle Kommunikation mit einem gemeinsamen Kanal umgesetzt. Da die einzelnen \acp{USIC} und deren Kanäle verschieden viele Slave-Select-Leitungen besitzen wurde der Kanal $0$ des \ac{USIC} $0$ ausgewählt, nur dieser verfügt über die benötigten sechs Select-Leitungen.
%beschreiben Funktion
%wo SPI allgmein beschreiben
\subsection{ERU}
Von zentraler Bedeutung für die Funktion der Basisstation war die Behandlung von Interrupts durch den  \ac{IC}. Der XMC4500 besitzt dafür zwei entsprechende \ac{ERU}-Module die eine solchen erkennen können und den Prozessor zum Aufrufen einer \ac{ISR} auffordern können. Jedes Modul verfügt über vier Kanäle auf denen  bei einem Interrupt ein vierstufiger Prozess durchlaufen wird: In der ersten Stufe der \ac{ERU}, der so genannten \ac{ERS} lassen sich aus zwei Eingänge mit jeweils vier Signalen die gewünschten Eingänge wählen. In der \ac{ETL} generiert der \ac{IC} aus dem Signalstatus ein Trigger-Event indem Veränderungen erkannt werden. So kann eine fallende oder steigende Flanke, die einen Interrupt auslösen soll, erkannt werden. In der Cross Connection Matrix können Signale der verschiedenen \acp{ETL} zu den vier \acp{OGU} weitergeleitet und somit dort untereinander und mit Triggersignalen von anderen Peripherie-Modulen des XMC kombiniert werden.  In der \ac{OGU} wird durch Vergleich der verschiedenen aufgetretenen Trigger und Muster entschieden ob ein kompletter Interrupt aufgetreten ist und leitet diesen weiter oder ob etwa nur das gewählte Muster erkannt wurde, was für andere Module wichtig ist. Diese Informationen werden entsprechend an die Peripherie weitergeleitet, sind aber für die Funktion der Basisstation nicht weiter von Bedeutung. 
Bei Vorliegen aller Bedingungen für einen Interrupt wird diese Information an den \ac{NVIC} im Cortex-M4 weitergeleitet. Dieser Teil des Prozessorkerns erkennt den Interrupt und sorgt dafür, das der aktuelle Prozessorstatus gespeichert wird. Nach Ablauf der \ac{ISR} wird der Prozessorstatus wieder hergestellt.
%wo falsche wahl der Pins einbringen?
%Interrupt Request, IRQ im gegensatz zu isr https://de.wikipedia.org/wiki/Interrupt
\subsection{USB}
Das \ac{USB}-Modul des XMC4500 arbeitet nach den  Spezifikationen für USB 2.0 und den \enquote{On-The-Go}-Spezifikationen der Version 1.3. Der Mikrocontroller könnte durch das \ac{USB}-Modul sowohl als Host oder als USB-Slave  arbeiten. In diesem Fall wurde der \ac{IC} als Slave betrieben. Das \ac{USB}-Modul besitzt über eine eigene Interruptsteuerung und ist damit eine der gerade erwähnten Peripherien des XMC deren Steuerung auch über Interrupts gelöst ist. Die gesamte Übertragung wird durch den \ac{USB}-Kern gesteuert und empfangene oder zu sendende Pakete werden in einem \ac{FIFO}-Puffer gespeichert. Für die Kommunikation der Basisstation mit dem Host-Computer wird ein virtueller COM-Port durch das \ac{USB}-Interface emuliert.
\subsection Ethernet 
%TODO was ist mit bzw. ??
Im XMC4500 werden Netzwerkverbindungen durch das  Ethernet-Modul behandelt. Diese unterstützt Datenübertragungen mit Geräten über IPv4 und IPv6 sowie Übertragungsraten von 10/100 MBit/s  Dazu werden zunächst die Daten von der CPU über ein Bus-Interface übertragen. Im \enquote{MAC Transaction Layer} werden die vom Prozessor bzw. über Ethernet empfangenen Datenpakete zwischengespeichert. Der Ethernet-Kern formatiert die zu sendenden Daten und stellt sie einem \enquote{Physical Layer} zu, welches die Daten für den Kanal moduliert.
\section{verwendete Bibliotheken}
\subsection{XMC Libraries (XMC Lib)}
Infineon stellt für seine \acp{IC} der XMC4000 Serie zu der auch der XMC4500 gehört die \enquote{XMC Peripheral Library} bereit. Diese erlaubt einen vereinfachten Zugriff auf alle Module und die entsprechenden Register und soll dadurch den Modulzugang übersichtlich gestalten und den Programmcode vereinfachen und leichter lesbar machen. Die Software baut auf dem \ac{CMSIS} auf, erlaubt die Verwendung verschiedener Compiler und kann kann mit oder ohne DAVE\textsuperscript{TM} bzw. mit oder ohne DAVE APPs verwendet werden. %C99 usage +  weiter beschreiben etc
Für die Programmierung wurde mit der Software \enquote{doxygen} eine Dokumentation zur Bibliothek als HTML generiert.

%XMC Lib mit .. docu erstellt
\subsection{SPI Library}
\subsection{TDA5340 Library}


\subsection{Virtueller COM Port}
Die Kommunikation der Basistation mit dem Hostcomputer zum übertragen der gemessene Werte wurde nach dem Vorbild eines Beispielprojektes für DAVE\textsuperscript{TM}. Die Bereitstellung des virtuellen seriellen Ports erfolgt auf Seiten des XMC über die LUFA (Lightweight USB Framework for AVRs)-Bibliothek. Mit dieser beschränkt sich die Ausgabe über den COM-Port auf das übergeben der zu sendenden Zeichen an eine entsprechende Funktion. Eine Steuerung des XMC durch empfangen von Daten über den COM-Port wäre mit der Bibliothek ebenfalls möglich, war jedoch nicht notwendig.
Die Bibliothek und das Beispielprojekt wurde dahingehend angepasst, das ganze Zeichenketten statt nur einzelner Zeichen der Funktion zum Senden übergeben werden konnten. Auch wurde das Senden von Integer-Variablen ermöglicht, indem diese zu Zeichen umgewandelt wurden. 
\section{Programmablauf}
Im Programmablauf des XMC wurde zunächst eine Warteschleife umgesetzt, in welcher der Mikrocontroller auf eine erste Eingabe durch den Benutzer am Hostcomputer wartet. Nach dem diese Bestätigung über den COM-Port vom Mikrocontroller empfangen wurde setzt dieser zunächst alle Transceiver in den Schlafmodus von welchem aus eine Kommunikation möglich ist. Daraufhin beginnt der XMC4500 mit der Konfiguration der für die Interrupts notwendigen Pins und ermöglicht somit das Empfangen von \acp{IRQ} durch die TDA5430. Anschließend initialisiert er zunächst das SPI-Modul um im folgenden den Transceiver darüber konfigurieren zu können. Bevor das dazu notwendige Schreiben in die Register der TDAs jedoch möglich ist, wird eine gewisse Verzögerung benötigt. Diese resultiert daher, dass der Wechsel des TDA vom ausgeschalteten Zustand in den Schlafmodus eine gewisse Zeitspanne benötigt. 
Im folgenden werden alle Transceiver initalisiert und anschließend in den Resceiver-Modus gefahren.  
Daraufhin setzt der \ac{IC} noch alle für die Übertragung notwendigen Variablen  und alle Felder zum Speichern von Daten zu null. 
Nun Beginnt der Prozessor mit einer Dauerschleife in der dieser auf das Ankommen von Übertragungen wartet und teilt dies auch dem Benutzer am Hostcomputer über eine Ausgabe mit. In dieser Endlosschleife wechselt sich die interruptbasierte Datenerfassung mit der Weiterleitung der erfassten Daten zyklisch ab. Wobei nur bei erfolgreichem Empfang ein Senden an den steuernden Computer erfolgt. 

%TODO:genauer alles?!; wo beschreiben? 


\subsection{Konfiguration der Funkmodule}

 Bei der Initialisierung erhalten diese die gewünschten Werte für die Sende- und Empfangs-Frequenzen. Diese werden über die Teilerrate für die  \ac{PLL} übergeben und ermittelt. Über die entsprechenden Register wird auch das Verhalten bei
%und rechnung aus exekl sheet einfügen
\subsection{interruptbasierte Datenerfassung}



In der \acl{ISR}, in welche der Prozessor beim Auftreten eines Interrupts springt, wird einer globalen Variable der Wert $1$ zugeordnet. Für jeden der möglichen Transceiver existiert eine solche Flagge, die einen aufgetretenen Interrupt anzeigt. Innerhalb der Dauerschleife wird nun zyklisch abgefragt ob diese Flagge gesetzt wurde. Beim Auftreten einer solchen Flagge, also nach dem aufgetretenen Interrupt, liest der 






\subsection{Weiterleitung der erfassten Daten}









%wie viel speicher braucht man aaktuell?
%speichergröße uint immer da 32bit mikrocontroller