<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>XMC Peripheral Library for XMC4000 Family: SCU</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family
   &#160;<span id="projectnumber">2.1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Hauptseite</span></a></li>
      <li><a href="pages.html"><span>Zusätzliche&#160;Informationen</span></a></li>
      <li class="current"><a href="modules.html"><span>Module</span></a></li>
      <li><a href="files.html"><span>Dateien</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Datenstrukturen</a> &#124;
<a href="#define-members">Makrodefinitionen</a> &#124;
<a href="#typedef-members">Typdefinitionen</a> &#124;
<a href="#enum-members">Aufzählungen</a> &#124;
<a href="#func-members">Funktionen</a>  </div>
  <div class="headertitle">
<div class="title">SCU<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Datenstrukturen</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___s_y_s_p_l_l___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_SYSPLL_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Makrodefinitionen</h2></td></tr>
<tr class="memitem:gab645bf93d140a469fb94f5a50b81043c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab645bf93d140a469fb94f5a50b81043c">XMC_SCU_INTERRUPT_EVENT_DLR_OVERRUN</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_DLROVR_Msk</td></tr>
<tr class="separator:gab645bf93d140a469fb94f5a50b81043c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5350d7ebb5bdbec5b511a8bada81e418"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga5350d7ebb5bdbec5b511a8bada81e418">XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_HDCLR_Msk</td></tr>
<tr class="separator:ga5350d7ebb5bdbec5b511a8bada81e418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1ff0412abb2208a9b5186760d86ef8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga7c1ff0412abb2208a9b5186760d86ef8">XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_HDCR_Msk</td></tr>
<tr class="separator:ga7c1ff0412abb2208a9b5186760d86ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95958fca048b8558aca91badd5782e82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga95958fca048b8558aca91badd5782e82">XMC_SCU_INTERRUPT_EVENT_HDSET_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_HDSET_Msk</td></tr>
<tr class="separator:ga95958fca048b8558aca91badd5782e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c8db1c80c86912466e5f41440976e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa3c8db1c80c86912466e5f41440976e2">XMC_SCU_INTERRUPT_EVENT_HDSTAT_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_HDSTAT_Msk</td></tr>
<tr class="separator:gaa3c8db1c80c86912466e5f41440976e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga502c7593b8fd66f1d2d566da69d35aa9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga502c7593b8fd66f1d2d566da69d35aa9">XMC_SCU_INTERRUPT_EVENT_OSCSICTRL_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_OSCSICTRL_Msk</td></tr>
<tr class="separator:ga502c7593b8fd66f1d2d566da69d35aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9451749d951a975241a3f06a61f53c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gace9451749d951a975241a3f06a61f53c">XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_OSCULCTRL_Msk</td></tr>
<tr class="separator:gace9451749d951a975241a3f06a61f53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d73a9730bd1f494aba410294249b561"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga7d73a9730bd1f494aba410294249b561">XMC_SCU_INTERRUPT_EVENT_OSCULSTAT_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_OSCULSTAT_Msk</td></tr>
<tr class="separator:ga7d73a9730bd1f494aba410294249b561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec8f143f2c150b61329cbe4333ddc51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga9ec8f143f2c150b61329cbe4333ddc51">XMC_SCU_INTERRUPT_EVENT_RMX_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RMX_Msk</td></tr>
<tr class="separator:ga9ec8f143f2c150b61329cbe4333ddc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2de9ba5dfa78e350e552cc36529ad22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab2de9ba5dfa78e350e552cc36529ad22">XMC_SCU_INTERRUPT_EVENT_RTC_ALARM</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_AI_Msk</td></tr>
<tr class="separator:gab2de9ba5dfa78e350e552cc36529ad22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b86e6490dd0310069274f042ef47625"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga2b86e6490dd0310069274f042ef47625">XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_PI_Msk</td></tr>
<tr class="separator:ga2b86e6490dd0310069274f042ef47625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33dc60f1ff3285386633b53623dca92b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga33dc60f1ff3285386633b53623dca92b">XMC_SCU_INTERRUPT_EVENT_RTCATIM0_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RTC_ATIM0_Msk</td></tr>
<tr class="separator:ga33dc60f1ff3285386633b53623dca92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a78d87581dbbf3db6f3f23ee4db98e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga19a78d87581dbbf3db6f3f23ee4db98e">XMC_SCU_INTERRUPT_EVENT_RTCATIM1_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RTC_ATIM1_Msk</td></tr>
<tr class="separator:ga19a78d87581dbbf3db6f3f23ee4db98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07039df071591f92674bdd82fc735030"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga07039df071591f92674bdd82fc735030">XMC_SCU_INTERRUPT_EVENT_RTCCTR_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RTC_CTR_Msk</td></tr>
<tr class="separator:ga07039df071591f92674bdd82fc735030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34acc61e5b01e7f6b4ea1d7a9a9195c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga34acc61e5b01e7f6b4ea1d7a9a9195c9">XMC_SCU_INTERRUPT_EVENT_RTCTIM0_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RTC_TIM0_Msk</td></tr>
<tr class="separator:ga34acc61e5b01e7f6b4ea1d7a9a9195c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcaa73f61c18ec8237e076da6c3bc0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga7fcaa73f61c18ec8237e076da6c3bc0e">XMC_SCU_INTERRUPT_EVENT_RTCTIM1_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RTC_TIM1_Msk</td></tr>
<tr class="separator:ga7fcaa73f61c18ec8237e076da6c3bc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61bedea1698b39bbd1fa3d2cd79a9f33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga61bedea1698b39bbd1fa3d2cd79a9f33">XMC_SCU_INTERRUPT_EVENT_WDT_WARN</a>&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_PRWARN_Msk</td></tr>
<tr class="separator:ga61bedea1698b39bbd1fa3d2cd79a9f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typdefinitionen</h2></td></tr>
<tr class="memitem:ga4b50170c441fb21833c07a27b814a581"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a>) (void)</td></tr>
<tr class="separator:ga4b50170c441fb21833c07a27b814a581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18e68742408210603bed8d0806ce1573"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a></td></tr>
<tr class="separator:ga18e68742408210603bed8d0806ce1573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Aufzählungen</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funktionen</h2></td></tr>
<tr class="memitem:gacf86e99e8def2e37a0b484982e61256d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gacf86e99e8def2e37a0b484982e61256d">XMC_SCU_CalibrateTemperatureSensor</a> (uint32_t offset, uint32_t gain)</td></tr>
<tr class="separator:gacf86e99e8def2e37a0b484982e61256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f9078c8d5a83149c40812925f3c218d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0f9078c8d5a83149c40812925f3c218d">XMC_SCU_CLOCK_DisableClock</a> (const <a class="el" href="group___s_c_u.html#ga2bd90dc2daf0ff48625ab7b297b2cacd">XMC_SCU_CLOCK_t</a> clock)</td></tr>
<tr class="separator:ga0f9078c8d5a83149c40812925f3c218d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9465a7485ccf3e4aeb4739d4e2422dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad9465a7485ccf3e4aeb4739d4e2422dc">XMC_SCU_CLOCK_DisableHighPerformanceOscillator</a> (void)</td></tr>
<tr class="separator:gad9465a7485ccf3e4aeb4739d4e2422dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a4bbb5fa7a9f538428ef93a39b5d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga19a4bbb5fa7a9f538428ef93a39b5d99">XMC_SCU_CLOCK_DisableLowPowerOscillator</a> (void)</td></tr>
<tr class="separator:ga19a4bbb5fa7a9f538428ef93a39b5d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc3a5c5ed7095b25389ebc23705517a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gacc3a5c5ed7095b25389ebc23705517a3">XMC_SCU_CLOCK_DisableSystemPll</a> (void)</td></tr>
<tr class="separator:gacc3a5c5ed7095b25389ebc23705517a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ca204f398c5ae671ba9d59b5be2264c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6ca204f398c5ae671ba9d59b5be2264c">XMC_SCU_CLOCK_DisableUsbPll</a> (void)</td></tr>
<tr class="separator:ga6ca204f398c5ae671ba9d59b5be2264c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31001fdc4707eb901996074ee0c6fcff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga31001fdc4707eb901996074ee0c6fcff">XMC_SCU_CLOCK_EnableClock</a> (const <a class="el" href="group___s_c_u.html#ga2bd90dc2daf0ff48625ab7b297b2cacd">XMC_SCU_CLOCK_t</a> clock)</td></tr>
<tr class="separator:ga31001fdc4707eb901996074ee0c6fcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8179be793c17dda72a87dea440dd118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad8179be793c17dda72a87dea440dd118">XMC_SCU_CLOCK_EnableHighPerformanceOscillator</a> (void)</td></tr>
<tr class="separator:gad8179be793c17dda72a87dea440dd118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad827fd74357895b8387e896501f21579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad827fd74357895b8387e896501f21579">XMC_SCU_CLOCK_EnableLowPowerOscillator</a> (void)</td></tr>
<tr class="separator:gad827fd74357895b8387e896501f21579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga324e4c4bb68133279a6c8c50fe1a514e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga324e4c4bb68133279a6c8c50fe1a514e">XMC_SCU_CLOCK_EnableSystemPll</a> (void)</td></tr>
<tr class="separator:ga324e4c4bb68133279a6c8c50fe1a514e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89d0737a9026f17d0d55b6db74333f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa89d0737a9026f17d0d55b6db74333f5">XMC_SCU_CLOCK_EnableUsbPll</a> (void)</td></tr>
<tr class="separator:gaa89d0737a9026f17d0d55b6db74333f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0af70f90b9a1f24d3a0a4764543d833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock</a> (const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> peripheral)</td></tr>
<tr class="separator:gab0af70f90b9a1f24d3a0a4764543d833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabc40433a3a0c21f96993cfb6af038ae"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaabc40433a3a0c21f96993cfb6af038ae">XMC_SCU_CLOCK_GetCcuClockDivider</a> (void)</td></tr>
<tr class="separator:gaabc40433a3a0c21f96993cfb6af038ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22725a6c39f19f4089e45509e63f936e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga22725a6c39f19f4089e45509e63f936e">XMC_SCU_CLOCK_GetCcuClockFrequency</a> (void)</td></tr>
<tr class="separator:ga22725a6c39f19f4089e45509e63f936e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab537dadfc72161a06f4f6dfa85449ae6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab537dadfc72161a06f4f6dfa85449ae6">XMC_SCU_CLOCK_GetCpuClockDivider</a> (void)</td></tr>
<tr class="separator:gab537dadfc72161a06f4f6dfa85449ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e78410c4d0c9f9b54aa0965d16c3795"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency</a> (void)</td></tr>
<tr class="separator:ga3e78410c4d0c9f9b54aa0965d16c3795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12fce693c9f70eae932924cacedd3d6b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga12fce693c9f70eae932924cacedd3d6b">XMC_SCU_CLOCK_GetEbuClockDivider</a> (void)</td></tr>
<tr class="separator:ga12fce693c9f70eae932924cacedd3d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d21487445c6104d1362b45c3882877"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga70d21487445c6104d1362b45c3882877">XMC_SCU_CLOCK_GetEbuClockFrequency</a> (void)</td></tr>
<tr class="separator:ga70d21487445c6104d1362b45c3882877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720f80a8e2c129e7139c8bfec4afb962"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga720f80a8e2c129e7139c8bfec4afb962">XMC_SCU_CLOCK_GetECATClockDivider</a> (void)</td></tr>
<tr class="separator:ga720f80a8e2c129e7139c8bfec4afb962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2786257933663aa4c54f9dc7c97422d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#ga26a3f6ccc6fa98818df8efd7e487d7c0">XMC_SCU_CLOCK_ECATCLKSRC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga2786257933663aa4c54f9dc7c97422d4">XMC_SCU_CLOCK_GetECATClockSource</a> (void)</td></tr>
<tr class="separator:ga2786257933663aa4c54f9dc7c97422d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83d6d8e1bb269b8cccb8e700bd4a842a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency</a> (void)</td></tr>
<tr class="separator:ga83d6d8e1bb269b8cccb8e700bd4a842a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e64fe15f9ce0183a1bc5fba7bec579"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga24e64fe15f9ce0183a1bc5fba7bec579">XMC_SCU_CLOCK_GetExternalOutputClockDivider</a> (void)</td></tr>
<tr class="separator:ga24e64fe15f9ce0183a1bc5fba7bec579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8274d36f46ebb315665d30985b62611"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab8274d36f46ebb315665d30985b62611">XMC_SCU_CLOCK_GetExternalOutputClockFrequency</a> (void)</td></tr>
<tr class="separator:gab8274d36f46ebb315665d30985b62611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae80c027210bcf8cdafd0fe8aa3274777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gaaf5142b4b63fc9f6413c9deb3e7740a0">XMC_SCU_CLOCK_EXTOUTCLKSRC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae80c027210bcf8cdafd0fe8aa3274777">XMC_SCU_CLOCK_GetExternalOutputClockSource</a> (void)</td></tr>
<tr class="separator:gae80c027210bcf8cdafd0fe8aa3274777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae163ddda50d4e04337cc17b3a3aed1f7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae163ddda50d4e04337cc17b3a3aed1f7">XMC_SCU_CLOCK_GetPeripheralClockDivider</a> (void)</td></tr>
<tr class="separator:gae163ddda50d4e04337cc17b3a3aed1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a1be4f0e96fcda7b2c0feb542af250"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency</a> (void)</td></tr>
<tr class="separator:ga55a1be4f0e96fcda7b2c0feb542af250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700247f0d54ab409e0542547ce3546f9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga700247f0d54ab409e0542547ce3546f9">XMC_SCU_CLOCK_GetSystemClockDivider</a> (void)</td></tr>
<tr class="separator:ga700247f0d54ab409e0542547ce3546f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a9fd5e87ad27c874c88706ba43772c2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0a9fd5e87ad27c874c88706ba43772c2">XMC_SCU_CLOCK_GetSystemClockFrequency</a> (void)</td></tr>
<tr class="separator:ga0a9fd5e87ad27c874c88706ba43772c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6bbfbc0d075a0e3bab4c4906136fcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gaccffa04837e2b0c2132f74f3c502139b">XMC_SCU_CLOCK_SYSCLKSRC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0e6bbfbc0d075a0e3bab4c4906136fcb">XMC_SCU_CLOCK_GetSystemClockSource</a> (void)</td></tr>
<tr class="separator:ga0e6bbfbc0d075a0e3bab4c4906136fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c2602ab7184dbeda09e0ca0e690168"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae8c2602ab7184dbeda09e0ca0e690168">XMC_SCU_CLOCK_GetSystemPllClockFrequency</a> (void)</td></tr>
<tr class="separator:gae8c2602ab7184dbeda09e0ca0e690168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b75ab108bf4a3b1e153a339b77a62c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#ga91284bbc86bb476327771f3639cbe440">XMC_SCU_CLOCK_SYSPLLCLKSRC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga00b75ab108bf4a3b1e153a339b77a62c">XMC_SCU_CLOCK_GetSystemPllClockSource</a> (void)</td></tr>
<tr class="separator:ga00b75ab108bf4a3b1e153a339b77a62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcba51c9d61c4f3e8a3e1bc816c5fb02"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gabcba51c9d61c4f3e8a3e1bc816c5fb02">XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency</a> (void)</td></tr>
<tr class="separator:gabcba51c9d61c4f3e8a3e1bc816c5fb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga129a4c1cd0e4963b8a573c25485cd693"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga129a4c1cd0e4963b8a573c25485cd693">XMC_SCU_CLOCK_GetUsbClockDivider</a> (void)</td></tr>
<tr class="separator:ga129a4c1cd0e4963b8a573c25485cd693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12a425e40ac269c2b17a06100be6cf2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad12a425e40ac269c2b17a06100be6cf2">XMC_SCU_CLOCK_GetUsbClockFrequency</a> (void)</td></tr>
<tr class="separator:gad12a425e40ac269c2b17a06100be6cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65588bdfa384f0f3deca2553ca2205be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gaa25fc7c21af145300a57dd93c391816d">XMC_SCU_CLOCK_USBCLKSRC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga65588bdfa384f0f3deca2553ca2205be">XMC_SCU_CLOCK_GetUsbClockSource</a> (void)</td></tr>
<tr class="separator:ga65588bdfa384f0f3deca2553ca2205be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050ac1d63bf86241205c4fdcca3eb988"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga050ac1d63bf86241205c4fdcca3eb988">XMC_SCU_CLOCK_GetUsbPllClockFrequency</a> (void)</td></tr>
<tr class="separator:ga050ac1d63bf86241205c4fdcca3eb988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c044e6458ccab71e1d8c045719d545"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga12c044e6458ccab71e1d8c045719d545">XMC_SCU_CLOCK_GetWdtClockDivider</a> (void)</td></tr>
<tr class="separator:ga12c044e6458ccab71e1d8c045719d545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6266b7288cd6a209146d83d67f21b573"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6266b7288cd6a209146d83d67f21b573">XMC_SCU_CLOCK_GetWdtClockFrequency</a> (void)</td></tr>
<tr class="separator:ga6266b7288cd6a209146d83d67f21b573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ee4bbf7462c9e3d2e3b15d845136da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#ga77f22d4ceb0b920b48b87da63f62d174">XMC_SCU_CLOCK_WDTCLKSRC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae5ee4bbf7462c9e3d2e3b15d845136da">XMC_SCU_CLOCK_GetWdtClockSource</a> (void)</td></tr>
<tr class="separator:gae5ee4bbf7462c9e3d2e3b15d845136da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c337e8a728604e7eb54dff78ae2d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init</a> (const <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga08c337e8a728604e7eb54dff78ae2d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dd13c0aa61ed09a31f8137d28c4532"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga52dd13c0aa61ed09a31f8137d28c4532">XMC_SCU_CLOCK_IsClockEnabled</a> (const <a class="el" href="group___s_c_u.html#ga2bd90dc2daf0ff48625ab7b297b2cacd">XMC_SCU_CLOCK_t</a> clock)</td></tr>
<tr class="separator:ga52dd13c0aa61ed09a31f8137d28c4532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804f98badedf0e0ba4ce09f445687a37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated</a> (const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> peripheral)</td></tr>
<tr class="separator:ga804f98badedf0e0ba4ce09f445687a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b65db9f01407d2b3b98d5984ae09e71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3b65db9f01407d2b3b98d5984ae09e71">XMC_SCU_CLOCK_IsSystemPllLocked</a> (void)</td></tr>
<tr class="separator:ga3b65db9f01407d2b3b98d5984ae09e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab138fec040dc094a8a6579cfcaad2da8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab138fec040dc094a8a6579cfcaad2da8">XMC_SCU_CLOCK_IsUsbPllLocked</a> (void)</td></tr>
<tr class="separator:gab138fec040dc094a8a6579cfcaad2da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae09f0a2575e72f52d961ea5a4622cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga8ae09f0a2575e72f52d961ea5a4622cf">XMC_SCU_CLOCK_SetBackupClockCalibrationMode</a> (<a class="el" href="group___s_c_u.html#ga7ba412eed9b7e0f28d60090b5a53768d">XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t</a> mode)</td></tr>
<tr class="separator:ga8ae09f0a2575e72f52d961ea5a4622cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga222a00aedb2c6822f78f2794ef237f26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga222a00aedb2c6822f78f2794ef237f26">XMC_SCU_CLOCK_SetCcuClockDivider</a> (const uint32_t ratio)</td></tr>
<tr class="separator:ga222a00aedb2c6822f78f2794ef237f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d0a11b4d5cad0f4516afb8b3976ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaf5d0a11b4d5cad0f4516afb8b3976ca1">XMC_SCU_CLOCK_SetCpuClockDivider</a> (const uint32_t ratio)</td></tr>
<tr class="separator:gaf5d0a11b4d5cad0f4516afb8b3976ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb869f7d0e646d10680f2ca8eb4124c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gacb869f7d0e646d10680f2ca8eb4124c0">XMC_SCU_CLOCK_SetDeepSleepConfig</a> (uint32_t config)</td></tr>
<tr class="separator:gacb869f7d0e646d10680f2ca8eb4124c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4e4b167bff6189b508f9655693ca84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0d4e4b167bff6189b508f9655693ca84">XMC_SCU_CLOCK_SetEbuClockDivider</a> (const uint32_t ratio)</td></tr>
<tr class="separator:ga0d4e4b167bff6189b508f9655693ca84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20f63e6573fd17e9b0c05a004dcd499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa20f63e6573fd17e9b0c05a004dcd499">XMC_SCU_CLOCK_SetECATClockDivider</a> (const uint32_t divider)</td></tr>
<tr class="separator:gaa20f63e6573fd17e9b0c05a004dcd499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c721ac3ba6f1d066101176e103d5ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa7c721ac3ba6f1d066101176e103d5ff">XMC_SCU_CLOCK_SetECATClockSource</a> (const <a class="el" href="group___s_c_u.html#ga26a3f6ccc6fa98818df8efd7e487d7c0">XMC_SCU_CLOCK_ECATCLKSRC_t</a> source)</td></tr>
<tr class="separator:gaa7c721ac3ba6f1d066101176e103d5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga504e82a0763495f9d487ea0b0d5ebd7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga504e82a0763495f9d487ea0b0d5ebd7a">XMC_SCU_CLOCK_SetExternalOutputClockDivider</a> (const uint32_t ratio)</td></tr>
<tr class="separator:ga504e82a0763495f9d487ea0b0d5ebd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0e95e282cd20159627d036941caf0c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae0e95e282cd20159627d036941caf0c7">XMC_SCU_CLOCK_SetExternalOutputClockSource</a> (const <a class="el" href="group___s_c_u.html#gaaf5142b4b63fc9f6413c9deb3e7740a0">XMC_SCU_CLOCK_EXTOUTCLKSRC_t</a> clock)</td></tr>
<tr class="separator:gae0e95e282cd20159627d036941caf0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256245971cfb74c5260d5564bb01020a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga256245971cfb74c5260d5564bb01020a">XMC_SCU_CLOCK_SetPeripheralClockDivider</a> (const uint32_t ratio)</td></tr>
<tr class="separator:ga256245971cfb74c5260d5564bb01020a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14af7311359e751a90c08ca3c80d6777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga14af7311359e751a90c08ca3c80d6777">XMC_SCU_CLOCK_SetSleepConfig</a> (uint32_t config)</td></tr>
<tr class="separator:ga14af7311359e751a90c08ca3c80d6777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07a3504f85acd247cd7b9315dcc4083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae07a3504f85acd247cd7b9315dcc4083">XMC_SCU_CLOCK_SetSystemClockDivider</a> (const uint32_t divider)</td></tr>
<tr class="separator:gae07a3504f85acd247cd7b9315dcc4083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d37853e6609aa646b4dd1517fddd54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gac6d37853e6609aa646b4dd1517fddd54">XMC_SCU_CLOCK_SetSystemClockSource</a> (const <a class="el" href="group___s_c_u.html#gaccffa04837e2b0c2132f74f3c502139b">XMC_SCU_CLOCK_SYSCLKSRC_t</a> source)</td></tr>
<tr class="separator:gac6d37853e6609aa646b4dd1517fddd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab274b04a774d18a4a7305f43ffb71d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab274b04a774d18a4a7305f43ffb71d4e">XMC_SCU_CLOCK_SetSystemPllClockSource</a> (const <a class="el" href="group___s_c_u.html#ga91284bbc86bb476327771f3639cbe440">XMC_SCU_CLOCK_SYSPLLCLKSRC_t</a> source)</td></tr>
<tr class="separator:gab274b04a774d18a4a7305f43ffb71d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bfbeee9da8ba9c854c34fc5da9a7d7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6bfbeee9da8ba9c854c34fc5da9a7d7d">XMC_SCU_CLOCK_SetUsbClockDivider</a> (const uint32_t ratio)</td></tr>
<tr class="separator:ga6bfbeee9da8ba9c854c34fc5da9a7d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5332425bae1da209b9c6cc857f53d51e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga5332425bae1da209b9c6cc857f53d51e">XMC_SCU_CLOCK_SetUsbClockSource</a> (const <a class="el" href="group___s_c_u.html#gaa25fc7c21af145300a57dd93c391816d">XMC_SCU_CLOCK_USBCLKSRC_t</a> source)</td></tr>
<tr class="separator:ga5332425bae1da209b9c6cc857f53d51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f338f60cac7809fafd01b0941d1a2c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga8f338f60cac7809fafd01b0941d1a2c1">XMC_SCU_CLOCK_SetWdtClockDivider</a> (const uint32_t ratio)</td></tr>
<tr class="separator:ga8f338f60cac7809fafd01b0941d1a2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9061262a31285c0b5c3a13801650a453"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga9061262a31285c0b5c3a13801650a453">XMC_SCU_CLOCK_SetWdtClockSource</a> (const <a class="el" href="group___s_c_u.html#ga77f22d4ceb0b920b48b87da63f62d174">XMC_SCU_CLOCK_WDTCLKSRC_t</a> source)</td></tr>
<tr class="separator:ga9061262a31285c0b5c3a13801650a453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356a667144dc0009582198bad1070d7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga356a667144dc0009582198bad1070d7a">XMC_SCU_CLOCK_StartSystemPll</a> (<a class="el" href="group___s_c_u.html#ga91284bbc86bb476327771f3639cbe440">XMC_SCU_CLOCK_SYSPLLCLKSRC_t</a> source, <a class="el" href="group___s_c_u.html#gad0bc6581cbe44ad6b1d649cbffe96875">XMC_SCU_CLOCK_SYSPLL_MODE_t</a> mode, uint32_t pdiv, uint32_t ndiv, uint32_t kdiv)</td></tr>
<tr class="separator:ga356a667144dc0009582198bad1070d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5f410baf92504c4fc60bc33e167d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gacb5f410baf92504c4fc60bc33e167d9c">XMC_SCU_CLOCK_StartUsbPll</a> (uint32_t pdiv, uint32_t ndiv)</td></tr>
<tr class="separator:gacb5f410baf92504c4fc60bc33e167d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga381e223afdcbd3d2766a24958468dc0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga381e223afdcbd3d2766a24958468dc0f">XMC_SCU_CLOCK_StepSystemPllFrequency</a> (uint32_t kdiv)</td></tr>
<tr class="separator:ga381e223afdcbd3d2766a24958468dc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879eeaff71fe00dd7fc148b481ce8379"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga879eeaff71fe00dd7fc148b481ce8379">XMC_SCU_CLOCK_StopSystemPll</a> (void)</td></tr>
<tr class="separator:ga879eeaff71fe00dd7fc148b481ce8379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11067ab015e6a6632cf9be194a4f8d6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga11067ab015e6a6632cf9be194a4f8d6b">XMC_SCU_CLOCK_StopUsbPll</a> (void)</td></tr>
<tr class="separator:ga11067ab015e6a6632cf9be194a4f8d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702904d10b6e6c6a55db381763fd322f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock</a> (const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> peripheral)</td></tr>
<tr class="separator:ga702904d10b6e6c6a55db381763fd322f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf7bd240140468c6235149828dc3e7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gafbf7bd240140468c6235149828dc3e7e">XMC_SCU_DisableOutOfRangeComparator</a> (const uint32_t group, const uint32_t channel)</td></tr>
<tr class="separator:gafbf7bd240140468c6235149828dc3e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95190e4549898b0f02b653045d5816b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga95190e4549898b0f02b653045d5816b7">XMC_SCU_DisableTemperatureSensor</a> (void)</td></tr>
<tr class="separator:ga95190e4549898b0f02b653045d5816b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d593608a5e056fb40c1cc2b340fb2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga51d593608a5e056fb40c1cc2b340fb2a">XMC_SCU_EnableOutOfRangeComparator</a> (const uint32_t group, const uint32_t channel)</td></tr>
<tr class="separator:ga51d593608a5e056fb40c1cc2b340fb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f6a1e71b005175777c6dd9a069e325c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3f6a1e71b005175777c6dd9a069e325c">XMC_SCU_EnableTemperatureSensor</a> (void)</td></tr>
<tr class="separator:ga3f6a1e71b005175777c6dd9a069e325c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6d9572718fe6822b42522947fe822b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga2a6d9572718fe6822b42522947fe822b">XMC_SCU_GetBootMode</a> (void)</td></tr>
<tr class="separator:ga2a6d9572718fe6822b42522947fe822b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494b75a841498374cfee9664e6ce9cee"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga494b75a841498374cfee9664e6ce9cee">XMC_SCU_GetMirrorStatus</a> (void)</td></tr>
<tr class="separator:ga494b75a841498374cfee9664e6ce9cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ac62bd07097bb83cd294a1d6625af36"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga8ac62bd07097bb83cd294a1d6625af36">XMC_SCU_GetTemperatureMeasurement</a> (void)</td></tr>
<tr class="separator:ga8ac62bd07097bb83cd294a1d6625af36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c8ea8d8a577e936a3dde5239966337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae5c8ea8d8a577e936a3dde5239966337">XMC_SCU_HIB_DisableHibernateDomain</a> (void)</td></tr>
<tr class="separator:gae5c8ea8d8a577e936a3dde5239966337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09c64c2a7a15e6cba8b97de86c87c6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa09c64c2a7a15e6cba8b97de86c87c6e">XMC_SCU_HIB_DisableInternalSlowClock</a> (void)</td></tr>
<tr class="separator:gaa09c64c2a7a15e6cba8b97de86c87c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f73953dadc8eaa2fad5e66a2c2e57a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga2f73953dadc8eaa2fad5e66a2c2e57a4">XMC_SCU_HIB_EnableHibernateDomain</a> (void)</td></tr>
<tr class="separator:ga2f73953dadc8eaa2fad5e66a2c2e57a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa00ec6206d10e3840504ba592f5725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gadaa00ec6206d10e3840504ba592f5725">XMC_SCU_HIB_EnableInternalSlowClock</a> (void)</td></tr>
<tr class="separator:gadaa00ec6206d10e3840504ba592f5725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7d07fb799f33da6bd55dfec0938f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gad0408131d64c97d53a863b982225e664">XMC_SCU_HIB_RTCCLKSRC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaff7d07fb799f33da6bd55dfec0938f53">XMC_SCU_HIB_GetRtcClockSource</a> (void)</td></tr>
<tr class="separator:gaff7d07fb799f33da6bd55dfec0938f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893f5ed38bc3417a1b6482bda5031e0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gad0408131d64c97d53a863b982225e664">XMC_SCU_HIB_RTCCLKSRC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga893f5ed38bc3417a1b6482bda5031e0c">XMC_SCU_HIB_GetStdbyClockSource</a> (void)</td></tr>
<tr class="separator:ga893f5ed38bc3417a1b6482bda5031e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga725038f7765622ede258de69e21971a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga725038f7765622ede258de69e21971a4">XMC_SCU_HIB_IsHibernateDomainEnabled</a> (void)</td></tr>
<tr class="separator:ga725038f7765622ede258de69e21971a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadca7d1332ed62fda2a1a85550d12f06d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gadca7d1332ed62fda2a1a85550d12f06d">XMC_SCU_HIB_SetRtcClockSource</a> (const <a class="el" href="group___s_c_u.html#gad0408131d64c97d53a863b982225e664">XMC_SCU_HIB_RTCCLKSRC_t</a> source)</td></tr>
<tr class="separator:gadca7d1332ed62fda2a1a85550d12f06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387a75bbd0299d99fd8f818d1ea9886a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga387a75bbd0299d99fd8f818d1ea9886a">XMC_SCU_HIB_SetStandbyClockSource</a> (const <a class="el" href="group___s_c_u.html#ga8290034e7a28d8e2e8ed0086d6f92ab5">XMC_SCU_HIB_STDBYCLKSRC_t</a> source)</td></tr>
<tr class="separator:ga387a75bbd0299d99fd8f818d1ea9886a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0ad9c467d9549542d0f0275bae6314"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature</a> (void)</td></tr>
<tr class="separator:ga5a0ad9c467d9549542d0f0275bae6314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2e577339ff5af48261d18e0e41dc50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gabd2e577339ff5af48261d18e0e41dc50">XMC_SCU_INTERRUPT_ClearEventStatus</a> (const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> event)</td></tr>
<tr class="separator:gabd2e577339ff5af48261d18e0e41dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa814678729d6b7f41c558e768ba8ecd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa814678729d6b7f41c558e768ba8ecd4">XMC_SCU_INTERRUPT_DisableEvent</a> (const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> event)</td></tr>
<tr class="separator:gaa814678729d6b7f41c558e768ba8ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada4c1f90be9bb22b2b404d26fd88535c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gada4c1f90be9bb22b2b404d26fd88535c">XMC_SCU_INTERRUPT_DisableNmiRequest</a> (const uint32_t request)</td></tr>
<tr class="separator:gada4c1f90be9bb22b2b404d26fd88535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cfb9545d1e561e1f24aeaa69af821c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab4cfb9545d1e561e1f24aeaa69af821c">XMC_SCU_INTERRUPT_EnableEvent</a> (const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> event)</td></tr>
<tr class="separator:gab4cfb9545d1e561e1f24aeaa69af821c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9595d70f3cb1cd35b236afdd058c5895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest</a> (const uint32_t request)</td></tr>
<tr class="separator:ga9595d70f3cb1cd35b236afdd058c5895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae03c6bcc3ccade266b46d84f7715e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler</a> (const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> event, const <a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a> handler)</td></tr>
<tr class="separator:ga4ae03c6bcc3ccade266b46d84f7715e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55b2098ce803174e7dfd680d0c30728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent</a> (const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> event)</td></tr>
<tr class="separator:gaa55b2098ce803174e7dfd680d0c30728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23dfad3e5e11c78791e5d5a777c44a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus</a> (void)</td></tr>
<tr class="separator:gae23dfad3e5e11c78791e5d5a777c44a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba1ce317ce89edfea107893fbd8a0be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga9ba1ce317ce89edfea107893fbd8a0be">XMC_SCU_IRQHandler</a> (uint32_t sr_num)</td></tr>
<tr class="separator:ga9ba1ce317ce89edfea107893fbd8a0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09f2786f94680cc125ead431f3c4d9c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga09f2786f94680cc125ead431f3c4d9c4">XMC_SCU_IsTemperatureSensorBusy</a> (void)</td></tr>
<tr class="separator:ga09f2786f94680cc125ead431f3c4d9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedec5f2ce4cc799cad5026d5ec76a1f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaedec5f2ce4cc799cad5026d5ec76a1f2">XMC_SCU_IsTemperatureSensorEnabled</a> (void)</td></tr>
<tr class="separator:gaedec5f2ce4cc799cad5026d5ec76a1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57499ff739d75ea0f53f51d2fd51505"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gac57499ff739d75ea0f53f51d2fd51505">XMC_SCU_IsTemperatureSensorReady</a> (void)</td></tr>
<tr class="separator:gac57499ff739d75ea0f53f51d2fd51505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8573534003ebf11fbaa49e331238fb86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga8573534003ebf11fbaa49e331238fb86">XMC_SCU_LowTemperature</a> (void)</td></tr>
<tr class="separator:ga8573534003ebf11fbaa49e331238fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c564412ab3d6a5d43c4fde9035cf07f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0c564412ab3d6a5d43c4fde9035cf07f">XMC_SCU_PARITY_ClearStatus</a> (const uint32_t memory)</td></tr>
<tr class="separator:ga0c564412ab3d6a5d43c4fde9035cf07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae85c78b1d38fcd51069d4f2a131d280f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae85c78b1d38fcd51069d4f2a131d280f">XMC_SCU_PARITY_Disable</a> (const uint32_t memory)</td></tr>
<tr class="separator:gae85c78b1d38fcd51069d4f2a131d280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga763ff133611bd2b42456fa9e8f3e34af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga763ff133611bd2b42456fa9e8f3e34af">XMC_SCU_PARITY_DisableTrapGeneration</a> (const uint32_t memory)</td></tr>
<tr class="separator:ga763ff133611bd2b42456fa9e8f3e34af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab020813ed43c4a858e3866254546aca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab020813ed43c4a858e3866254546aca3">XMC_SCU_PARITY_Enable</a> (const uint32_t memory)</td></tr>
<tr class="separator:gab020813ed43c4a858e3866254546aca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef433d566f700f9106db98439af3f88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gafef433d566f700f9106db98439af3f88">XMC_SCU_PARITY_EnableTrapGeneration</a> (const uint32_t memory)</td></tr>
<tr class="separator:gafef433d566f700f9106db98439af3f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb74be3c54ea80b2fd25d20e143a299"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gabfb74be3c54ea80b2fd25d20e143a299">XMC_SCU_PARITY_GetStatus</a> (void)</td></tr>
<tr class="separator:gabfb74be3c54ea80b2fd25d20e143a299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf750b3451bbdd00820d54f25100bd75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gacf750b3451bbdd00820d54f25100bd75">XMC_SCU_POWER_DisableUsb</a> (void)</td></tr>
<tr class="separator:gacf750b3451bbdd00820d54f25100bd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d0a5061d139bb8e136316a2fcc98bab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4d0a5061d139bb8e136316a2fcc98bab">XMC_SCU_POWER_EnableUsb</a> (void)</td></tr>
<tr class="separator:ga4d0a5061d139bb8e136316a2fcc98bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315dd2a00d282eddb3056118c86e6da9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga315dd2a00d282eddb3056118c86e6da9">XMC_SCU_ReadFromRetentionMemory</a> (uint32_t address)</td></tr>
<tr class="separator:ga315dd2a00d282eddb3056118c86e6da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7000d0aa26ac656926b108b49e0f73d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa7000d0aa26ac656926b108b49e0f73d">XMC_SCU_ReadGPR</a> (const uint32_t index)</td></tr>
<tr class="separator:gaa7000d0aa26ac656926b108b49e0f73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00fa5e7e6ed73767de6f80b9a849543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab00fa5e7e6ed73767de6f80b9a849543">XMC_SCU_RESET_AssertPeripheralReset</a> (const <a class="el" href="group___s_c_u.html#ga8a897b11f9bf2e3cba0a33b127ee972a">XMC_SCU_PERIPHERAL_RESET_t</a> peripheral)</td></tr>
<tr class="separator:gab00fa5e7e6ed73767de6f80b9a849543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf9396e8b46be98f73999575d13bf6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4bf9396e8b46be98f73999575d13bf6d">XMC_SCU_RESET_ClearDeviceResetReason</a> (void)</td></tr>
<tr class="separator:ga4bf9396e8b46be98f73999575d13bf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88ad38d3473b139dafef29dc3ba5216"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gac88ad38d3473b139dafef29dc3ba5216">XMC_SCU_RESET_DeassertPeripheralReset</a> (const <a class="el" href="group___s_c_u.html#ga8a897b11f9bf2e3cba0a33b127ee972a">XMC_SCU_PERIPHERAL_RESET_t</a> peripheral)</td></tr>
<tr class="separator:gac88ad38d3473b139dafef29dc3ba5216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f779c81bdc29b44c644017a52aff300"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3f779c81bdc29b44c644017a52aff300">XMC_SCU_RESET_GetDeviceResetReason</a> (void)</td></tr>
<tr class="separator:ga3f779c81bdc29b44c644017a52aff300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09011e9b100f1a164c3b908cc9bdf77f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga09011e9b100f1a164c3b908cc9bdf77f">XMC_SCU_RESET_IsPeripheralResetAsserted</a> (const <a class="el" href="group___s_c_u.html#ga8a897b11f9bf2e3cba0a33b127ee972a">XMC_SCU_PERIPHERAL_RESET_t</a> peripheral)</td></tr>
<tr class="separator:ga09011e9b100f1a164c3b908cc9bdf77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ebb50291e4fc5722746f2f40fadb6a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3ebb50291e4fc5722746f2f40fadb6a8">XMC_SCU_SetBootMode</a> (const <a class="el" href="group___s_c_u.html#gaee17d2349a9e695f89aaa67972035bb6">XMC_SCU_BOOTMODE_t</a> mode)</td></tr>
<tr class="separator:ga3ebb50291e4fc5722746f2f40fadb6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10ca2cd72477476ffe38a4818bcae4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gac10ca2cd72477476ffe38a4818bcae4b">XMC_SCU_SetCcuTriggerHigh</a> (const uint32_t trigger)</td></tr>
<tr class="separator:gac10ca2cd72477476ffe38a4818bcae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53300d587bbd03bc34c5a4396f5a34b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow</a> (const uint32_t trigger)</td></tr>
<tr class="separator:ga53300d587bbd03bc34c5a4396f5a34b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f600fa31f024ec9d8e0c17fc767772f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits</a> (const uint32_t lower_temp, const uint32_t upper_temp)</td></tr>
<tr class="separator:ga0f600fa31f024ec9d8e0c17fc767772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac9292e193c9804b5a6856de186737e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gabac9292e193c9804b5a6856de186737e">XMC_SCU_StartTemperatureMeasurement</a> (void)</td></tr>
<tr class="separator:gabac9292e193c9804b5a6856de186737e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fef80ad14de7e792696cbd892b1ad26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6fef80ad14de7e792696cbd892b1ad26">XMC_SCU_TRAP_ClearStatus</a> (const uint32_t trap)</td></tr>
<tr class="separator:ga6fef80ad14de7e792696cbd892b1ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb00024734804883905d6a423f69a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gacfb00024734804883905d6a423f69a39">XMC_SCU_TRAP_Disable</a> (const uint32_t trap)</td></tr>
<tr class="separator:gacfb00024734804883905d6a423f69a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a3e55dedfde788f1ba5e3bad7fdb4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga51a3e55dedfde788f1ba5e3bad7fdb4e">XMC_SCU_TRAP_Enable</a> (const uint32_t trap)</td></tr>
<tr class="separator:ga51a3e55dedfde788f1ba5e3bad7fdb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada772bc64ad61ae19612224ae7f3855c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gada772bc64ad61ae19612224ae7f3855c">XMC_SCU_TRAP_GetStatus</a> (void)</td></tr>
<tr class="separator:gada772bc64ad61ae19612224ae7f3855c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706f23b13aabcbcd5ad3ece9cf77a58f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga706f23b13aabcbcd5ad3ece9cf77a58f">XMC_SCU_TRAP_Trigger</a> (const uint32_t trap)</td></tr>
<tr class="separator:ga706f23b13aabcbcd5ad3ece9cf77a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0681ca8911f106c0c9f6fd65db89e1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad0681ca8911f106c0c9f6fd65db89e1c">XMC_SCU_WriteGPR</a> (const uint32_t index, const uint32_t data)</td></tr>
<tr class="separator:gad0681ca8911f106c0c9f6fd65db89e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab835560fc4cd24d8f03043d39e52b5ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab835560fc4cd24d8f03043d39e52b5ac">XMC_SCU_WriteToRetentionMemory</a> (uint32_t address, uint32_t data)</td></tr>
<tr class="separator:gab835560fc4cd24d8f03043d39e52b5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Ausführliche Beschreibung</h2>
<p>System control unit is the SoC power, reset and a clock manager with additional responsibility of providing system stability protection and other auxiliary functions.<br />
 SCU provides the following features,</p><ol type="1">
<li>Power control</li>
<li>Hibernate control</li>
<li>Reset control</li>
<li>Clock control</li>
<li>Miscellaneous control(boot mode, system interrupts etc.)<br />
<br />
</li>
</ol>
<p>The SCU driver is divided in to clock control logic, reset control logic, system interrupt control logic , hibernate control logic, trap control logic, parity control logic and miscellaneous control logic.<br />
</p>
<p>Clock driver features:</p><ol type="1">
<li>Allows clock configuration using the structure <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> and API <a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init()</a></li>
<li>Provides structure <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___s_y_s_p_l_l___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_SYSPLL_CONFIG_t</a> for configuring the system PLL</li>
<li>Allows selection of clock source for system PLL, <a class="el" href="group___s_c_u.html#ga00b75ab108bf4a3b1e153a339b77a62c">XMC_SCU_CLOCK_GetSystemPllClockSource()</a></li>
<li>Provides APIs for configuring different module clock frequencies <a class="el" href="group___s_c_u.html#ga8f338f60cac7809fafd01b0941d1a2c1">XMC_SCU_CLOCK_SetWdtClockDivider()</a>, <a class="el" href="group___s_c_u.html#ga6bfbeee9da8ba9c854c34fc5da9a7d7d">XMC_SCU_CLOCK_SetUsbClockDivider()</a></li>
<li>Allows selection of clock source for external output, <a class="el" href="group___s_c_u.html#gae0e95e282cd20159627d036941caf0c7">XMC_SCU_CLOCK_SetExternalOutputClockSource()</a></li>
<li>Provides APIs for enabling external high power oscillator and ultra low power oscillator, <a class="el" href="group___s_c_u.html#gad8179be793c17dda72a87dea440dd118">XMC_SCU_CLOCK_EnableHighPerformanceOscillator()</a>, <a class="el" href="group___s_c_u.html#gad827fd74357895b8387e896501f21579">XMC_SCU_CLOCK_EnableLowPowerOscillator()</a></li>
<li>Provides APIs for getting various clock frequencies <a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga0a9fd5e87ad27c874c88706ba43772c2">XMC_SCU_CLOCK_GetSystemClockFrequency()</a><br />
</li>
</ol>
<p>Reset driver features:</p><ol type="1">
<li>Allows to handle peripheral reset <a class="el" href="group___s_c_u.html#gab00fa5e7e6ed73767de6f80b9a849543">XMC_SCU_RESET_AssertPeripheralReset()</a>, <a class="el" href="group___s_c_u.html#gac88ad38d3473b139dafef29dc3ba5216">XMC_SCU_RESET_DeassertPeripheralReset()</a></li>
<li>Allows configuration of NMI generation for selected events, <a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest()</a> <br />
</li>
</ol>
<p>Interrupt driver features:</p><ol type="1">
<li>Provides APIs for enabling/ disabling interrupt event generation <a class="el" href="group___s_c_u.html#gab4cfb9545d1e561e1f24aeaa69af821c">XMC_SCU_INTERRUPT_EnableEvent()</a>, <a class="el" href="group___s_c_u.html#gaa814678729d6b7f41c558e768ba8ecd4">XMC_SCU_INTERRUPT_DisableEvent()</a></li>
<li>Provides API for registering callback function for events <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a><br />
</li>
</ol>
<p>Hibernate driver features:</p><ol type="1">
<li>Allows configuration of hibernate domain <a class="el" href="group___s_c_u.html#ga2f73953dadc8eaa2fad5e66a2c2e57a4">XMC_SCU_HIB_EnableHibernateDomain()</a>, <a class="el" href="group___s_c_u.html#gae5c8ea8d8a577e936a3dde5239966337">XMC_SCU_HIB_DisableHibernateDomain()</a></li>
<li>Allows selection of standby clock source, <a class="el" href="group___s_c_u.html#ga387a75bbd0299d99fd8f818d1ea9886a">XMC_SCU_HIB_SetStandbyClockSource()</a></li>
<li>Allows selection of RTC clock source, <a class="el" href="group___s_c_u.html#gadca7d1332ed62fda2a1a85550d12f06d">XMC_SCU_HIB_SetRtcClockSource()</a></li>
<li>Provides API for enabling slow internal clock used for backup clock, <a class="el" href="group___s_c_u.html#gadaa00ec6206d10e3840504ba592f5725">XMC_SCU_HIB_EnableInternalSlowClock()</a><br />
</li>
</ol>
<p>Trap driver features:</p><ol type="1">
<li>Allows handling of trap <a class="el" href="group___s_c_u.html#ga51a3e55dedfde788f1ba5e3bad7fdb4e">XMC_SCU_TRAP_Enable()</a>, <a class="el" href="group___s_c_u.html#gada772bc64ad61ae19612224ae7f3855c">XMC_SCU_TRAP_GetStatus()</a>, <a class="el" href="group___s_c_u.html#ga706f23b13aabcbcd5ad3ece9cf77a58f">XMC_SCU_TRAP_Trigger()</a><br />
</li>
</ol>
<p>Parity driver features:</p><ol type="1">
<li>Parity error generated by on-chip RAM can be monitored, <a class="el" href="group___s_c_u.html#gab020813ed43c4a858e3866254546aca3">XMC_SCU_PARITY_Enable()</a>, <a class="el" href="group___s_c_u.html#gabfb74be3c54ea80b2fd25d20e143a299">XMC_SCU_PARITY_GetStatus()</a></li>
<li>Allows configuration of trap generation on detection of parity error, <a class="el" href="group___s_c_u.html#gafef433d566f700f9106db98439af3f88">XMC_SCU_PARITY_EnableTrapGeneration()</a></li>
</ol>
<p>Power driver features:</p><ol type="1">
<li>Allows to power the USB module <a class="el" href="group___s_c_u.html#ga4d0a5061d139bb8e136316a2fcc98bab">XMC_SCU_POWER_EnableUsb()</a>, <a class="el" href="group___s_c_u.html#gacf750b3451bbdd00820d54f25100bd75">XMC_SCU_POWER_DisableUsb()</a></li>
</ol>
<p>Miscellaneous features:</p><ol type="1">
<li>Allows to trigger multiple capture compare unit(CCU) channels to be started together <a class="el" href="group___s_c_u.html#gac10ca2cd72477476ffe38a4818bcae4b">XMC_SCU_SetCcuTriggerHigh()</a></li>
<li>Enables configuration of out of range comparator (ORC) <a class="el" href="group___s_c_u.html#ga51d593608a5e056fb40c1cc2b340fb2a">XMC_SCU_EnableOutOfRangeComparator()</a></li>
<li>Enables configuration of die temperature sensor <a class="el" href="group___s_c_u.html#ga3f6a1e71b005175777c6dd9a069e325c">XMC_SCU_EnableTemperatureSensor()</a>, <a class="el" href="group___s_c_u.html#gacf86e99e8def2e37a0b484982e61256d">XMC_SCU_CalibrateTemperatureSensor()</a></li>
<li>Enables configuration of device boot mode <a class="el" href="group___s_c_u.html#ga3ebb50291e4fc5722746f2f40fadb6a8">XMC_SCU_SetBootMode()</a><br />
 </li>
</ol>
<h2 class="groupheader">Makro-Dokumentation</h2>
<a class="anchor" id="gab645bf93d140a469fb94f5a50b81043c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_DLR_OVERRUN&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_DLROVR_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DLR overrun event. </p>

</div>
</div>
<a class="anchor" id="ga5350d7ebb5bdbec5b511a8bada81e418"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_HDCLR_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB HDCLR register update event. </p>

</div>
</div>
<a class="anchor" id="ga7c1ff0412abb2208a9b5186760d86ef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_HDCR_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB HDCR register update event. </p>

</div>
</div>
<a class="anchor" id="ga95958fca048b8558aca91badd5782e82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_HDSET_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_HDSET_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB HDSET register update event. </p>

</div>
</div>
<a class="anchor" id="gaa3c8db1c80c86912466e5f41440976e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_HDSTAT_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_HDSTAT_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB HDSTAT register update event. </p>

</div>
</div>
<a class="anchor" id="ga502c7593b8fd66f1d2d566da69d35aa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_OSCSICTRL_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_OSCSICTRL_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB OSCSICTRL register update event. </p>

</div>
</div>
<a class="anchor" id="gace9451749d951a975241a3f06a61f53c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_OSCULCTRL_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB OSCULCTRL register update event. </p>

</div>
</div>
<a class="anchor" id="ga7d73a9730bd1f494aba410294249b561"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_OSCULSTAT_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_OSCULSTAT_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB OSCULSTAT register update event. </p>

</div>
</div>
<a class="anchor" id="ga9ec8f143f2c150b61329cbe4333ddc51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RMX_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RMX_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB RMX register update event. </p>

</div>
</div>
<a class="anchor" id="gab2de9ba5dfa78e350e552cc36529ad22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTC_ALARM&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_AI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTC alarm event. </p>

</div>
</div>
<a class="anchor" id="ga2b86e6490dd0310069274f042ef47625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_PI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTC periodic interrupt. </p>

</div>
</div>
<a class="anchor" id="ga33dc60f1ff3285386633b53623dca92b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTCATIM0_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RTC_ATIM0_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB RTCATIM0 register update event. </p>

</div>
</div>
<a class="anchor" id="ga19a78d87581dbbf3db6f3f23ee4db98e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTCATIM1_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RTC_ATIM1_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB RTCATIM1 register update event. </p>

</div>
</div>
<a class="anchor" id="ga07039df071591f92674bdd82fc735030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTCCTR_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RTC_CTR_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB RTCCTR register update event. </p>

</div>
</div>
<a class="anchor" id="ga34acc61e5b01e7f6b4ea1d7a9a9195c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTCTIM0_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RTC_TIM0_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB TIM0 register update event. </p>

</div>
</div>
<a class="anchor" id="ga7fcaa73f61c18ec8237e076da6c3bc0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTCTIM1_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_RTC_TIM1_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HIB TIM1 register update event. </p>

</div>
</div>
<a class="anchor" id="ga61bedea1698b39bbd1fa3d2cd79a9f33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_WDT_WARN&#160;&#160;&#160;SCU_INTERRUPT_SRSTAT_PRWARN_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Watchdog prewarning event. </p>

</div>
</div>
<h2 class="groupheader">Dokumentation der benutzerdefinierten Typen</h2>
<a class="anchor" id="ga4b50170c441fb21833c07a27b814a581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XMC_SCU_INTERRUPT_EVENT_HANDLER_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer type used for registering callback functions on SCU event occurrence. </p>

</div>
</div>
<a class="anchor" id="ga18e68742408210603bed8d0806ce1573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines enumerations for events which can lead to interrupt. These enumeration values represent the status of one of the bits in <em>SRSTAT</em> register. Use type <em>XMC_SCU_INTERRUPT_EVENT_t</em> for accessing these enum parameters. </p>

</div>
</div>
<h2 class="groupheader">Dokumentation der Aufzählungstypen</h2>
<a class="anchor" id="gaee17d2349a9e695f89aaa67972035bb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gaee17d2349a9e695f89aaa67972035bb6">XMC_SCU_BOOTMODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for selecting device boot mode. These enums are used to configure <em>SWCON</em> bits of <em>STCON</em> register. User can choose among various boot modes by configuring SWCON bits. Use type <em>XMC_SCU_BOOTMODE_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaee17d2349a9e695f89aaa67972035bb6a356f43937f5b8c1b645e397cd5f9d472"></a>XMC_SCU_BOOTMODE_NORMAL&#160;</td><td class="fielddoc">
<p>Boot from start of flash. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaee17d2349a9e695f89aaa67972035bb6a43012a7d194983b13f5395978f211856"></a>XMC_SCU_BOOTMODE_ASC_BSL&#160;</td><td class="fielddoc">
<p>UART bootstrap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaee17d2349a9e695f89aaa67972035bb6a3a6a3ee2f5707b70bbf3ed1f52433130"></a>XMC_SCU_BOOTMODE_BMI&#160;</td><td class="fielddoc">
<p>Boot Mode Index - Customized boot sequence. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaee17d2349a9e695f89aaa67972035bb6a1251cc9c5f1230b2d04e03597ea4da3c"></a>XMC_SCU_BOOTMODE_CAN_BSL&#160;</td><td class="fielddoc">
<p>CAN bootstrap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaee17d2349a9e695f89aaa67972035bb6a7d3ce72b7b54b6dd42e7104b9b1f0222"></a>XMC_SCU_BOOTMODE_PSRAM_BOOT&#160;</td><td class="fielddoc">
<p>Boot from PSRAM. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaee17d2349a9e695f89aaa67972035bb6aa95c8184ede7372b598b702103e42eda"></a>XMC_SCU_BOOTMODE_ABM0&#160;</td><td class="fielddoc">
<p>Boot from flash - fixed alternative address 0. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaee17d2349a9e695f89aaa67972035bb6a9d94cd67b30c41af733f5b1bb0113fb1"></a>XMC_SCU_BOOTMODE_ABM1&#160;</td><td class="fielddoc">
<p>Boot from flash - fixed alternative address 1. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaee17d2349a9e695f89aaa67972035bb6a7a98097217ed6f88409a458ca43bb080"></a>XMC_SCU_BOOTMODE_FABM&#160;</td><td class="fielddoc">
<p>fallback Alternate Boot Mode (ABM) - Try ABM-0 then try ABM-1. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga51850699f03c906a5fefcc4f04c6b2c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines Capture/Compare unit timer slice trigger, that enables synchronous start function available on the <em>SCU</em>, CCUCON register. Use type <em>XMC_SCU_CCU_TRIGGER_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga51850699f03c906a5fefcc4f04c6b2c1ab9e67fe77a9a1219bd0d4594c3f7a0ea"></a>XMC_SCU_CCU_TRIGGER_CCU40&#160;</td><td class="fielddoc">
<p>Trigger mask used for Global Start Control of CCU40 peripheral. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga51850699f03c906a5fefcc4f04c6b2c1ae5aa55222489a096c454eb0ce95e1bf2"></a>XMC_SCU_CCU_TRIGGER_CCU80&#160;</td><td class="fielddoc">
<p>Trigger mask used for Global Start Control of CCU80 peripheral. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga5a00552e019ebfb3f3ded0ac0c52d324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga5a00552e019ebfb3f3ded0ac0c52d324">XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324abb7be28ea7ac410261ae838f682b98db"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_SYSCLK_FOFI&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_SYSCLK_FOFI. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324a24bc5c51ad6f0839d037b85c86798167"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_SYSCLK_FPLL&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_SYSCLK_FPLL. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324add2138f379b3d29101c722aaa92f0507"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_FLASH_POWERDOWN&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_FLASH_POWERDOWN. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324a2106d720a1214d1fee5e77e25a92a135"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_PLL_POWERDOWN&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_PLL_POWERDOWN. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324a666c1ee2dd56b6ab2a85d9d3f0750910"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_VCO_POWERDOWN&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_VCO_POWERDOWN. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324a15dd761ddf9cd11f834710ba77222c13"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_USB&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_USB. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324a05683f35720a055da8325a162024ca6c"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_SDMMC&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_SDMMC. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324ad645aeb9debd59b2f8ca55ad6619137b"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_ETH&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_ETH. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324a3a1808e0e524a8415766ce83ab564cca"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_EBU&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_EBU. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324a5ba39c27d3089d46c65f17576a8eab9d"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_CCU&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_CCU. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a00552e019ebfb3f3ded0ac0c52d324aafe2d6e092f55373521f1d69a7df54d7"></a>XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_WDT&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_WDT. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga26a3f6ccc6fa98818df8efd7e487d7c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga26a3f6ccc6fa98818df8efd7e487d7c0">XMC_SCU_CLOCK_ECATCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for selecting the ECAT clock source. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga26a3f6ccc6fa98818df8efd7e487d7c0acfe959797554e13450d5047bc303850c"></a>XMC_SCU_CLOCK_ECATCLKSRC_USBPLL&#160;</td><td class="fielddoc">
<p>USB PLL (fUSBPLL) as a source for ECAT clock. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga26a3f6ccc6fa98818df8efd7e487d7c0a1a7b3bac723e37553c83298204dc7c43"></a>XMC_SCU_CLOCK_ECATCLKSRC_SYSPLL&#160;</td><td class="fielddoc">
<p>Main PLL output (fPLL) as a source for ECAT clock. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaaf5142b4b63fc9f6413c9deb3e7740a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gaaf5142b4b63fc9f6413c9deb3e7740a0">XMC_SCU_CLOCK_EXTOUTCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for selecting the source of external clock out (fEXT). These enums are used to configure <em>ECKSEL</em> bits of <em>EXTCLKCR</em> register. User can choose either fSYS or fPLL or fUSBPLL clock as a source for external clock out (fEXT). Use type <em>XMC_SCU_CLOCK_EXTOUTCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaaf5142b4b63fc9f6413c9deb3e7740a0ac15a557c19634848803fcf01e3f2f5b3"></a>XMC_SCU_CLOCK_EXTOUTCLKSRC_SYS&#160;</td><td class="fielddoc">
<p>System clock (fSYS) as the source for external clock out (fEXT). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaaf5142b4b63fc9f6413c9deb3e7740a0a92a58df18906972b786a85c88df65141"></a>XMC_SCU_CLOCK_EXTOUTCLKSRC_USB&#160;</td><td class="fielddoc">
<p>USB PLL output(fUSB PLL) as the source for external clock out (fEXT). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaaf5142b4b63fc9f6413c9deb3e7740a0a42c6903e304281e63b4dca0aceff6859"></a>XMC_SCU_CLOCK_EXTOUTCLKSRC_PLL&#160;</td><td class="fielddoc">
<p>Main PLL output(fPLL) as the source for external clock out (fEXT). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7ba412eed9b7e0f28d60090b5a53768d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga7ba412eed9b7e0f28d60090b5a53768d">XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for backup clock trimming. These enums are used to configure <em>AOTREN</em> <em>FOTR</em> bits of <em>PLLCON0</em> register. Use type <em>XMC_SCU_CLOCK_BACKUP_TRIM_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7ba412eed9b7e0f28d60090b5a53768da14df677f6d1d5ca724913581ebf2eb73"></a>XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_FACTORY&#160;</td><td class="fielddoc">
<p>Factory Oscillator Calibration: Force adjustment of the internal oscillator with the firmware defined values. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7ba412eed9b7e0f28d60090b5a53768da6acf21fd18be2ff4e437f71950c30324"></a>XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC&#160;</td><td class="fielddoc">
<p>Automatic Oscillator Calibration adjustment of the fOFI clock with fSTDBY clock. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga89194aa42c041fa1e72c1a3da8dbdef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga89194aa42c041fa1e72c1a3da8dbdef8">XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga89194aa42c041fa1e72c1a3da8dbdef8a6c72ebd7125eaa96a643ca27d175173d"></a>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_SYSCLK_FOFI&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_SYSCLK_FOFI. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga89194aa42c041fa1e72c1a3da8dbdef8ae2f0700a740030d26e189332cbe642ea"></a>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_SYSCLK_FPLL&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_SYSCLK_FPLL. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga89194aa42c041fa1e72c1a3da8dbdef8a02279e8dd80ece4259fd481d82b4300d"></a>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_USB&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_USB. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga89194aa42c041fa1e72c1a3da8dbdef8ac6d3bdb292b6a1fc42d9b4457d393baf"></a>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_SDMMC&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_SDMMC. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga89194aa42c041fa1e72c1a3da8dbdef8a91982488cc35c45c98831ddd29d7c18b"></a>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_ETH&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_ETH. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga89194aa42c041fa1e72c1a3da8dbdef8a0cfeab885f3bfbbb2dd2e4b017af77ec"></a>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_EBU&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_EBU. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga89194aa42c041fa1e72c1a3da8dbdef8a059a47c7287ee0f465f0a25585f5e637"></a>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_CCU&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_CCU. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga89194aa42c041fa1e72c1a3da8dbdef8ab4c0828a89c01fce6a320da4fdd23d63"></a>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_WDT&#160;</td><td class="fielddoc">
<p>XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_WDT. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaccffa04837e2b0c2132f74f3c502139b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gaccffa04837e2b0c2132f74f3c502139b">XMC_SCU_CLOCK_SYSCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for system clock (fSYS) source. These enums are used to configure <em>SYSSEL</em> bits of <em>SYSCLKCR</em> Clock Control Register. Use type <em>XMC_SCU_CLOCK_SYSCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaccffa04837e2b0c2132f74f3c502139ba76d7434b48f7728c2de246533fa458df"></a>XMC_SCU_CLOCK_SYSCLKSRC_OFI&#160;</td><td class="fielddoc">
<p>Internal Fast Clock (fOFI) as a source for system clock (fSYS). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaccffa04837e2b0c2132f74f3c502139badda85eae72f715c9d96128a52bafe5c9"></a>XMC_SCU_CLOCK_SYSCLKSRC_PLL&#160;</td><td class="fielddoc">
<p>PLL output (fPLL) as a source for system clock (fSYS). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gad0bc6581cbe44ad6b1d649cbffe96875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gad0bc6581cbe44ad6b1d649cbffe96875">XMC_SCU_CLOCK_SYSPLL_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines various PLL modes of operation. These enums are used to configure <em>VCOBYP</em> bit of <em>PLLCON0</em> register. User can choose either normal or prescalar mode by configuring VCOBYP bit. Use type <em>XMC_SCU_PLL_MODE_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggad0bc6581cbe44ad6b1d649cbffe96875a13594a59c97a6cb8404de58a2a44c029"></a>XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED&#160;</td><td class="fielddoc">
<p>fPLL derived from fOSC and PLL operating in prescalar mode(i.e.VCO bypassed). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad0bc6581cbe44ad6b1d649cbffe96875a71ff2dabf5ecbf6010cba347710e1438"></a>XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL&#160;</td><td class="fielddoc">
<p>fPLL derived from fVCO and PLL operating in normal mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad0bc6581cbe44ad6b1d649cbffe96875a09dbd0b32d77b9cbe2b353d80fc8fd1d"></a>XMC_SCU_CLOCK_SYSPLL_MODE_PRESCALAR&#160;</td><td class="fielddoc">
<p>fPLL derived from fOSC and PLL operating in prescalar mode(i.e.VCO bypassed). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga91284bbc86bb476327771f3639cbe440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga91284bbc86bb476327771f3639cbe440">XMC_SCU_CLOCK_SYSPLLCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for selecting the P-Divider input frequency. These enums are used to configure <em>PINSEL</em> bits of <em>PLLCON2</em> register. Use type <em>XMC_SCU_CLOCK_OSCCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga91284bbc86bb476327771f3639cbe440a8a828ad9bc8ac397c2c68dd4cb703a6f"></a>XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP&#160;</td><td class="fielddoc">
<p>External crystal oscillator (fOHP) as the source for P-Divider. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91284bbc86bb476327771f3639cbe440a8126bd0d0703cd1c35edb9afd52e821c"></a>XMC_SCU_CLOCK_SYSPLLCLKSRC_OFI&#160;</td><td class="fielddoc">
<p>Backup clock(fOFI) as the source for P-Divider. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga2bd90dc2daf0ff48625ab7b297b2cacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga2bd90dc2daf0ff48625ab7b297b2cacd">XMC_SCU_CLOCK_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines enumerations for disabling the clocks sources of peripherals. Disabling of the peripheral clock is configured via the <em>CLKCLR</em> registers. Use type <em>XMC_SCU_PERIPHERAL_CLOCK_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga2bd90dc2daf0ff48625ab7b297b2cacdaec80b1a0120591c20aaa28b7fcebe879"></a>XMC_SCU_CLOCK_USB&#160;</td><td class="fielddoc">
<p>USB module clock. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2bd90dc2daf0ff48625ab7b297b2cacdaf0d53d76990a8f82da350b1c9e93ce5f"></a>XMC_SCU_CLOCK_MMC&#160;</td><td class="fielddoc">
<p>MMC module clock. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2bd90dc2daf0ff48625ab7b297b2cacdaf712007d69fe05782cfcb16a1eabde29"></a>XMC_SCU_CLOCK_ETH&#160;</td><td class="fielddoc">
<p>Ethernet module clock. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2bd90dc2daf0ff48625ab7b297b2cacdae662acca97237b36e1295d9ff9fed395"></a>XMC_SCU_CLOCK_EBU&#160;</td><td class="fielddoc">
<p>EBU module clock. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2bd90dc2daf0ff48625ab7b297b2cacdab649d2e78a8522355c7373f7c95407be"></a>XMC_SCU_CLOCK_CCU&#160;</td><td class="fielddoc">
<p>CCU module clock. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2bd90dc2daf0ff48625ab7b297b2cacda14737d737a93d5bcd3401dc3033e56a6"></a>XMC_SCU_CLOCK_WDT&#160;</td><td class="fielddoc">
<p>WDT module clock. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaa25fc7c21af145300a57dd93c391816d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gaa25fc7c21af145300a57dd93c391816d">XMC_SCU_CLOCK_USBCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for selecting the USB clock source(fUSB/fSDMMC). These enums are used to configure <em>USBSEL</em> bits of <em>USBCLKCR</em> register. User can choose either fPLL or fUSBPLL clock as a source for USB clock. Use type <em>XMC_SCU_CLOCK_USBCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaa25fc7c21af145300a57dd93c391816dab86ed8cbb94eb9390d61aa94df5b7461"></a>XMC_SCU_CLOCK_USBCLKSRC_USBPLL&#160;</td><td class="fielddoc">
<p>USB PLL(fUSB PLL) as a source for USB clock (fUSB/fSDMMC). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa25fc7c21af145300a57dd93c391816da451e195a57276d5ef1fb34e275cae51b"></a>XMC_SCU_CLOCK_USBCLKSRC_SYSPLL&#160;</td><td class="fielddoc">
<p>Main PLL output (fPLL) as a source for USB clock (fUSB/fSDMMC). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga77f22d4ceb0b920b48b87da63f62d174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga77f22d4ceb0b920b48b87da63f62d174">XMC_SCU_CLOCK_WDTCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for selecting the source of WDT clock(fWDT). These enums are used to configure <em>WDTSEL</em> bits of <em>WDTCLKCR</em> register. User can choose either fOFI or fPLL or fSTDBY clock as a source for WDT clock. Use type <em>XMC_SCU_CLOCK_USBCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga77f22d4ceb0b920b48b87da63f62d174ae0d64bcb5c71dd2d9c9fdf8ff11cb73d"></a>XMC_SCU_CLOCK_WDTCLKSRC_OFI&#160;</td><td class="fielddoc">
<p>Internal Fast Clock (fOFI) as the source for WDT clock (fWDT). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga77f22d4ceb0b920b48b87da63f62d174a145b032645cb6d43c6617dd26e7f9087"></a>XMC_SCU_CLOCK_WDTCLKSRC_STDBY&#160;</td><td class="fielddoc">
<p>Standby clock (fSTDBY) as the source for WDT clock (fWDT). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga77f22d4ceb0b920b48b87da63f62d174ac39bb0fdcadf330ce33bbbd6f03d4a04"></a>XMC_SCU_CLOCK_WDTCLKSRC_PLL&#160;</td><td class="fielddoc">
<p>PLL output (fPLL) as the source for WDT clock (fWDT). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gad0408131d64c97d53a863b982225e664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gad0408131d64c97d53a863b982225e664">XMC_SCU_HIB_RTCCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for selecting the source of RTC Clock (fRTC). These enums are used to configure <em>RCS</em> bit of <em>HDCR</em> register. User can choose either fOSI or fULP clock as a source for RTC Clock (fRTC). Use type <em>XMC_SCU_HIB_RTCCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggad0408131d64c97d53a863b982225e664a3c14bca46e64d357669225b8a0ae2c9d"></a>XMC_SCU_HIB_RTCCLKSRC_OSI&#160;</td><td class="fielddoc">
<p>Internal Slow Clock (fOSI) as the source for RTC Clock (fRTC). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad0408131d64c97d53a863b982225e664a337804604112681d99243ec37a386870"></a>XMC_SCU_HIB_RTCCLKSRC_ULP&#160;</td><td class="fielddoc">
<p>Ultra Low Power Clock (fULP) as the source for RTC Clock (fRTC). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga8290034e7a28d8e2e8ed0086d6f92ab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga8290034e7a28d8e2e8ed0086d6f92ab5">XMC_SCU_HIB_STDBYCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for selecting the source of Standby Clock (fSTDBY). These enums are used to configure <em>STDBYSEL</em> bit of <em>HDCR</em> register. User can choose either fOSI or fULP clock as a source for Standby Clock (fSTDBY). Use type <em>XMC_SCU_HIB_STDBYCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga8290034e7a28d8e2e8ed0086d6f92ab5a72c9a9d9c6ae06d17bfd8ca0f6982a44"></a>XMC_SCU_HIB_STDBYCLKSRC_OSI&#160;</td><td class="fielddoc">
<p>Internal Slow Clock (fOSI) as the source for Standby Clock (fSTDBY). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8290034e7a28d8e2e8ed0086d6f92ab5ab92e941f87b08da4b6a00fe921582b75"></a>XMC_SCU_HIB_STDBYCLKSRC_OSCULP&#160;</td><td class="fielddoc">
<p>Ultra Low Power Clock (fULP) as the source for Standby Clock (fSTDBY). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga5a0bae480e780bdd2dd407dfd1c30816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga5a0bae480e780bdd2dd407dfd1c30816">XMC_SCU_NMIREQ_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines enumeration for the events that can generate non maskable interrupt(NMI). The NMI generation can be enabled with <em>NMIREQEN</em> register. The event will be reflected in <em>SRSTAT</em> or will be mirrored in the TRAPSTAT register. These enums can be used to configure NMI request generation bits of <em>NMIREQEN</em> register. Once configured, these events can generate non maskable interrupt. All the enum items are tabulated as per bits present in <em>NMIREQEN</em> register. Use type <em>XMC_SCU_NMIREQ_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga5a0bae480e780bdd2dd407dfd1c30816aaa484dff613548b3f220b4075bb9c120"></a>XMC_SCU_NMIREQ_WDT_WARN&#160;</td><td class="fielddoc">
<p>Watchdog timer Pre-Warning event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a0bae480e780bdd2dd407dfd1c30816af5c4b0a9066d1c3e14728454a1e8ade4"></a>XMC_SCU_NMIREQ_RTC_PI&#160;</td><td class="fielddoc">
<p>RTC Periodic event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a0bae480e780bdd2dd407dfd1c30816a3329d92d30f22de4e50fe5c31c03976d"></a>XMC_SCU_NMIREQ_RTC_AI&#160;</td><td class="fielddoc">
<p>RTC Alarm event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a0bae480e780bdd2dd407dfd1c30816a2150ab8eb9e25a0dd86c5dd3d0b45095"></a>XMC_SCU_NMIREQ_ERU0_0&#160;</td><td class="fielddoc">
<p>Channel 0 event of ERU0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a0bae480e780bdd2dd407dfd1c30816aa4f70f8f327b57fc5d1c388f3ba64fda"></a>XMC_SCU_NMIREQ_ERU0_1&#160;</td><td class="fielddoc">
<p>Channel 1 event of ERU0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a0bae480e780bdd2dd407dfd1c30816aace1860a21aef9e281b9e2e674feb752"></a>XMC_SCU_NMIREQ_ERU0_2&#160;</td><td class="fielddoc">
<p>Channel 2 event of ERU0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5a0bae480e780bdd2dd407dfd1c30816aaaadbecaa95e9e83a788083daf70257a"></a>XMC_SCU_NMIREQ_ERU0_3&#160;</td><td class="fielddoc">
<p>Channel 3 event of ERU0 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga22ea4f1155833e07a1ec13cd2c4cb4e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga22ea4f1155833e07a1ec13cd2c4cb4e0">XMC_SCU_PARITY_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines enumerations for different parity event generating modules that in turn generate a trap. Parity can be enabled with <em>PETE</em> register in order to get the trap flag reflected in <em>TRAPRAW</em> register. These enums are used to configure parity error trap generation mechanism bits of <em>PETE</em> register. All the enum items are tabulated as per bits present in <em>PETE</em> register. Use type <em>XMC_SCU_PARITY_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga22ea4f1155833e07a1ec13cd2c4cb4e0a76faf61fab7d1dc520a2edd499a8b869"></a>XMC_SCU_PARITY_PSRAM_MEM&#160;</td><td class="fielddoc">
<p>Program SRAM parity error trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga22ea4f1155833e07a1ec13cd2c4cb4e0a4fb8cb5395dd8b911a56f051e0d4fa0a"></a>XMC_SCU_PARITY_DSRAM1_MEM&#160;</td><td class="fielddoc">
<p>Data SRAM-1 parity error trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga22ea4f1155833e07a1ec13cd2c4cb4e0aef91b712c835ba659fdfbea92d8c052c"></a>XMC_SCU_PARITY_USIC0_MEM&#160;</td><td class="fielddoc">
<p>USIC0 memory parity error trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga22ea4f1155833e07a1ec13cd2c4cb4e0af43a02e98b55697a2189ddb103d35514"></a>XMC_SCU_PARITY_MCAN_MEM&#160;</td><td class="fielddoc">
<p>CAN memory parity error trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga22ea4f1155833e07a1ec13cd2c4cb4e0a194265618138204ee082e2b48f5ab619"></a>XMC_SCU_PARITY_PMU_MEM&#160;</td><td class="fielddoc">
<p>PMU Prefetch memory parity error trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga22ea4f1155833e07a1ec13cd2c4cb4e0af342269261128fd9b06a35b3604e649a"></a>XMC_SCU_PARITY_USB_MEM&#160;</td><td class="fielddoc">
<p>USB memory parity error trap. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga29713150fdafc3c88f3c73f621410239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines enumeration for peripherals that support clock gating. The enumerations can be used for gating or ungating the peripheral clocks. All the enum items are tabulated as per bits present in <em>CGATSTAT0</em> register. Use type <em>XMC_SCU_PERIPHERAL_CLOCK_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a52c9f76dec72eff13f90cdc046d47401"></a>XMC_SCU_PERIPHERAL_CLOCK_VADC&#160;</td><td class="fielddoc">
<p>VADC peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239ae0fd9b7ccf5415550786dcdb14cf5f35"></a>XMC_SCU_PERIPHERAL_CLOCK_DSD&#160;</td><td class="fielddoc">
<p>DSD peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a346af75d76735810851f4175e0aa7510"></a>XMC_SCU_PERIPHERAL_CLOCK_CCU40&#160;</td><td class="fielddoc">
<p>CCU40 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a0bb88ac36dfd3545282123f56c5c2374"></a>XMC_SCU_PERIPHERAL_CLOCK_CCU80&#160;</td><td class="fielddoc">
<p>CCU80 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a7d81755a02791cef84e36351a4e21ca5"></a>XMC_SCU_PERIPHERAL_CLOCK_POSIF0&#160;</td><td class="fielddoc">
<p>POSIF0 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a3b7bdfee77b9c35016b8c8367fa19cc2"></a>XMC_SCU_PERIPHERAL_CLOCK_USIC0&#160;</td><td class="fielddoc">
<p>USIC0 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239ae7dbfc0c6a37bdd716b87b0acfa5c498"></a>XMC_SCU_PERIPHERAL_CLOCK_ERU1&#160;</td><td class="fielddoc">
<p>ERU1 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239afdc0f84c4da3a956ee0bf2a876224c47"></a>XMC_SCU_PERIPHERAL_CLOCK_HRPWM0&#160;</td><td class="fielddoc">
<p>HRPWM0 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a2cdc8717b252a95151639d5f95c5d0a2"></a>XMC_SCU_PERIPHERAL_CLOCK_LEDTS0&#160;</td><td class="fielddoc">
<p>LEDTS0 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239ab6ee98017bc789b6642e875cd7918c0f"></a>XMC_SCU_PERIPHERAL_CLOCK_MCAN&#160;</td><td class="fielddoc">
<p>MCAN peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a301a0d6ad57fa44fa9989a26d11994c2"></a>XMC_SCU_PERIPHERAL_CLOCK_DAC&#160;</td><td class="fielddoc">
<p>DAC peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a650dcac3670a4e8d46dc06b4f35fa963"></a>XMC_SCU_PERIPHERAL_CLOCK_SDMMC&#160;</td><td class="fielddoc">
<p>SDMMC peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a37d2702a725dfc9bf6093e324a530ffb"></a>XMC_SCU_PERIPHERAL_CLOCK_USIC1&#160;</td><td class="fielddoc">
<p>USIC1 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a19830f281f510d08298a188bd657fdca"></a>XMC_SCU_PERIPHERAL_CLOCK_USIC2&#160;</td><td class="fielddoc">
<p>USIC2 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a5a0c924a2ce77ead4698c1651fc3c6dd"></a>XMC_SCU_PERIPHERAL_CLOCK_PORTS&#160;</td><td class="fielddoc">
<p>PORTS peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a94022ad63fa2dbbbf514709a230956ea"></a>XMC_SCU_PERIPHERAL_CLOCK_WDT&#160;</td><td class="fielddoc">
<p>WDT peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239ad1d5376be49034feb18db7e80ed56516"></a>XMC_SCU_PERIPHERAL_CLOCK_ETH0&#160;</td><td class="fielddoc">
<p>ETH0 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239ab6bd29a0cea6f179591b5df3d9112e4e"></a>XMC_SCU_PERIPHERAL_CLOCK_GPDMA0&#160;</td><td class="fielddoc">
<p>DMA0 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a2136960d61838413acf3d9f475a0d1b1"></a>XMC_SCU_PERIPHERAL_CLOCK_GPDMA1&#160;</td><td class="fielddoc">
<p>DMA1 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a14790dc03c41d0a2a130f08d561919f2"></a>XMC_SCU_PERIPHERAL_CLOCK_FCE&#160;</td><td class="fielddoc">
<p>FCE peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239aaa96ac2efc271d2e552813e96e8d2a8e"></a>XMC_SCU_PERIPHERAL_CLOCK_USB0&#160;</td><td class="fielddoc">
<p>USB0 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239ada108efa35e1598805661b232a4f7967"></a>XMC_SCU_PERIPHERAL_CLOCK_ECAT0&#160;</td><td class="fielddoc">
<p>ECAT0 peripheral gating. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a1d0cea1744d7164245529bbb838e5406"></a>XMC_SCU_PERIPHERAL_CLOCK_EBU&#160;</td><td class="fielddoc">
<p>EBU peripheral gating. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga8a897b11f9bf2e3cba0a33b127ee972a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga8a897b11f9bf2e3cba0a33b127ee972a">XMC_SCU_PERIPHERAL_RESET_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines enumeration representing different peripheral reset bits in the <em>PRSTAT</em> registers. All the enum items are tabulated as per bits present in <em>PRSTAT0</em>, <em>PRSTAT1</em>, <em>PRSTAT2</em>, <em>PRSTAT3</em> registers. Use type <em>XMC_SCU_PERIPHERAL_RESET_t</em> for accessing these enum parameters. Note: Release of reset should be prevented when the peripheral clock is gated in cases where kernel clock and bus interface clocks are shared, in order to avoid system hang-up. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aab92a48bfa06a56b9bc784ee1becdc182"></a>XMC_SCU_PERIPHERAL_RESET_VADC&#160;</td><td class="fielddoc">
<p>VADC reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa17fca0db0aec4105203958dcffcadf4b"></a>XMC_SCU_PERIPHERAL_RESET_DSD&#160;</td><td class="fielddoc">
<p>DSD reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa706302378c8c92b4cd7af2a2c4bb91c8"></a>XMC_SCU_PERIPHERAL_RESET_CCU40&#160;</td><td class="fielddoc">
<p>CCU40 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa775c8d3e416e48f0b2a751dd26659572"></a>XMC_SCU_PERIPHERAL_RESET_CCU80&#160;</td><td class="fielddoc">
<p>CCU80 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa9e40fb6cbe0dc62d09fc37b1137af202"></a>XMC_SCU_PERIPHERAL_RESET_POSIF0&#160;</td><td class="fielddoc">
<p>POSIF0 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa02f66fca8bcbd7a2250e2b3370484df7"></a>XMC_SCU_PERIPHERAL_RESET_USIC0&#160;</td><td class="fielddoc">
<p>USIC0 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa5e9fb8a01e93ee63ba24fdc7449db653"></a>XMC_SCU_PERIPHERAL_RESET_ERU1&#160;</td><td class="fielddoc">
<p>ERU1 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa6b200cb3367f5804f2bc7c270c2977d1"></a>XMC_SCU_PERIPHERAL_RESET_HRPWM0&#160;</td><td class="fielddoc">
<p>HRPWM0 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa649e5a1581875da6c8de2b020c7d7c47"></a>XMC_SCU_PERIPHERAL_RESET_LEDTS0&#160;</td><td class="fielddoc">
<p>LEDTS0 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa4be96af34bf6d2ce43abada383c159b7"></a>XMC_SCU_PERIPHERAL_RESET_MCAN&#160;</td><td class="fielddoc">
<p>MCAN reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aae6a230116a0fa0aba975273d604c9556"></a>XMC_SCU_PERIPHERAL_RESET_DAC&#160;</td><td class="fielddoc">
<p>DAC reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa95b33fc58402c8fe68349cfca2db384e"></a>XMC_SCU_PERIPHERAL_RESET_SDMMC&#160;</td><td class="fielddoc">
<p>SDMMC reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa16768d04bba1aef6a180ec3de84329e3"></a>XMC_SCU_PERIPHERAL_RESET_USIC1&#160;</td><td class="fielddoc">
<p>USIC1 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aaa9c8b41681e488c650b1f9eed08dec9b"></a>XMC_SCU_PERIPHERAL_RESET_USIC2&#160;</td><td class="fielddoc">
<p>USIC2 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa8ab1758864a5a6f7293c977af0343044"></a>XMC_SCU_PERIPHERAL_RESET_PORTS&#160;</td><td class="fielddoc">
<p>PORTS reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa5b93473d0a260f121d0d791407806768"></a>XMC_SCU_PERIPHERAL_RESET_WDT&#160;</td><td class="fielddoc">
<p>WDT reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa320b8f28eeb9d5e33bb69b68629806e5"></a>XMC_SCU_PERIPHERAL_RESET_ETH0&#160;</td><td class="fielddoc">
<p>ETH0 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa84048166ab6924c97045bf80165fa82f"></a>XMC_SCU_PERIPHERAL_RESET_GPDMA0&#160;</td><td class="fielddoc">
<p>DMA0 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aaff91f6055da3af780113bb0a5ec1c6e0"></a>XMC_SCU_PERIPHERAL_RESET_GPDMA1&#160;</td><td class="fielddoc">
<p>DMA1 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aa9aa2b769cdb8706f18798bc7fb235493"></a>XMC_SCU_PERIPHERAL_RESET_FCE&#160;</td><td class="fielddoc">
<p>FCE reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aae457e9e4edd7268d4ca9776af8fad0ff"></a>XMC_SCU_PERIPHERAL_RESET_USB0&#160;</td><td class="fielddoc">
<p>USB0 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aad924fd9b6e57d5dfd7e8c4c1cbfd08c0"></a>XMC_SCU_PERIPHERAL_RESET_ECAT0&#160;</td><td class="fielddoc">
<p>ECAT0 reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8a897b11f9bf2e3cba0a33b127ee972aafb6b5b3111253765bc9819b48ef363e1"></a>XMC_SCU_PERIPHERAL_RESET_EBU&#160;</td><td class="fielddoc">
<p>EBU reset. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae01c08f5d524dadbc6e0c4128b348dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gae01c08f5d524dadbc6e0c4128b348dc3">XMC_SCU_RESET_REASON_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the different causes for last reset. The cause of the last reset gets automatically stored in the <em>SCU_RSTSTAT</em> register and can be checked by user software to determine the state of the system and for debuggging purpose. All the enum items are tabulated as per bits present in <em>SCU_RSTSTAT</em> register. Use type <em>XMC_SCU_RESET_REASON_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3ae8bea77e364f87d9c74afb215da65273"></a>XMC_SCU_RESET_REASON_PORST&#160;</td><td class="fielddoc">
<p>Reset due to Power on reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3ab51de4d666b015887ff5ba839ff65259"></a>XMC_SCU_RESET_REASON_SWD&#160;</td><td class="fielddoc">
<p>Reset due to Serial wire debugger reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3a7ed9319c75de199685fb674cc89eb21a"></a>XMC_SCU_RESET_REASON_PV&#160;</td><td class="fielddoc">
<p>Reset due to Power Validation reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3aa6d2a43d58beebfabf3897c2ed65bd03"></a>XMC_SCU_RESET_REASON_SW&#160;</td><td class="fielddoc">
<p>Reset due to Software reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3aa147b82fa48ea09fe9137601ce28b6c9"></a>XMC_SCU_RESET_REASON_LOCKUP&#160;</td><td class="fielddoc">
<p>Reset due to reset due to CPU lockup. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3acd2ed3c6d9ade72259637c7c80a840cb"></a>XMC_SCU_RESET_REASON_WATCHDOG&#160;</td><td class="fielddoc">
<p>Reset due to Watchdog timer initiated reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3a9d34595d39facbd7b114462d5cc5b0c8"></a>XMC_SCU_RESET_REASON_PARITY_ERROR&#160;</td><td class="fielddoc">
<p>Reset due to reset due to memory parity error. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaff029b1575acc0712d494932d8ca6d60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the status of SCU API execution, used to verify the SCU related API calls. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaff029b1575acc0712d494932d8ca6d60a764eaaa84d169b3222ae9174d1fa6855"></a>XMC_SCU_STATUS_OK&#160;</td><td class="fielddoc">
<p>SCU related operation successfully completed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaff029b1575acc0712d494932d8ca6d60aaf8f778e9be5e754dcaa0c1cf83e1e4b"></a>XMC_SCU_STATUS_ERROR&#160;</td><td class="fielddoc">
<p>SCU related operation failed. When API cannot fulfill request, this value is returned. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaff029b1575acc0712d494932d8ca6d60a6f6a43bd2a61be2a1b0b57601d58bd77"></a>XMC_SCU_STATUS_BUSY&#160;</td><td class="fielddoc">
<p>Cannot execute the SCU related operation request because another operation is in progress. <em>XMC_SCU_STATUS_BUSY</em> is returned when API is busy processing another request. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4de86b97726dc23fabd8c4e573b1bdb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga4de86b97726dc23fabd8c4e573b1bdb0">XMC_SCU_TRAP_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines enumerations representing the status of trap cause. The cause of the trap gets automatically stored in the <em>TRAPSTAT</em> register and can be checked by user software to determine the state of the system and for debug purpose. Use type <em>XMC_SCU_TRAP_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4de86b97726dc23fabd8c4e573b1bdb0a1b0819f2f12755f729dd4595ce5d6b14"></a>XMC_SCU_TRAP_OSC_WDG&#160;</td><td class="fielddoc">
<p>OSC_HP Oscillator Watchdog trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4de86b97726dc23fabd8c4e573b1bdb0a67e91a2b9240957470f5ba077bb8e54a"></a>XMC_SCU_TRAP_VCO_LOCK&#160;</td><td class="fielddoc">
<p>PLL loss of lock trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4de86b97726dc23fabd8c4e573b1bdb0aa1faa35eca95044644fa5a8b3ac1ddd5"></a>XMC_SCU_TRAP_USB_VCO_LOCK&#160;</td><td class="fielddoc">
<p>USB PLL loss of lock trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4de86b97726dc23fabd8c4e573b1bdb0a3a1a0db9c727530f70df92a2064c656e"></a>XMC_SCU_TRAP_PARITY_ERROR&#160;</td><td class="fielddoc">
<p>Memory Parity error trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4de86b97726dc23fabd8c4e573b1bdb0a07fca7088a9a4a5b4ad078e10226b07a"></a>XMC_SCU_TRAP_BROWNOUT&#160;</td><td class="fielddoc">
<p>Brownout trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4de86b97726dc23fabd8c4e573b1bdb0a29962065106d968469a8e5663907ba89"></a>XMC_SCU_TRAP_ULP_WDG&#160;</td><td class="fielddoc">
<p>Unstable 32KHz clock trap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4de86b97726dc23fabd8c4e573b1bdb0a924f06cf751454f379bcb31ff69a8626"></a>XMC_SCU_TRAP_PER_BRIDGE0&#160;</td><td class="fielddoc">
<p>Bad memory access of peripherals on Bridge-0. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4de86b97726dc23fabd8c4e573b1bdb0a9740c5bdbb9f490452931cdd987b96a0"></a>XMC_SCU_TRAP_PER_BRIDGE1&#160;</td><td class="fielddoc">
<p>Bad memory access of peripherals on Bridge-1. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4de86b97726dc23fabd8c4e573b1bdb0a322bb8e660028c3e94ac13d8e2ac7f4d"></a>XMC_SCU_TRAP_ECAT_RESET&#160;</td><td class="fielddoc">
<p>EtherCat Reset </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Dokumentation der Funktionen</h2>
<a class="anchor" id="gacf86e99e8def2e37a0b484982e61256d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CalibrateTemperatureSensor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset value for calibrating the DTS result.<br />
 <b>Range:</b> 0 to 127. </td></tr>
    <tr><td class="paramname">gain</td><td>Gain value for calibrating the DTS conversion result.<br />
 <b>Range:</b> 0 to 63.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Calibrates the measurement of temperature by configuring the values of offset and gain of <em>DTSCON</em> register. <br />
<br />
Allows to improve the accuracy of the temperature measurement with the adjustment of <em>OFFSET</em> and <em>GAIN</em> bit fields in the <em>DTSCON</em> register. Offset adjustment is defined as a shift of the conversion result. The range of the offset adjustment is 7 bits with a resolution that corresponds to +/- 12.5C. The offset value gets added to the measure result. Offset is considered as a signed value. Gain adjustment helps in minimizing gain error. When the <em>gain</em> value is 0, result is generated with maximum gain. When the <em>gain</em> value is 63, result is generated with least gain, i.e, <em>RESULT</em> - 63 at the highest measured temperature.<br />
It is recommended to use following steps:<br />
<ul>
<li>Call <em>XMC_SCU_StopTempMeasurement</em> to stop temperature measurement if it was started previously.<br />
</li>
<li>Call <em>XMC_SCU_CalibrateTempMonitor</em> with desired offset and gain calibration values to the DTS.<br />
</li>
<li>Call <em>XMC_SCU_SetRawTempLimits</em> with desired lower and upper temperature threshold limit values if it is needed.<br />
</li>
<li>Call <em>XMC_SCU_StartTempMeasurement</em> to start temperature measurement.<br />
</li>
<li>Check whether Die Temperature Sensor (DTS) is busy in conversion by calling <em><a class="el" href="group___s_c_u.html#ga09f2786f94680cc125ead431f3c4d9c4">XMC_SCU_IsTemperatureSensorBusy()</a></em> and wait till conversion complete.<br />
</li>
<li>Read the die temperature value using <em>XMC_SCU_GetTemperatureMeasurement</em> API. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3f6a1e71b005175777c6dd9a069e325c">XMC_SCU_EnableTemperatureSensor()</a>, <a class="el" href="group___s_c_u.html#gabac9292e193c9804b5a6856de186737e">XMC_SCU_StartTemperatureMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga8ac62bd07097bb83cd294a1d6625af36">XMC_SCU_GetTemperatureMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0f9078c8d5a83149c40812925f3c218d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_DisableClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga2bd90dc2daf0ff48625ab7b297b2cacd">XMC_SCU_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock</td><td>Peripheral for which the clock has to be disabled. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga2bd90dc2daf0ff48625ab7b297b2cacd">XMC_SCU_CLOCK_t</a> to select the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables source clock for the peripheral selected.<br />
<br />
The various outputs of Clock Generation Unit (CGU) can be individually disabled by setting the peripheral specific bits in the <em>CLKCLR</em> register.<br />
It is recommended to use following steps to verify whether clock source of the peripheral is enabled/disabled:<br />
<ul>
<li>Call <em>XMC_SCU_CLOCK_DisableClock</em> with desired peripheral identifier.<br />
</li>
<li>Call <em>XMC_SCU_CLOCK_IsClockEnabled</em> with same peripheral identifier to verify whether peripheral is enabled/disabled.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga31001fdc4707eb901996074ee0c6fcff">XMC_SCU_CLOCK_EnableClock()</a>, <a class="el" href="group___s_c_u.html#gab00fa5e7e6ed73767de6f80b9a849543">XMC_SCU_RESET_AssertPeripheralReset()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gad9465a7485ccf3e4aeb4739d4e2422dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_DisableHighPerformanceOscillator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the high precision oscillator by disabling the external oscillator.<br />
<br />
The API configures <em>MODE</em> bits of <em>OSCHPCTRL</em> register to 1, there by disabling the external oscillator. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gad8179be793c17dda72a87dea440dd118">XMC_SCU_CLOCK_EnableHighPerformanceOscillator()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga720f80a8e2c129e7139c8bfec4afb962">XMC_SCU_CLOCK_GetECATClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga19a4bbb5fa7a9f538428ef93a39b5d99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_DisableLowPowerOscillator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables ultra low power oscillator.<br />
<br />
It is disabled by setting the <em>MODE</em> bits of <em>OSCULCTRL</em> register to value 2. By default on power up, the ultra low power osciallator is disabled. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gad827fd74357895b8387e896501f21579">XMC_SCU_CLOCK_EnableLowPowerOscillator()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga720f80a8e2c129e7139c8bfec4afb962">XMC_SCU_CLOCK_GetECATClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="gacc3a5c5ed7095b25389ebc23705517a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_DisableSystemPll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables main PLL for system clock. <br />
<br />
System PLL is disabled by setting the <em>PLLPWD</em> and <em>VCOPWD</em> bits of <em>PLLCON0</em> register. By default the system PLL is in power saving mode. If the system PLL is explicitly enabled, the API disables the PLL and the voltage controlled oscillator(VCO) associated with it. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga324e4c4bb68133279a6c8c50fe1a514e">XMC_SCU_CLOCK_EnableSystemPll()</a>, <a class="el" href="group___s_c_u.html#ga879eeaff71fe00dd7fc148b481ce8379">XMC_SCU_CLOCK_StopSystemPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6ca204f398c5ae671ba9d59b5be2264c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_DisableUsbPll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables USB PLL for USB clock. <br />
<br />
USB PLL is disabled by setting the <em>PLLPWD</em> and <em>VCOPWD</em> bits of <em>USBPLLCON</em> register. By default the USB PLL is in power saving mode. If the USB PLL is explicitly enabled, the API disables the PLL and the voltage controlled oscillator(VCO) associated with it. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaa89d0737a9026f17d0d55b6db74333f5">XMC_SCU_CLOCK_EnableUsbPll()</a>, <a class="el" href="group___s_c_u.html#ga11067ab015e6a6632cf9be194a4f8d6b">XMC_SCU_CLOCK_StopUsbPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga31001fdc4707eb901996074ee0c6fcff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_EnableClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga2bd90dc2daf0ff48625ab7b297b2cacd">XMC_SCU_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock</td><td>Peripheral for which the clock has to be enabled. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga2bd90dc2daf0ff48625ab7b297b2cacd">XMC_SCU_CLOCK_t</a> to select the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the source clock for selected peripheral.<br />
<br />
The various outputs of Clock Generation Unit (CGU) can be individually enabled by setting the peripheral specific bit in the <em>CLKSET</em> register.<br />
It is recommended to use following steps to verify whether a source clock of peripheral is enabled/disabled:<br />
<ul>
<li>Call <em><a class="el" href="group___s_c_u.html#ga31001fdc4707eb901996074ee0c6fcff">XMC_SCU_CLOCK_EnableClock()</a></em> with desired peripheral identifier.<br />
</li>
<li>Call <em><a class="el" href="group___s_c_u.html#ga52dd13c0aa61ed09a31f8137d28c4532">XMC_SCU_CLOCK_IsClockEnabled()</a></em> with same peripheral identifier to verify whether the clock is enabled.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga0f9078c8d5a83149c40812925f3c218d">XMC_SCU_CLOCK_DisableClock()</a>, <a class="el" href="group___s_c_u.html#gac88ad38d3473b139dafef29dc3ba5216">XMC_SCU_RESET_DeassertPeripheralReset()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gad8179be793c17dda72a87dea440dd118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_EnableHighPerformanceOscillator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the high precision oscillator by configuring external crystal mode.<br />
<br />
The API configures <em>MODE</em> bits of <em>OSCHPCTRL</em> register to 0, there by configuring the external clock input. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gad9465a7485ccf3e4aeb4739d4e2422dc">XMC_SCU_CLOCK_DisableHighPerformanceOscillator()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga720f80a8e2c129e7139c8bfec4afb962">XMC_SCU_CLOCK_GetECATClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="gad827fd74357895b8387e896501f21579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_EnableLowPowerOscillator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables ultra low power oscillator(ULP). <br />
<br />
It enables the hibernate domain, configures the ultra low power oscillator uisng the <em>MODE</em> bits of the <em>OSCULCTRL</em> register. The <em>Mode</em> bits will be reset to 0 to enable the low power oscillator. Mirror register update delays are handled internally. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga19a4bbb5fa7a9f538428ef93a39b5d99">XMC_SCU_CLOCK_DisableLowPowerOscillator()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga720f80a8e2c129e7139c8bfec4afb962">XMC_SCU_CLOCK_GetECATClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga324e4c4bb68133279a6c8c50fe1a514e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_EnableSystemPll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables main PLL for system clock. <br />
<br />
System PLL is enabled by clearing the <em>PLLPWD</em> and <em>VCOPWD</em> bits of <em>PLLCON0</em> register. By default the system PLL is in power saving mode. The API enables the PLL and the voltage controlled oscillator associated with it. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gacc3a5c5ed7095b25389ebc23705517a3">XMC_SCU_CLOCK_DisableSystemPll()</a>, <a class="el" href="group___s_c_u.html#ga356a667144dc0009582198bad1070d7a">XMC_SCU_CLOCK_StartSystemPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa89d0737a9026f17d0d55b6db74333f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_EnableUsbPll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables USB PLL for USB clock. <br />
<br />
USB PLL is enabled by clearing the <em>PLLPWD</em> and <em>VCOPWD</em> bits of <em>USBPLLCON</em> register. By default the USB PLL is in power saving mode. The API enables the PLL and the voltage controlled oscillator associated with it. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga6ca204f398c5ae671ba9d59b5be2264c">XMC_SCU_CLOCK_DisableUsbPll()</a>, <a class="el" href="group___s_c_u.html#gacb5f410baf92504c4fc60bc33e167d9c">XMC_SCU_CLOCK_StartUsbPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gab0af70f90b9a1f24d3a0a4764543d833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_GatePeripheralClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the clock has to be gated. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> to identify the peripheral clock to be gated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Blocks the supply of clock to the selected peripheral.<br />
<br />
Clock gating helps in reducing the power consumption. User can selectively gate the clocks of unused peripherals. fPERI is the source of clock to various peripherals. Some peripherals support clock gate. Such a gate blocks the clock supply for the selected peripheral. Software can request for individual gating of such peripheral clocks by enabling one of the <em>SCU_CGATSET0</em>, <em>SCU_CGATSET1</em> or <em>SCU_CGATSET2</em> register bitfields.</dd></dl>
<p>Note: Clock gating shall not be activated unless the module is in reset state. So use <em><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a></em> API before enabling the gating of any peripheral. </p><dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a>, <a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gaabc40433a3a0c21f96993cfb6af038ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetCcuClockDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Ratio of fCCU clock source to the value of fCCU. <b>Range:</b> 0 or 1.<br />
 0-&gt; fCCU= fSYS <br />
 1-&gt; fCCU= fSYS/2.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the ratio of CCU clock(fCCU) to system clock(fSYS).<br />
<br />
The value is obtained by reading <em>CCUDIV</em> bit of <em>CCUCLKCR</em> register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga222a00aedb2c6822f78f2794ef237f26">XMC_SCU_CLOCK_SetCcuClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#gaf5d0a11b4d5cad0f4516afb8b3976ca1">XMC_SCU_CLOCK_SetCpuClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga22725a6c39f19f4089e45509e63f936e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetCcuClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t CCU clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the frequency of clock(fCPU) used for CCU4, CCU8, POSIF and HRPWM.<br />
<br />
The value is obtained from <em>CCUDIV</em> bits of <em>CCUCLKCR</em> register and system clock (fSYS) frequency. Based on these values, fCCU clock frequency is calculated using following formula:<br />
fCCU = fSYS &gt;&gt; CCUDIV.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaabc40433a3a0c21f96993cfb6af038ae">XMC_SCU_CLOCK_GetCcuClockDivider()</a>, <a class="el" href="group___s_c_u.html#ga0a9fd5e87ad27c874c88706ba43772c2">XMC_SCU_CLOCK_GetSystemClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga0a9fd5e87ad27c874c88706ba43772c2">XMC_SCU_CLOCK_GetSystemClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gab537dadfc72161a06f4f6dfa85449ae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetCpuClockDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Ratio between system clock(fSYS) and CPU clock(fCPU). <b>Range:</b> 0 or 1.<br />
 0-&gt; fCPU= fSYS. <br />
 1-&gt; fCPU= fSYS/2.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the ratio between system clock(fSYS) and CPU clock(fCPU). <br />
<br />
The value is obtained by reading <em>CPUDIV</em> bit of <em>CPUCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaf5d0a11b4d5cad0f4516afb8b3976ca1">XMC_SCU_CLOCK_SetCpuClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga256245971cfb74c5260d5564bb01020a">XMC_SCU_CLOCK_SetPeripheralClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3e78410c4d0c9f9b54aa0965d16c3795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Value of CPU clock frequency.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the vlaue of CPU clock frequency.<br />
<br />
The value is stored in a global variable <em><b>SystemCoreClock</b>.</em> It is updated when the clock configuration is done using the SCU LLD APIs. The value represents the frequency of clock used for CPU operation. <b>Range:</b> Value is of type uint32_t, and gives the value of frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a>, <a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a> und <a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock()</a>.</p>

</div>
</div>
<a class="anchor" id="ga12fce693c9f70eae932924cacedd3d6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetEbuClockDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Ratio of PLL clock(fPLL) to EBU clock(fEBU).<br />
 <b>Range:</b> 0 to 63.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the ratio between PLL clock(fPLL) and EBU clock(fEBU).<br />
<br />
The value is obtained by reading <em>EBUDIV</em> bits of <em>EBUCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga0d4e4b167bff6189b508f9655693ca84">XMC_SCU_CLOCK_SetEbuClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga8f338f60cac7809fafd01b0941d1a2c1">XMC_SCU_CLOCK_SetWdtClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga70d21487445c6104d1362b45c3882877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetEbuClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t EBU clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the frequency of EBU clock(fEBU).<br />
<br />
The value is derived from system PLL clock frequency(fPLL) by applying the EBU divider. It is calculated using the following formula:<br />
fETH = fPLL /(EBUDIV+1) </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga12fce693c9f70eae932924cacedd3d6b">XMC_SCU_CLOCK_GetEbuClockDivider()</a>, <a class="el" href="group___s_c_u.html#gae8c2602ab7184dbeda09e0ca0e690168">XMC_SCU_CLOCK_GetSystemPllClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga720f80a8e2c129e7139c8bfec4afb962"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetECATClockDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Ratio between the source of ECAT clock and the ECAT clock.<br />
 <b>Range:</b> 0 to 3.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the ratio between the ECAT parent clock and the ECAT clock. <br />
<br />
The value is obtained by reading <em>ECADIV</em> bits of <em>ECATCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaa7c721ac3ba6f1d066101176e103d5ff">XMC_SCU_CLOCK_SetECATClockSource()</a>, <a class="el" href="group___s_c_u.html#gaa20f63e6573fd17e9b0c05a004dcd499">XMC_SCU_CLOCK_SetECATClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#gad9465a7485ccf3e4aeb4739d4e2422dc">XMC_SCU_CLOCK_DisableHighPerformanceOscillator()</a>, <a class="el" href="group___s_c_u.html#ga19a4bbb5fa7a9f538428ef93a39b5d99">XMC_SCU_CLOCK_DisableLowPowerOscillator()</a>, <a class="el" href="group___s_c_u.html#gad8179be793c17dda72a87dea440dd118">XMC_SCU_CLOCK_EnableHighPerformanceOscillator()</a>, <a class="el" href="group___s_c_u.html#gad827fd74357895b8387e896501f21579">XMC_SCU_CLOCK_EnableLowPowerOscillator()</a>, <a class="el" href="group___s_c_u.html#gae8c2602ab7184dbeda09e0ca0e690168">XMC_SCU_CLOCK_GetSystemPllClockFrequency()</a>, <a class="el" href="group___s_c_u.html#gabcba51c9d61c4f3e8a3e1bc816c5fb02">XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency()</a> und <a class="el" href="group___s_c_u.html#ga050ac1d63bf86241205c4fdcca3eb988">XMC_SCU_CLOCK_GetUsbPllClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2786257933663aa4c54f9dc7c97422d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#ga26a3f6ccc6fa98818df8efd7e487d7c0">XMC_SCU_CLOCK_ECATCLKSRC_t</a> XMC_SCU_CLOCK_GetECATClockSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>XMC_SCU_CLOCK_ECATCLKSRC_t Source of ECAT clock.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga26a3f6ccc6fa98818df8efd7e487d7c0">XMC_SCU_CLOCK_ECATCLKSRC_t</a> to identify the clock source.<br />
 XMC_SCU_CLOCK_ECATCLKSRC_USBPLL - USB PLL (fUSBPLL) as a source for ECAT clock. <br />
 XMC_SCU_CLOCK_ECATCLKSRC_SYSPLL - Main PLL output (fPLL) as a source for ECAT clock. <br />
 </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the source of ECAT clock (fECAT). The value is obtained by reading <em>ECATSEL</em> bit of <em>ECATCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gadca7d1332ed62fda2a1a85550d12f06d">XMC_SCU_HIB_SetRtcClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#gae07a3504f85acd247cd7b9315dcc4083">XMC_SCU_CLOCK_SetSystemClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga83d6d8e1bb269b8cccb8e700bd4a842a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetEthernetClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Ethernet clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the frequency of Ethernet clock(fETH).<br />
<br />
The value is derived from system clock frequency(fSYS). It is calculated using the following formula:<br />
fETH = fSYS &gt;&gt; 1; </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga0a9fd5e87ad27c874c88706ba43772c2">XMC_SCU_CLOCK_GetSystemClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#gacc3a5c5ed7095b25389ebc23705517a3">XMC_SCU_CLOCK_DisableSystemPll()</a>, <a class="el" href="group___s_c_u.html#ga6ca204f398c5ae671ba9d59b5be2264c">XMC_SCU_CLOCK_DisableUsbPll()</a>, <a class="el" href="group___s_c_u.html#ga324e4c4bb68133279a6c8c50fe1a514e">XMC_SCU_CLOCK_EnableSystemPll()</a>, <a class="el" href="group___s_c_u.html#gaa89d0737a9026f17d0d55b6db74333f5">XMC_SCU_CLOCK_EnableUsbPll()</a>, <a class="el" href="group___s_c_u.html#ga70d21487445c6104d1362b45c3882877">XMC_SCU_CLOCK_GetEbuClockFrequency()</a>, <a class="el" href="group___s_c_u.html#gab8274d36f46ebb315665d30985b62611">XMC_SCU_CLOCK_GetExternalOutputClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga0a9fd5e87ad27c874c88706ba43772c2">XMC_SCU_CLOCK_GetSystemClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga6266b7288cd6a209146d83d67f21b573">XMC_SCU_CLOCK_GetWdtClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga3b65db9f01407d2b3b98d5984ae09e71">XMC_SCU_CLOCK_IsSystemPllLocked()</a>, <a class="el" href="group___s_c_u.html#gab138fec040dc094a8a6579cfcaad2da8">XMC_SCU_CLOCK_IsUsbPllLocked()</a>, <a class="el" href="group___s_c_u.html#ga8ae09f0a2575e72f52d961ea5a4622cf">XMC_SCU_CLOCK_SetBackupClockCalibrationMode()</a>, <a class="el" href="group___s_c_u.html#ga356a667144dc0009582198bad1070d7a">XMC_SCU_CLOCK_StartSystemPll()</a>, <a class="el" href="group___s_c_u.html#gacb5f410baf92504c4fc60bc33e167d9c">XMC_SCU_CLOCK_StartUsbPll()</a>, <a class="el" href="group___s_c_u.html#ga381e223afdcbd3d2766a24958468dc0f">XMC_SCU_CLOCK_StepSystemPllFrequency()</a>, <a class="el" href="group___s_c_u.html#ga879eeaff71fe00dd7fc148b481ce8379">XMC_SCU_CLOCK_StopSystemPll()</a>, <a class="el" href="group___s_c_u.html#ga11067ab015e6a6632cf9be194a4f8d6b">XMC_SCU_CLOCK_StopUsbPll()</a>, <a class="el" href="group___s_c_u.html#gae5c8ea8d8a577e936a3dde5239966337">XMC_SCU_HIB_DisableHibernateDomain()</a>, <a class="el" href="group___s_c_u.html#gaa09c64c2a7a15e6cba8b97de86c87c6e">XMC_SCU_HIB_DisableInternalSlowClock()</a>, <a class="el" href="group___s_c_u.html#ga2f73953dadc8eaa2fad5e66a2c2e57a4">XMC_SCU_HIB_EnableHibernateDomain()</a>, <a class="el" href="group___s_c_u.html#gadaa00ec6206d10e3840504ba592f5725">XMC_SCU_HIB_EnableInternalSlowClock()</a>, <a class="el" href="group___s_c_u.html#ga725038f7765622ede258de69e21971a4">XMC_SCU_HIB_IsHibernateDomainEnabled()</a>, <a class="el" href="group___s_c_u.html#gacf750b3451bbdd00820d54f25100bd75">XMC_SCU_POWER_DisableUsb()</a> und <a class="el" href="group___s_c_u.html#ga4d0a5061d139bb8e136316a2fcc98bab">XMC_SCU_POWER_EnableUsb()</a>.</p>

</div>
</div>
<a class="anchor" id="ga24e64fe15f9ce0183a1bc5fba7bec579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetExternalOutputClockDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Ratio between the external output parent clock selected and the output clock.<br />
 <b>Range:</b> 0 to 511.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the divider value applied on parent clock before the generation of external output clock. <br />
<br />
The value is obtained by reading <em>EXTDIV</em> bit of <em>EXTCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae80c027210bcf8cdafd0fe8aa3274777">XMC_SCU_CLOCK_GetExternalOutputClockSource()</a>, <a class="el" href="group___s_c_u.html#ga504e82a0763495f9d487ea0b0d5ebd7a">XMC_SCU_CLOCK_SetExternalOutputClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#gaa20f63e6573fd17e9b0c05a004dcd499">XMC_SCU_CLOCK_SetECATClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="gab8274d36f46ebb315665d30985b62611"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetExternalOutputClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t External clock out frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the frequency of external output clock(fEXT).<br />
<br />
The value is derived using <em>ECKDIV</em> bits of <em>EXCLKCR</em> register and external clock out source. Based on these values, it is calculated using the following formula:<br />
if external clock out source = System clock: fEXT = fSYS.<br />
if external clock out source = PLL: fEXT = fPLL/(ECKDIV + 1).<br />
if external clock out source = USBPLL: fEXT = fUSBPLL/(ECKDIV + 1).<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga24e64fe15f9ce0183a1bc5fba7bec579">XMC_SCU_CLOCK_GetExternalOutputClockDivider()</a>, <a class="el" href="group___s_c_u.html#gae80c027210bcf8cdafd0fe8aa3274777">XMC_SCU_CLOCK_GetExternalOutputClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gae80c027210bcf8cdafd0fe8aa3274777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gaaf5142b4b63fc9f6413c9deb3e7740a0">XMC_SCU_CLOCK_EXTOUTCLKSRC_t</a> XMC_SCU_CLOCK_GetExternalOutputClockSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>XMC_SCU_CLOCK_EXTOUTCLKSRC_t Source of external clock output(fEXT).<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gaaf5142b4b63fc9f6413c9deb3e7740a0">XMC_SCU_CLOCK_EXTOUTCLKSRC_t</a> to identify the clock.<br />
 XMC_SCU_CLOCK_EXTOUTCLKSRC_SYS - system clock fSYS. <br />
 XMC_SCU_CLOCK_EXTOUTCLKSRC_USB - USB clock fUSB. <br />
 XMC_SCU_CLOCK_EXTOUTCLKSRC_PLL - PLL output fPLL. <br />
 </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the source of external clock output(fEXT).<br />
<br />
The value is obtained by reading <em>ECKSEL</em> bits of <em>EXTCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae0e95e282cd20159627d036941caf0c7">XMC_SCU_CLOCK_SetExternalOutputClockSource()</a>, <a class="el" href="group___s_c_u.html#ga504e82a0763495f9d487ea0b0d5ebd7a">XMC_SCU_CLOCK_SetExternalOutputClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#gab274b04a774d18a4a7305f43ffb71d4e">XMC_SCU_CLOCK_SetSystemPllClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gae163ddda50d4e04337cc17b3a3aed1f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetPeripheralClockDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Ratio of peripheral clock source to the value of peripheral clock.<br />
 <b>Range:</b> 0 or 1.<br />
 0-&gt; fPERIPH= fCPU.<br />
 1-&gt; fPERIPH= fCPU/2.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the ratio of CPU clock(fCPU) to peripheral clock(fPERIPH).<br />
<br />
The value is obtained by reading <em>PBDIV</em> bit of <em>PBCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga256245971cfb74c5260d5564bb01020a">XMC_SCU_CLOCK_SetPeripheralClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga6bfbeee9da8ba9c854c34fc5da9a7d7d">XMC_SCU_CLOCK_SetUsbClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga55a1be4f0e96fcda7b2c0feb542af250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Value of peripheral clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the vlaue of clock frequency at which the peripherals are working.<br />
<br />
The value is derived from the CPU frequency. <b>Range:</b> Value is of type uint32_t. It is represented in Hertz. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a>,<a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga700247f0d54ab409e0542547ce3546f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetSystemClockDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Ratio of fSYS clock source to the value of fSYS. <b>Range:</b> 0 to 255.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the value of ratio between the source of system clock to the the value of system clock frequency. <br />
<br />
The value is obtained by reading <em>SYSDIV</em> bits of <em>SYSCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae07a3504f85acd247cd7b9315dcc4083">XMC_SCU_CLOCK_SetSystemClockDivider()</a>, <a class="el" href="group___s_c_u.html#gac6d37853e6609aa646b4dd1517fddd54">XMC_SCU_CLOCK_SetSystemClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga222a00aedb2c6822f78f2794ef237f26">XMC_SCU_CLOCK_SetCcuClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a9fd5e87ad27c874c88706ba43772c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetSystemClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t System clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the frequency of system clock (fSYS).<br />
<br />
The value obtained by dividing <em>CPUDIV</em> bits information of <em>CPUCLKCR</em> register with SystemCoreClock (fCPU) value.<br />
Based on these values, fSYS clock frequency is derived using the following formula:<br />
fSYS = fCPU &lt;&lt; CPUDIV. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga050ac1d63bf86241205c4fdcca3eb988">XMC_SCU_CLOCK_GetUsbPllClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga22725a6c39f19f4089e45509e63f936e">XMC_SCU_CLOCK_GetCcuClockFrequency()</a> und <a class="el" href="group___s_c_u.html#gad12a425e40ac269c2b17a06100be6cf2">XMC_SCU_CLOCK_GetUsbClockFrequency()</a>.</p>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e6bbfbc0d075a0e3bab4c4906136fcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gaccffa04837e2b0c2132f74f3c502139b">XMC_SCU_CLOCK_SYSCLKSRC_t</a> XMC_SCU_CLOCK_GetSystemClockSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>XMC_SCU_CLOCK_SYSCLKSRC_t Source of clock for fSYS.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gaccffa04837e2b0c2132f74f3c502139b">XMC_SCU_CLOCK_SYSCLKSRC_t</a> to select the source of clock.<br />
 XMC_SCU_CLOCK_SYSCLKSRC_OFI - internal fast clock selected as fSYS.<br />
 XMC_SCU_CLOCK_SYSCLKSRC_PLL - output of PLL fPLL selected as fSYS.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the selected source of system clock (fSYS). <br />
<br />
Selected source of fSYS is obtained by reading <em>SYSSEL</em> bits of <em>SYSCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gac6d37853e6609aa646b4dd1517fddd54">XMC_SCU_CLOCK_SetSystemClockSource()</a>, <a class="el" href="group___s_c_u.html#gabcba51c9d61c4f3e8a3e1bc816c5fb02">XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga5332425bae1da209b9c6cc857f53d51e">XMC_SCU_CLOCK_SetUsbClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gae8c2602ab7184dbeda09e0ca0e690168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetSystemPllClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t System frequency in Hertz.<br />
 <b>Range:</b> clock frequency in Hertz. Range of the value depends on the source clock frequency and the configured values of dividers.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the value of system PLL output clock frequency(fPLL).<br />
<br />
The API uses <em>N-DIV</em>, <em>P-DIV</em>, <em>K1-DIV</em>, <em>K2-DIV</em> bits information from <em>PLLCON1</em> register and VCOBYP bit information from <em>PLLCON0</em> register. It calculates frequency of system pll clock using following formula: If normal Mode : fPLL = (fOSC * N)/(P * K2). If prescaler mode: fPLL = fOSC/ K1. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gac6d37853e6609aa646b4dd1517fddd54">XMC_SCU_CLOCK_SetSystemClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga720f80a8e2c129e7139c8bfec4afb962">XMC_SCU_CLOCK_GetECATClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga00b75ab108bf4a3b1e153a339b77a62c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#ga91284bbc86bb476327771f3639cbe440">XMC_SCU_CLOCK_SYSPLLCLKSRC_t</a> XMC_SCU_CLOCK_GetSystemPllClockSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>XMC_SCU_CLOCK_OSCCLKSRC_t Source of clock for system PLL.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga91284bbc86bb476327771f3639cbe440">XMC_SCU_CLOCK_SYSPLLCLKSRC_t</a> for identifying the clock source.<br />
 XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP - External High performance oscillator(fOHP).<br />
 XMC_SCU_CLOCK_SYSPLLCLKSRC_OFI - Internal fast clock (fOFI).</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the source of system PLL clock (fPLL). <br />
<br />
The value is obtained by reading <em>VCOBYP</em> bit of <em>PLLCON0</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gad8179be793c17dda72a87dea440dd118">XMC_SCU_CLOCK_EnableHighPerformanceOscillator()</a>, <a class="el" href="group___s_c_u.html#gab274b04a774d18a4a7305f43ffb71d4e">XMC_SCU_CLOCK_SetSystemPllClockSource()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gabcba51c9d61c4f3e8a3e1bc816c5fb02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Source clock used for deriving system clock.<br />
 <b>Range:</b> fOHP frequency if external high precision frequency is used. <br />
 fOFI fast internal clock frequency.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the value of the input clock frequency for deriving the system clock. The API retrieves frequency of system PLL input clock (fPLLin). Based on <em>PINSEL</em> bits information from <em>PLLCON2</em> register, the parent clock source is obtained. This bit field specifies if fOHP or fOFI is used for deriving system clock. System clock frequency is obtained by dividing the source clock frequency with different divider values. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae8c2602ab7184dbeda09e0ca0e690168">XMC_SCU_CLOCK_GetSystemPllClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga720f80a8e2c129e7139c8bfec4afb962">XMC_SCU_CLOCK_GetECATClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga129a4c1cd0e4963b8a573c25485cd693"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetUsbClockDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Ratio of PLL output clock(fPLL) to USB clock(fUSB). <b>Range:</b> 0 to 7.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the ratio between PLL output frequency(fPLL) and USB clock(fUSB).<br />
<br />
The value is obtained by reading <em>USBDIV</em> bit of <em>USBCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga6bfbeee9da8ba9c854c34fc5da9a7d7d">XMC_SCU_CLOCK_SetUsbClockDivider()</a>, <a class="el" href="group___s_c_u.html#ga65588bdfa384f0f3deca2553ca2205be">XMC_SCU_CLOCK_GetUsbClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga0d4e4b167bff6189b508f9655693ca84">XMC_SCU_CLOCK_SetEbuClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="gad12a425e40ac269c2b17a06100be6cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetUsbClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t USB clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the frequency of USB and SDMMC clock(fUSB/fSDMMC).<br />
<br />
The value is obtained from <em>USBDIV</em> bits of <em>USBCLKCR</em> register and USB clock source. Based on these values fUSB/fSDMMC clock frequency is calculated using following formula:<br />
if USB clock source = USBPLL: fUSB/fSDMMC = fUSBPLL/(USBDIV + 1).<br />
if USB clock source = PLL: fUSB/fSDMMC = fPLL/(USBDIV + 1).<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga65588bdfa384f0f3deca2553ca2205be">XMC_SCU_CLOCK_GetUsbClockSource()</a>, <a class="el" href="group___s_c_u.html#ga129a4c1cd0e4963b8a573c25485cd693">XMC_SCU_CLOCK_GetUsbClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga0a9fd5e87ad27c874c88706ba43772c2">XMC_SCU_CLOCK_GetSystemClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga65588bdfa384f0f3deca2553ca2205be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gaa25fc7c21af145300a57dd93c391816d">XMC_SCU_CLOCK_USBCLKSRC_t</a> XMC_SCU_CLOCK_GetUsbClockSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>XMC_SCU_CLOCK_USBCLKSRC_t Source of clock for USB and SDMMC(fUSB/SDMMC).<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gaa25fc7c21af145300a57dd93c391816d">XMC_SCU_CLOCK_USBCLKSRC_t</a> to identify the source of clock.<br />
 XMC_SCU_CLOCK_USBCLKSRC_USBPLL - output of USB PLL is selected as source of USB clock(fUSB/SDMMC).<br />
 XMC_SCU_CLOCK_USBCLKSRC_SYSPLL - output of PLL fPLL is selected as source of USB clock(fUSB/SDMMC).</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the selected source of USB and SDMMC clock frequency.<br />
<br />
The clock source is read from from the <em>USBSEL</em> bits of <em>USBCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga6bfbeee9da8ba9c854c34fc5da9a7d7d">XMC_SCU_CLOCK_SetUsbClockDivider()</a>, <a class="el" href="group___s_c_u.html#ga050ac1d63bf86241205c4fdcca3eb988">XMC_SCU_CLOCK_GetUsbPllClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga9061262a31285c0b5c3a13801650a453">XMC_SCU_CLOCK_SetWdtClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga050ac1d63bf86241205c4fdcca3eb988"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetUsbPllClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t USB PLL output clock frequency.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the frequency of USB PLL output clock (fUSBPLL).<br />
<br />
It obtains the <em>VCOBYP</em> bits information from <em>USBPLLCON</em> register and decides if USB PLL mode is used. If USB PLL mode is used, the USB clock frequency is obtained by dividing the source clock by USB PLL dividers.<br />
The frequency is obtained using following formula:<br />
If Normal Mode : fUSBPLL = (fOSC * N)/(P * 2).<br />
If Prescaler mode: fPLL = fOSC. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gabcba51c9d61c4f3e8a3e1bc816c5fb02">XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga720f80a8e2c129e7139c8bfec4afb962">XMC_SCU_CLOCK_GetECATClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga12c044e6458ccab71e1d8c045719d545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetWdtClockDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Ratio between the source of WDT clock and the WDT clock.<br />
 <b>Range:</b> 0 to 255.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the ratio between the WDT parent clock and the WDT clock. <br />
<br />
The value is obtained by reading <em>WDTDIV</em> bits of <em>WDTCLKCR</em> register. Ensure that the WDT parent clock is considered before using the value of the divider value. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga9061262a31285c0b5c3a13801650a453">XMC_SCU_CLOCK_SetWdtClockSource()</a>, <a class="el" href="group___s_c_u.html#ga8f338f60cac7809fafd01b0941d1a2c1">XMC_SCU_CLOCK_SetWdtClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga504e82a0763495f9d487ea0b0d5ebd7a">XMC_SCU_CLOCK_SetExternalOutputClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6266b7288cd6a209146d83d67f21b573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetWdtClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t WDT clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the frequency of WDT clock(fWDT).<br />
<br />
The value is derived using <em>WDTDIV</em> bits of <em>WDTCLKCR</em> register and WDT clock source. Based on these values it is calculated using the following formula:<br />
if WDT clock source = PLL: fWDT = fUSBPLL/(WDTDIV + 1).<br />
if WDT clock source = OFI: fWDT = fOFI/(WDTDIV + 1).<br />
if WDT clock source = Standby: fWDT = fSTDBY/(WDTDIV + 1).<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae5ee4bbf7462c9e3d2e3b15d845136da">XMC_SCU_CLOCK_GetWdtClockSource()</a>, <a class="el" href="group___s_c_u.html#ga12c044e6458ccab71e1d8c045719d545">XMC_SCU_CLOCK_GetWdtClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gae5ee4bbf7462c9e3d2e3b15d845136da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#ga77f22d4ceb0b920b48b87da63f62d174">XMC_SCU_CLOCK_WDTCLKSRC_t</a> XMC_SCU_CLOCK_GetWdtClockSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>XMC_SCU_CLOCK_WDTCLKSRC_t Clock source configured for watchdog timer.<br />
 <b>Range:</b> Use type XMC_SCU_CLOCK_WDTCLKSRC_t to identify the clock source.<br />
 XMC_SCU_CLOCK_WDTCLKSRC_OFI - internal fast oscillator (fOFI)<br />
 XMC_SCU_CLOCK_WDTCLKSRC_STDBY - backup standby clock (fSTDBY)<br />
 XMC_SCU_CLOCK_WDTCLKSRC_PLL - PLL output clock (fPLL)</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the source of clock used for watchdog timer.<br />
<br />
The value is obtained by reading <em>WDTSEL</em> bits of <em>WDTCLKCR</em> register. The time for timeout or pre-warning of watchdog has to be calculated based on the clock source selected. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga8f338f60cac7809fafd01b0941d1a2c1">XMC_SCU_CLOCK_SetWdtClockDivider()</a>, <a class="el" href="group___s_c_u.html#ga9061262a31285c0b5c3a13801650a453">XMC_SCU_CLOCK_SetWdtClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga387a75bbd0299d99fd8f818d1ea9886a">XMC_SCU_HIB_SetStandbyClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga08c337e8a728604e7eb54dff78ae2d9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Pointer to structure holding the clock prescaler values and divider values for configuring clock generators and clock tree.<br />
 <b>Range:</b> Configure the members of structure <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> for various parameters of clock setup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes clock generators and clock tree.<br />
<br />
Enables the high precision oscillator(fOHP) input and configures the system and peripheral clock frequencies. Based on the system clock source selected in <em>config</em>, either fPLL or fOFI will be chosen as system clock. Based on PLL mode(normal or prescaler mode) used, PLL ramps up in steps to achieve target frequency. The clock dividers for CPU, CCU and peripheral clocks will be set based on the input configuration. The <em>SystemCoreClock</em> variable is set with the value of system clock frequency. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow()</a>.</p>

</div>
</div>
<a class="anchor" id="ga52dd13c0aa61ed09a31f8137d28c4532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_CLOCK_IsClockEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga2bd90dc2daf0ff48625ab7b297b2cacd">XMC_SCU_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock</td><td>Peripheral for which the clock status has to be checked. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga2bd90dc2daf0ff48625ab7b297b2cacd">XMC_SCU_CLOCK_t</a> to select the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>bool Status of peripheral clock.<br />
 <b>Range:</b> <em>true</em> if peripheral clock is enabled. <em>false</em> if peripheral clock is disabled.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks the status of peripheral source clock.<br />
<br />
The status of peripheral source clock is read from the <em>CLKSTATn</em> register. Returns <em>true</em> if clock is enabled and returns <em>false</em> otherwise. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga31001fdc4707eb901996074ee0c6fcff">XMC_SCU_CLOCK_EnableClock()</a>, <a class="el" href="group___s_c_u.html#ga0f9078c8d5a83149c40812925f3c218d">XMC_SCU_CLOCK_DisableClock()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga804f98badedf0e0ba4ce09f445687a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_CLOCK_IsPeripheralClockGated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the check for clock gating has to be done. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> to identify the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>bool Status of the peripheral clock gating. <b>Range:</b> true if the peripheral clock is gated. false if the peripheral clock ungated(gate de-asserted).</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Gives the status of peripheral clock gating.<br />
<br />
Checks the status of peripheral clock gating using one of CGATSTAT0, CGATSTAT1 or CGATSTAT2 registers. It is recommended to use this API before enabling the gating of any peripherals through <em><a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a></em> API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b65db9f01407d2b3b98d5984ae09e71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_CLOCK_IsSystemPllLocked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Boolean value indicating if System PLL is locked</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Return status of System PLL VCO. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga356a667144dc0009582198bad1070d7a">XMC_SCU_CLOCK_StartSystemPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gab138fec040dc094a8a6579cfcaad2da8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_CLOCK_IsUsbPllLocked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Boolean value indicating if USB PLL is locked</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Return status of USB PLL VCO. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gacb5f410baf92504c4fc60bc33e167d9c">XMC_SCU_CLOCK_StartUsbPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ae09f0a2575e72f52d961ea5a4622cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetBackupClockCalibrationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_c_u.html#ga7ba412eed9b7e0f28d60090b5a53768d">XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Backup clock calibration mode.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga7ba412eed9b7e0f28d60090b5a53768d">XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t</a> to identify the calibration mode.<br />
 XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_FACTORY- Force trimming of internal oscillator with firmware configured values.<br />
 XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC- Calibrate internal oscillator automatically using standby clock(fSTDBY).<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the calibration mode of internal oscillator.<br />
<br />
Based on the calibration mode selected, the internal oscillator calibration will be configured. The calibration is useful while using fast internal clock(fOFI). When factory mode calibration is used, the internal oscillator is trimmed using the firmware configured values. If automatic calibration is selected, the internal oscillator will be monitored using the backup clock.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gac6d37853e6609aa646b4dd1517fddd54">XMC_SCU_CLOCK_SetSystemClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga222a00aedb2c6822f78f2794ef237f26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetCcuClockDivider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Ratio of fCCU clock source to the value of fCCU. <b>Range:</b> 1 or 2.<br />
 1-&gt; fCCU= fSYS <br />
 2-&gt; fCCU= fSYS/2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the divider for CCU clock source. <br />
<br />
Capture compare unit(CCU) can take either fSYS or fSYS/2 as the source of clock. The configuration is set to <em>CCUDIV</em> bit of <em>CCUCLKCR</em> register. The CCUDIV bit is 1 bit wide.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaabc40433a3a0c21f96993cfb6af038ae">XMC_SCU_CLOCK_GetCcuClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga700247f0d54ab409e0542547ce3546f9">XMC_SCU_CLOCK_GetSystemClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf5d0a11b4d5cad0f4516afb8b3976ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetCpuClockDivider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Ratio between system clock(fSYS) and CPU clock(fCPU). <b>Range:</b> 1 or 2.<br />
 1-&gt; fCPU= fSYS. <br />
 2-&gt; fCPU= fSYS/2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the CPU clock by setting the divider value for the system clock. <br />
<br />
The value is set to the <em>CPUDIV</em> bit of <em>CPUCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gab537dadfc72161a06f4f6dfa85449ae6">XMC_SCU_CLOCK_GetCpuClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#gaabc40433a3a0c21f96993cfb6af038ae">XMC_SCU_CLOCK_GetCcuClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="gacb869f7d0e646d10680f2ca8eb4124c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetDeepSleepConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Register configuration value that defines some system behavior aspects while in Deep Sleep mode.<br />
 Note: Refer user manual for valid register value before configuring the register. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configuration register that defines some system behavior aspects while in Deep Sleep mode. The PLL re-initialization is required after wake-up from Deep Sleep mode if was enabled before entering Deep Sleep mode and configured to go into power down while in Deep Sleep mode. <br />
 Note: Swiching off a module clock during operation may result in unexpected effects like e.g. clock spikes or protocol violations. Before entering Deep Sleep mode the affected modules should be in reset state. After restoration of the clocks the modules need to be re-initialized in order to ensure proper function. <br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0d4e4b167bff6189b508f9655693ca84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetEbuClockDivider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Ratio of PLL clock(fPLL) to EBU clock(fEBU).<br />
 <b>Range:</b> 1 to 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the EBU clock(fEBU) by setting the divider value.<br />
<br />
The clock divider is configured to the <em>EBUDIV</em> bits of <em>EBUCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga12fce693c9f70eae932924cacedd3d6b">XMC_SCU_CLOCK_GetEbuClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga129a4c1cd0e4963b8a573c25485cd693">XMC_SCU_CLOCK_GetUsbClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa20f63e6573fd17e9b0c05a004dcd499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetECATClockDivider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>divider</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Ratio between the source of ECAT clock and the ECAT clock.<br />
 <b>Range:</b> 1 to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the ECAT clock by setting the clock divider for the ECAT clock source.<br />
<br />
The value is configured to <em>ECADIV</em> bits of <em>ECATCLKCR</em> register. The value of divider is decremented by 1 before configuring. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaa7c721ac3ba6f1d066101176e103d5ff">XMC_SCU_CLOCK_SetECATClockSource()</a>, <a class="el" href="group___s_c_u.html#ga720f80a8e2c129e7139c8bfec4afb962">XMC_SCU_CLOCK_GetECATClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga24e64fe15f9ce0183a1bc5fba7bec579">XMC_SCU_CLOCK_GetExternalOutputClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa7c721ac3ba6f1d066101176e103d5ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetECATClockSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga26a3f6ccc6fa98818df8efd7e487d7c0">XMC_SCU_CLOCK_ECATCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source of ECAT clock.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga26a3f6ccc6fa98818df8efd7e487d7c0">XMC_SCU_CLOCK_ECATCLKSRC_t</a> to identify the clock source.<br />
 XMC_SCU_CLOCK_ECATCLKSRC_USBPLL - USB PLL (fUSBPLL) as a source for ECAT clock. <br />
 XMC_SCU_CLOCK_ECATCLKSRC_SYSPLL - Main PLL output (fPLL) as a source for ECAT clock. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the source of ECAT clock (fECAT).<br />
<br />
The value is configured to <em>ECATSEL</em> bit of <em>ECATCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga2786257933663aa4c54f9dc7c97422d4">XMC_SCU_CLOCK_GetECATClockSource()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga504e82a0763495f9d487ea0b0d5ebd7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetExternalOutputClockDivider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Ratio between the external output parent clock selected and the output clock.<br />
 <b>Range:</b> 1 to 512.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the external output clock by setting the divider value for the parent clock. <br />
<br />
The value will be configured to <em>ECKDIV</em> bits of <em>EXTCLKCR</em> register. The divider value is decremented by 1 before storing it to the bit fields. Ensure that the source of external output clock is configured appropriately using the API <a class="el" href="group___s_c_u.html#gae0e95e282cd20159627d036941caf0c7">XMC_SCU_CLOCK_SetExternalOutputClockSource()</a>. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae0e95e282cd20159627d036941caf0c7">XMC_SCU_CLOCK_SetExternalOutputClockSource()</a>, <a class="el" href="group___s_c_u.html#ga24e64fe15f9ce0183a1bc5fba7bec579">XMC_SCU_CLOCK_GetExternalOutputClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga12c044e6458ccab71e1d8c045719d545">XMC_SCU_CLOCK_GetWdtClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="gae0e95e282cd20159627d036941caf0c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetExternalOutputClockSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#gaaf5142b4b63fc9f6413c9deb3e7740a0">XMC_SCU_CLOCK_EXTOUTCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock</td><td>Source of external clock output(fEXT).<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gaaf5142b4b63fc9f6413c9deb3e7740a0">XMC_SCU_CLOCK_EXTOUTCLKSRC_t</a> to identify the clock.<br />
 XMC_SCU_CLOCK_EXTOUTCLKSRC_SYS - system clock fSYS. <br />
 XMC_SCU_CLOCK_EXTOUTCLKSRC_USB - USB clock fUSB. <br />
 XMC_SCU_CLOCK_EXTOUTCLKSRC_PLL - PLL output fPLL. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the source of external clock out (fEXT).<br />
<br />
The value will be configured to <em>ECKSEL</em> bits of <em>EXTCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae80c027210bcf8cdafd0fe8aa3274777">XMC_SCU_CLOCK_GetExternalOutputClockSource()</a>, <a class="el" href="group___s_c_u.html#ga504e82a0763495f9d487ea0b0d5ebd7a">XMC_SCU_CLOCK_SetExternalOutputClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#gaff7d07fb799f33da6bd55dfec0938f53">XMC_SCU_HIB_GetRtcClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga256245971cfb74c5260d5564bb01020a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetPeripheralClockDivider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Ratio of peripheral clock source to the value of peripheral clock.<br />
 <b>Range:</b> 1 or 2.<br />
 1-&gt; fPERIPH= fCPU.<br />
 2-&gt; fPERIPH= fCPU/2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the peripheral clock by setting the divider for CPU clock(fCPU).<br />
<br />
The peripheral clock can be equal to either fCPU or fCPU/2. The value is configured to <em>PBDIV</em> bit of <em>PBCLKCR</em> register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae163ddda50d4e04337cc17b3a3aed1f7">XMC_SCU_CLOCK_GetPeripheralClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#gab537dadfc72161a06f4f6dfa85449ae6">XMC_SCU_CLOCK_GetCpuClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga14af7311359e751a90c08ca3c80d6777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetSleepConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Register configuration value that defines some system behavior aspects while in Sleep mode.<br />
 Note: Refer user manual for valid register value before configuring the register. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configuration register that defines some system behavior aspects while in Deep Sleep mode. The original clock configuration gets restored upon wake-up from sleep mode. <br />
 Note: Swiching off a module clock during operation may result in unexpected effects like e.g. clock spikes or protocol violations. Before entering Sleep mode the affected modules should be in reset state. After restoration of the clocks the modules need to be re-initialized in order to ensure proper function. <br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gae07a3504f85acd247cd7b9315dcc4083"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetSystemClockDivider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>divider</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">divider</td><td>Ratio of fSYS clock source to the value of fSYS. <b>Range:</b> 1 to 256.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the ratio of system clock source to the value of system clock frequency.<br />
<br />
The value is configured as <em>SYSDIV</em> bits of <em>SYSCLKCR</em> register. The divider value is decremented by 1 before configuring. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga700247f0d54ab409e0542547ce3546f9">XMC_SCU_CLOCK_GetSystemClockDivider()</a>, <a class="el" href="group___s_c_u.html#gac6d37853e6609aa646b4dd1517fddd54">XMC_SCU_CLOCK_SetSystemClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga2786257933663aa4c54f9dc7c97422d4">XMC_SCU_CLOCK_GetECATClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gac6d37853e6609aa646b4dd1517fddd54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetSystemClockSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#gaccffa04837e2b0c2132f74f3c502139b">XMC_SCU_CLOCK_SYSCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source of clock for fSYS.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gaccffa04837e2b0c2132f74f3c502139b">XMC_SCU_CLOCK_SYSCLKSRC_t</a> to select the source of clock.<br />
 XMC_SCU_CLOCK_SYSCLKSRC_OFI for selecting internal fast clock as fSYS.<br />
 XMC_SCU_CLOCK_SYSCLKSRC_PLL for selecting the output of PLL fPLL as fSYS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the source for system clock (fSYS).<br />
<br />
System clock is selected by setting <em>SYSSEL</em> bits in the <em>SYSCLKCR</em> register. If <em>XMC_SCU_CLOCK_SYSCLKSRC_PLL</em> is selected, then the dividers of the PLL have to be additionally configured to achieve the required system clock frequency. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga356a667144dc0009582198bad1070d7a">XMC_SCU_CLOCK_StartSystemPll()</a>, <a class="el" href="group___s_c_u.html#gad8179be793c17dda72a87dea440dd118">XMC_SCU_CLOCK_EnableHighPerformanceOscillator()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gab274b04a774d18a4a7305f43ffb71d4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetSystemPllClockSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga91284bbc86bb476327771f3639cbe440">XMC_SCU_CLOCK_SYSPLLCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source of clock for system PLL.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga91284bbc86bb476327771f3639cbe440">XMC_SCU_CLOCK_SYSPLLCLKSRC_t</a> for identifying the clock source.<br />
 XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP - External High performance oscillator(fOHP).<br />
 XMC_SCU_CLOCK_SYSPLLCLKSRC_OFI - Internal fast clock (fOFI).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the source of system PLL.<br />
<br />
The value is configured to <em>VCOBYP</em> bit of <em>PLLCON0</em> register. If <em>XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP</em> is selected, ensure that the high performance oscillator is enabled by using the API <a class="el" href="group___s_c_u.html#gad8179be793c17dda72a87dea440dd118">XMC_SCU_CLOCK_EnableHighPerformanceOscillator()</a>. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gad8179be793c17dda72a87dea440dd118">XMC_SCU_CLOCK_EnableHighPerformanceOscillator()</a><br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#gae80c027210bcf8cdafd0fe8aa3274777">XMC_SCU_CLOCK_GetExternalOutputClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6bfbeee9da8ba9c854c34fc5da9a7d7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetUsbClockDivider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Ratio of PLL output clock(fPLL) to USB clock(fUSB). <b>Range:</b> 1 to 8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the USB clock(fUSB) by setting the USB clock divider. <br />
<br />
The value is decremented by 1 before setting it to <em>USBDIV</em> bits of <em>USBCLKCR</em> register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga129a4c1cd0e4963b8a573c25485cd693">XMC_SCU_CLOCK_GetUsbClockDivider()</a>, <a class="el" href="group___s_c_u.html#ga5332425bae1da209b9c6cc857f53d51e">XMC_SCU_CLOCK_SetUsbClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#gae163ddda50d4e04337cc17b3a3aed1f7">XMC_SCU_CLOCK_GetPeripheralClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5332425bae1da209b9c6cc857f53d51e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetUsbClockSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#gaa25fc7c21af145300a57dd93c391816d">XMC_SCU_CLOCK_USBCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source of clock for USB and SDMMC(fUSB/SDMMC).<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gaa25fc7c21af145300a57dd93c391816d">XMC_SCU_CLOCK_USBCLKSRC_t</a> to select the source of clock.<br />
 XMC_SCU_CLOCK_USBCLKSRC_USBPLL - output of USB PLL as source of USB clock(fUSB/SDMMC).<br />
 XMC_SCU_CLOCK_USBCLKSRC_SYSPLL - output of PLL fPLL as source of USB clock(fUSB/SDMMC).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the source of USB/SDMMC clock (fUSB/SDMMC).<br />
<br />
USB and SDMMC use a common clock source. They can either use fUSB PLL or fPLL as the source of clock. The selection is done by configuring the <em>USBSEL</em> bits of <em>USBCLKCR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga6bfbeee9da8ba9c854c34fc5da9a7d7d">XMC_SCU_CLOCK_SetUsbClockDivider()</a>, <a class="el" href="group___s_c_u.html#ga050ac1d63bf86241205c4fdcca3eb988">XMC_SCU_CLOCK_GetUsbPllClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga0e6bbfbc0d075a0e3bab4c4906136fcb">XMC_SCU_CLOCK_GetSystemClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f338f60cac7809fafd01b0941d1a2c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetWdtClockDivider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>Ratio between the source of WDT clock and the WDT clock.<br />
 <b>Range:</b> 1 to 256.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the WDT clock by setting the clock divider for the WDT clock source.<br />
<br />
The value is configured to <em>WDTDIV</em> bits of <em>WDTCLKCR</em> register. The value of divider is decremented by 1 before configuring. Check the selected clock source for the WDT clock before configuring the divider using the API <a class="el" href="group___s_c_u.html#ga9061262a31285c0b5c3a13801650a453">XMC_SCU_CLOCK_SetWdtClockSource()</a>. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga9061262a31285c0b5c3a13801650a453">XMC_SCU_CLOCK_SetWdtClockSource()</a>, <a class="el" href="group___s_c_u.html#ga12c044e6458ccab71e1d8c045719d545">XMC_SCU_CLOCK_GetWdtClockDivider()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga12fce693c9f70eae932924cacedd3d6b">XMC_SCU_CLOCK_GetEbuClockDivider()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9061262a31285c0b5c3a13801650a453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetWdtClockSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga77f22d4ceb0b920b48b87da63f62d174">XMC_SCU_CLOCK_WDTCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Clock source for watchdog timer.<br />
 <b>Range:</b> Use type XMC_SCU_CLOCK_WDTCLKSRC_t to identify the clock source.<br />
 XMC_SCU_CLOCK_WDTCLKSRC_OFI - internal fast oscillator (fOFI)<br />
 XMC_SCU_CLOCK_WDTCLKSRC_STDBY - backup standby clock (fSTDBY)<br />
 XMC_SCU_CLOCK_WDTCLKSRC_PLL - PLL output clock (fPLL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the source of WDT clock (fWDT).<br />
<br />
The selected value is configured to the <em>WDTSEL</em> bits of <em>WDTCLKCR</em> register. The watchdog timer counts at the frequency selected using this API. So the time for timeout or pre-warning of watchdog has to be calculated based on this selection.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga8f338f60cac7809fafd01b0941d1a2c1">XMC_SCU_CLOCK_SetWdtClockDivider()</a>, <a class="el" href="group___s_c_u.html#ga6266b7288cd6a209146d83d67f21b573">XMC_SCU_CLOCK_GetWdtClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga65588bdfa384f0f3deca2553ca2205be">XMC_SCU_CLOCK_GetUsbClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga356a667144dc0009582198bad1070d7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_StartSystemPll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_c_u.html#ga91284bbc86bb476327771f3639cbe440">XMC_SCU_CLOCK_SYSPLLCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_c_u.html#gad0bc6581cbe44ad6b1d649cbffe96875">XMC_SCU_CLOCK_SYSPLL_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ndiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>kdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>PLL clock source. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga91284bbc86bb476327771f3639cbe440">XMC_SCU_CLOCK_SYSPLLCLKSRC_t</a> to identify the clock source.<br />
 XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP- External high precision oscillator input. XMC_SCU_CLOCK_SYSPLLCLKSRC_OFI- Internal fast clock input. </td></tr>
    <tr><td class="paramname">mode</td><td>Mode of PLL operation.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gad0bc6581cbe44ad6b1d649cbffe96875">XMC_SCU_CLOCK_SYSPLL_MODE_t</a> to identify the PLL mode. <br />
 XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL- PLL frequency obtained from output of VCO(fVCO).<br />
 XMC_SCU_CLOCK_SYSPLL_MODE_PRESCALAR- VCO is bypassed. Frequency obtained from fOSC.<br />
</td></tr>
    <tr><td class="paramname">pdiv</td><td>Input divider. Represents (PDIV+1) applied to external reference frequency. <br />
 <b>Range:</b> 1 to 16.<br />
</td></tr>
    <tr><td class="paramname">ndiv</td><td>Feedback divider. Represents(NDIV+1) <br />
 <b>Range:</b> 1 to 128. <br />
</td></tr>
    <tr><td class="paramname">kdiv</td><td>Output divider. Represents (K2DIV+1) in normal PLL mode or (K1DIV+1) in prescaler mode.<br />
 <b>Range:</b> 1 to 128. <br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables system PLL.<br />
<br />
Based on the selected source of clock, either external frequency fOHP or internal clock fOFI will be used. Based on the selected PLL mode, either voltage controlled oscillator(VCO) output(fVCO) or direct input frequency is used for the output dividers.<br />
The API implements the following sequence:<br />
<ul>
<li>Store the value of TRAPDIS register into a temporary variable before disabling all traps.<br />
</li>
<li>Clear all PLL related traps.<br />
</li>
<li>If external fOHP is selected as source, wait for the external oscillator to stabilize.<br />
</li>
<li>If PLL normal mode is selected, calculate the value of K2DIV and configure the PDIV, NDIV and K2DIV values.<br />
</li>
<li>Ramp up the PLL frequency in steps. <br />
</li>
<li>If prescaler mode is selected, configure the value of K1DIV.<br />
</li>
<li>Wait for LOCK.<br />
</li>
<li>Restore the trap configuration from stored temporary variable.<br />
 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae8c2602ab7184dbeda09e0ca0e690168">XMC_SCU_CLOCK_GetSystemPllClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga879eeaff71fe00dd7fc148b481ce8379">XMC_SCU_CLOCK_StopSystemPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gacb5f410baf92504c4fc60bc33e167d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_StartUsbPll </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ndiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdiv</td><td>Input divider value. Represents (PDIV+1) divider for the USB PLL.<br />
 <b>Range:</b> 1 to 16. </td></tr>
    <tr><td class="paramname">ndiv</td><td>VCO feedback divider for USB PLL. Represents (NDIV+1) feedback divider.<br />
 <b>Range:</b> 1 to 128.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures USB PLL dividers and enables the PLL.<br />
<br />
The API follows the required sequence for safely configuring the divider values of USB PLL. Checks for PLL stabilization before enabling the same. After the configuring the dividers, it waits till the VCO lock is achieved. The sequence followed is as follows:<br />
<ul>
<li>Enable the USB PLL and configure VCO to be bypassed.<br />
</li>
<li>Set up the HP oscillator clock input.<br />
</li>
<li>Store the value of TRAPDIS register into a temporary variable before disabling all traps.<br />
</li>
<li>Clear all USBPLL related traps.<br />
</li>
<li>Disconnect the oscillator from USB PLL and configure the dividers PDIV and NDIV. <br />
</li>
<li>Connect the oscillator to USB PLL and enable VCO.<br />
</li>
<li>Wait for LOCK.<br />
</li>
<li>Restore the trap configuration from stored temporary variable.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga11067ab015e6a6632cf9be194a4f8d6b">XMC_SCU_CLOCK_StopUsbPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga381e223afdcbd3d2766a24958468dc0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_StepSystemPllFrequency </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>kdiv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdiv</td><td>PLL output divider K2DIV. <br />
 <b>Range:</b> 1 to 128. Represents (K2DIV+1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Ramps up or ramps down the PLL output frequency in provided step. <br />
<br />
The PLL output frequency is divided by the <em>kdiv</em> value. This generates a step of ramp for the PLL output frequency. The API waits for the clock to stabilize before the completing its execution. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga356a667144dc0009582198bad1070d7a">XMC_SCU_CLOCK_StartSystemPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga879eeaff71fe00dd7fc148b481ce8379"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_StopSystemPll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the system PLL. PLL is placed in power saving mode. It disables the PLL by setting the <em>PLLPWD</em> bit of <em>PLLCON0</em> register. If the PLL is put to power saving mode, it can no longer be used. It is recommended to ensure following steps before using <em>XMC_SCU_CLOCK_StopSystemPll</em> API:<br />
<ul>
<li>Store the value of TRAPDIS register into a temporary variable before disabling all traps.<br />
</li>
<li>Clear all PLL related traps.<br />
</li>
<li>Ramp down frequency until fPLL reaches backup clock frequency (fOFI).<br />
</li>
<li>Disable PLL.<br />
</li>
<li>Restore the trap configuration from stored temporary variable.<br />
 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae8c2602ab7184dbeda09e0ca0e690168">XMC_SCU_CLOCK_GetSystemPllClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga356a667144dc0009582198bad1070d7a">XMC_SCU_CLOCK_StartSystemPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga11067ab015e6a6632cf9be194a4f8d6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_StopUsbPll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables USB PLL operation.<br />
<br />
USB PLL is disabled by placing the USB PLL in power saving mode. The VCO and USB PLL are put in power saving mode by setting the <em>PLLPWD</em> bit and <em>VCOPWD</em> bit of <em>USBLLCON</em> register to 1. VCO bypass mode is enabled by setting the <em>VCOBYP</em> bit of <em>USBLLCON</em> register to 1. It is recommended to ensure following steps before using <em>XMC_SCU_CLOCK_StopUsbPll</em> API:<br />
<ul>
<li>Store the value of TRAPDIS register into a temporary variable before disabling all traps.<br />
</li>
<li>Clear all USBPLL related traps.<br />
</li>
<li>Ramp down frequency.<br />
</li>
<li>Disable PLL.<br />
</li>
<li>Restore the trap configuration from stored temporary variable.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gacb5f410baf92504c4fc60bc33e167d9c">XMC_SCU_CLOCK_StartUsbPll()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga702904d10b6e6c6a55db381763fd322f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_UngatePeripheralClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the clock has to be ungated. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> to identify the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the supply of clock to the selected peripheral.<br />
<br />
By default when the device powers on, the peripheral clock will be gated for the peripherals that support clock gating. The peripheral clock should be enabled before using it for any functionality. fPERI is the source of clock to various peripherals. Some peripherals support clock gate. Software can request for individual ungating of such peripheral clocks by setting the respective bits in one of <em>SCU_CGATCLR0</em>, <em>SCU_CGATCLR1</em> or <em>SCU_CGATCLR2</em> registers.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gafbf7bd240140468c6235149828dc3e7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_DisableOutOfRangeComparator </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>ADC Group to which the channel being monitored belongs to.<br />
 <b>Range:</b> 0 or 1. </td></tr>
    <tr><td class="paramname">channel</td><td>The channel whose voltage range has to be monitored.<br />
 <b>Range:</b> 6 or 7. Value identifies the channel in the selected ADC group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the out of range comparator for the selected ADC group and the channel. <br />
<br />
Out of range comparator is disabled by clearing the enable bit in the GORCEN register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga51d593608a5e056fb40c1cc2b340fb2a">XMC_SCU_EnableOutOfRangeComparator()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga95190e4549898b0f02b653045d5816b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_DisableTemperatureSensor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables die temperature measurement by powering the DTS module off.<br />
<br />
Die temperature sensor is disabled by clearing the PWD bit of DTSCON register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3f6a1e71b005175777c6dd9a069e325c">XMC_SCU_EnableTemperatureSensor()</a>, <a class="el" href="group___s_c_u.html#gaedec5f2ce4cc799cad5026d5ec76a1f2">XMC_SCU_IsTemperatureSensorEnabled()</a>, <a class="el" href="group___s_c_u.html#gacf86e99e8def2e37a0b484982e61256d">XMC_SCU_CalibrateTemperatureSensor()</a>, <a class="el" href="group___s_c_u.html#gabac9292e193c9804b5a6856de186737e">XMC_SCU_StartTemperatureMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga8ac62bd07097bb83cd294a1d6625af36">XMC_SCU_GetTemperatureMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga51d593608a5e056fb40c1cc2b340fb2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_EnableOutOfRangeComparator </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>ADC Group to which the channel being monitored belongs to.<br />
 <b>Range:</b> 0 or 1. </td></tr>
    <tr><td class="paramname">channel</td><td>The channel whose voltage range has to be monitored.<br />
 <b>Range:</b> 6 or 7. Value identifies the channel in the selected ADC group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables out of range comparator for the selected ADC group and channel. <br />
<br />
The ADC channel input is compared by Out of Range Comparator (ORC) for overvoltage monitoring or for detection of out of range analog inputs. ORC must be turned on explicitly to leverage the auditing feature. ORC is enabled by setting the enable bit in the GORCEN register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gafbf7bd240140468c6235149828dc3e7e">XMC_SCU_DisableOutOfRangeComparator()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3f6a1e71b005175777c6dd9a069e325c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_EnableTemperatureSensor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables die temperature measurement by powering the DTS module.<br />
<br />
Die temperature sensor is enabled by setting the PWD bit of DTSCON register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga95190e4549898b0f02b653045d5816b7">XMC_SCU_DisableTemperatureSensor()</a>, <a class="el" href="group___s_c_u.html#gaedec5f2ce4cc799cad5026d5ec76a1f2">XMC_SCU_IsTemperatureSensorEnabled()</a>, <a class="el" href="group___s_c_u.html#gacf86e99e8def2e37a0b484982e61256d">XMC_SCU_CalibrateTemperatureSensor()</a>, <a class="el" href="group___s_c_u.html#gabac9292e193c9804b5a6856de186737e">XMC_SCU_StartTemperatureMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga8ac62bd07097bb83cd294a1d6625af36">XMC_SCU_GetTemperatureMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2a6d9572718fe6822b42522947fe822b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_GetBootMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Configured boot mode for the device.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gaee17d2349a9e695f89aaa67972035bb6">XMC_SCU_BOOTMODE_t</a> for enumeration of different boot modes.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the boot mode configured for the device.<br />
<br />
The boot mode is read from the <em>STCON</em> register bit field <em>SWCON</em>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3ebb50291e4fc5722746f2f40fadb6a8">XMC_SCU_SetBootMode()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga494b75a841498374cfee9664e6ce9cee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_GetMirrorStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Status of the register mirror update.<br />
 <b>Range:</b> Use the bit mask of the SCU_GENERAL_MIRRSTS register for the mirror update event of interest. e.g.: SCU_GENERAL_MIRRSTS_RTC_CTR_Msk. Multiple update events can be combined using <em>OR</em> operation.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of hibernate domain register update, when the respective mirror registers are changed. <br />
<br />
The hibernate domain is connected to the core domain via SPI serial communication. MIRRSTS is a status register representing the communication of changed value of a mirror register to its corresponding register in the hibernate domain. The bit fields of the register indicate that a corresponding register of the hibernate domain is ready to accept a write or that the communication interface is busy with executing the previous operation.<br />
Note: There is no hibernate domain in XMC1x devices. This register is retained for legacy purpose. </dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a> und <a class="el" href="group___s_c_u.html#ga9ba1ce317ce89edfea107893fbd8a0be">XMC_SCU_IRQHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ac62bd07097bb83cd294a1d6625af36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_GetTemperatureMeasurement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Measured temperature value.<br />
 <b>Range:</b> Valid temperature range is 0 to 1023. <br />
 If sensor is not enabled, 0x7FFFFFFFH is returned.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Reads the measured value of die temperature.<br />
<br />
Temperature measurement result is read from <em>RESULT</em> bit field of <em>DTSSTAT</em> register. The temperature measured in C is given by (RESULT - 605) / 2.05 [C] </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga09f2786f94680cc125ead431f3c4d9c4">XMC_SCU_IsTemperatureSensorBusy()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gae5c8ea8d8a577e936a3dde5239966337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_HIB_DisableHibernateDomain </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Powers down the hibernation domain.<br />
<br />
After disabling the hibernate domain, none of the peripherals from the hibernte domain can be used. Hibernate domain is disabled by setting the <em>HIB</em> bit of <em>PWRCLR</em> register and \ HIBRS bit of <em>RSTSET</em> register.<br />
It is recommended to use following steps to verify whether a hibernation domain is enabled/disabled:<br />
<ul>
<li>Call <em>XMC_SCU_HIB_DisableHibernateDomain</em> .</li>
<li>Call <em>XMC_SCU_HIB_IsHibernateDomainEnabled</em> and check return value. If return value is true, it indicates that the hibernation domain is enabled otherwise disabled.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga2f73953dadc8eaa2fad5e66a2c2e57a4">XMC_SCU_HIB_EnableHibernateDomain()</a>, <a class="el" href="group___s_c_u.html#ga725038f7765622ede258de69e21971a4">XMC_SCU_HIB_IsHibernateDomainEnabled()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa09c64c2a7a15e6cba8b97de86c87c6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_HIB_DisableInternalSlowClock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables slow internal oscillator(fOSI).<br />
<br />
By default on device power up, the slow internall oscillator is enabled. It can be disabled only if the external oscillator(fULP) is enabled and toggling. It is recommended to enable fOSI to prevent deadlock if fULP fails. fOSI is disabled by setting the <em>PWD</em> bit of <em>OSCSICTRL</em> register. The API waits for the mirror register update of the configured register. The slow internal oscillator registers are in hibernate domain. Ensure that the hibernate domain is enabled before changing the configuration. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gadaa00ec6206d10e3840504ba592f5725">XMC_SCU_HIB_EnableInternalSlowClock()</a>, <a class="el" href="group___s_c_u.html#ga8ae09f0a2575e72f52d961ea5a4622cf">XMC_SCU_CLOCK_SetBackupClockCalibrationMode()</a>, <a class="el" href="group___s_c_u.html#ga2f73953dadc8eaa2fad5e66a2c2e57a4">XMC_SCU_HIB_EnableHibernateDomain()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2f73953dadc8eaa2fad5e66a2c2e57a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_HIB_EnableHibernateDomain </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Powers up the hibernation domain.<br />
<br />
Hibernate domain should be enabled before using any peripheral from the hibernate domain. It enables the power to the hibernate domain and moves it out of reset state. Power to hibernate domain is enabled by setting the <em>HIB</em> bit of <em>PWRSET</em> register only if it is currently powered down. The API will wait until HIB domain is enabled. If hibernate domain is in a state of reset, <em>HIBRS</em> bit of <em>RSTCLR</em> register is set to move it out of reset state.<br />
It is recommended to use following steps to verify whether a hibernation domain is enabled/disabled:<br />
<ul>
<li>Call <em>XMC_SCU_HIB_EnableHibernateDomain</em> .</li>
<li>Call <em>XMC_SCU_HIB_IsHibernateDomainEnabled</em> and check the return value. If return value is true, it indicates that the hibernation domain is enabled otherwise disabled.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae5c8ea8d8a577e936a3dde5239966337">XMC_SCU_HIB_DisableHibernateDomain()</a>, <a class="el" href="group___s_c_u.html#ga725038f7765622ede258de69e21971a4">XMC_SCU_HIB_IsHibernateDomainEnabled()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gadaa00ec6206d10e3840504ba592f5725"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_HIB_EnableInternalSlowClock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables slow internal oscillator(fOSI).<br />
<br />
By default on device power up, the slow internall oscillator is enabled. It can be disabled only if the external oscillator(fULP) is enabled and toggling. It is recommended to enable fOSI to prevent deadlock if fULP fails. fOSI is enabled by clearing the <em>PWD</em> bit of <em>OSCSICTRL</em> register. The API waits for the mirror register update of the configured register. The slow internal oscillator registers are in hibernate domain. Ensure that the hibernate domain is enabled before changing the configuration. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaa09c64c2a7a15e6cba8b97de86c87c6e">XMC_SCU_HIB_DisableInternalSlowClock()</a>, <a class="el" href="group___s_c_u.html#ga8ae09f0a2575e72f52d961ea5a4622cf">XMC_SCU_CLOCK_SetBackupClockCalibrationMode()</a>, <a class="el" href="group___s_c_u.html#ga2f73953dadc8eaa2fad5e66a2c2e57a4">XMC_SCU_HIB_EnableHibernateDomain()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gaff7d07fb799f33da6bd55dfec0938f53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gad0408131d64c97d53a863b982225e664">XMC_SCU_HIB_RTCCLKSRC_t</a> XMC_SCU_HIB_GetRtcClockSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>XMC_SCU_HIB_RTCCLKSRC_t Source of RTC clock.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gad0408131d64c97d53a863b982225e664">XMC_SCU_HIB_RTCCLKSRC_t</a> to identify the clock source.<br />
 XMC_SCU_HIB_RTCCLKSRC_OSI - internal slow oscillator(fOSI). <br />
 XMC_SCU_HIB_RTCCLKSRC_ULP - ultra low power oscillator(fULP). <br />
 </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the source of RTC clock (fRTC). The value is obtained by reading <em>RCS</em> bit of <em>HDCR</em> register. The frequency of the clock will be 32.768 kHz. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gadca7d1332ed62fda2a1a85550d12f06d">XMC_SCU_HIB_SetRtcClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#gae0e95e282cd20159627d036941caf0c7">XMC_SCU_CLOCK_SetExternalOutputClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga893f5ed38bc3417a1b6482bda5031e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gad0408131d64c97d53a863b982225e664">XMC_SCU_HIB_RTCCLKSRC_t</a> XMC_SCU_HIB_GetStdbyClockSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>XMC_SCU_HIB_RTCCLKSRC_t Source clock of standby clock(fSTDBY).<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga8290034e7a28d8e2e8ed0086d6f92ab5">XMC_SCU_HIB_STDBYCLKSRC_t</a> to identify the clock source.<br />
 XMC_SCU_HIB_STDBYCLKSRC_OSI - internal slow oscillator (fOSI) <br />
 XMC_SCU_HIB_STDBYCLKSRC_OSCULP - ultra low power osciallator (fULP) <br />
 </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the source of standby clock (fSTDBY).<br />
<br />
The value is obtained by reading <em>STDBYSEL</em> bits of <em>HDCR</em> register.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga387a75bbd0299d99fd8f818d1ea9886a">XMC_SCU_HIB_SetStandbyClockSource()</a>, <a class="el" href="group___s_c_u.html#ga2f73953dadc8eaa2fad5e66a2c2e57a4">XMC_SCU_HIB_EnableHibernateDomain()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#gadca7d1332ed62fda2a1a85550d12f06d">XMC_SCU_HIB_SetRtcClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga725038f7765622ede258de69e21971a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_HIB_IsHibernateDomainEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>bool Power status of hibernate domain.<br />
 <b>Range:</b> Boolean state value.<br />
 <em>true</em> if hibernate domain is enabled.<br />
 <em>false</em> if hibernate domain is disabled.<br />
</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks whether hibernation domain is enabled/disabled.<br />
<br />
The API can be used before using the peripherals from hibernation domain to ensure that the power is supplied to the peripherals and also that the hibernation domain is not in reset state. The status is obtained using the <em>HIBEN</em> bit of <em>PWRSTAT</em> register and <em>HIBRS</em> bit of <em>RSTSET</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga2f73953dadc8eaa2fad5e66a2c2e57a4">XMC_SCU_HIB_EnableHibernateDomain()</a>, <a class="el" href="group___s_c_u.html#gae5c8ea8d8a577e936a3dde5239966337">XMC_SCU_HIB_DisableHibernateDomain()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="gadca7d1332ed62fda2a1a85550d12f06d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_HIB_SetRtcClockSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#gad0408131d64c97d53a863b982225e664">XMC_SCU_HIB_RTCCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source of RTC clock.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gad0408131d64c97d53a863b982225e664">XMC_SCU_HIB_RTCCLKSRC_t</a> to identify the clock source.<br />
 XMC_SCU_HIB_RTCCLKSRC_OSI - internal slow oscillator(fOSI). <br />
 XMC_SCU_HIB_RTCCLKSRC_ULP - ultra low power oscillator(fULP). <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the source of RTC clock (fRTC).<br />
<br />
The value is configured to <em>RCS</em> bit of <em>HDCR</em> register. fULP needs external input powered by VBAT or VDDP. fOSI is internal clock. The frequency of the clock will be 32.768 kHz. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaff7d07fb799f33da6bd55dfec0938f53">XMC_SCU_HIB_GetRtcClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga893f5ed38bc3417a1b6482bda5031e0c">XMC_SCU_HIB_GetStdbyClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga387a75bbd0299d99fd8f818d1ea9886a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_HIB_SetStandbyClockSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga8290034e7a28d8e2e8ed0086d6f92ab5">XMC_SCU_HIB_STDBYCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source for standby clock.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga8290034e7a28d8e2e8ed0086d6f92ab5">XMC_SCU_HIB_STDBYCLKSRC_t</a> to identify the clock source.<br />
 XMC_SCU_HIB_STDBYCLKSRC_OSI - internal slow oscillator (fOSI) <br />
 XMC_SCU_HIB_STDBYCLKSRC_OSCULP - ultra low power osciallator (fULP) <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the source of Standby clock (fSTDBY).<br />
<br />
Clock source is configured by setting the <em>STDBYSEL</em> bits of <em>HDCR</em> register. Hibernate domain should be enabled explicitly before using the API. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga893f5ed38bc3417a1b6482bda5031e0c">XMC_SCU_HIB_GetStdbyClockSource()</a>, <a class="el" href="group___s_c_u.html#ga2f73953dadc8eaa2fad5e66a2c2e57a4">XMC_SCU_HIB_EnableHibernateDomain()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#gae5ee4bbf7462c9e3d2e3b15d845136da">XMC_SCU_CLOCK_GetWdtClockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a0ad9c467d9549542d0f0275bae6314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_HighTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>bool Indicates if the measured die temperature value has exceeded the configured upper limit.<br />
 <b>Range:</b> <em>true</em> if the temperature value has exceeded the configured upper limit. <em>false</em> if the temperature value is less than the configured upper limit.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks if the measured temperature has exceeded the configured upper limit of temperature.<br />
<br />
The API checks <em>OVERFL</em> bit (Upper Limit Overflow Status bit) of <em>DTEMPALARM</em> register. The <em>OVERFL</em> bit will be set if the measured temperature has exceeded the limit configured in the bitfield <em>UPPER</em> in the <em>DTEMPLIM</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>,<a class="el" href="group___s_c_u.html#ga8573534003ebf11fbaa49e331238fb86">XMC_SCU_LowTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gabd2e577339ff5af48261d18e0e41dc50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_ClearEventStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the events to clear. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the event status bit in SRRAW register.<br />
<br />
The events are cleared by writing value 1 to their bit positions in the SRCLR register. The API can be used when polling method is used. After detecting the event, the event status should be cleared using software to detect the event again.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus()</a>, <a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa814678729d6b7f41c558e768ba8ecd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_DisableEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to disable. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables generation of interrupt on occurrence of the input event.<br />
<br />
The events are disabled by resetting the respective bit fields in the SRMSK register. <br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>NVIC_DisableIRQ(), <a class="el" href="group___s_c_u.html#gab4cfb9545d1e561e1f24aeaa69af821c">XMC_SCU_INTERRUPT_EnableEvent()</a><br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow()</a>.</p>

</div>
</div>
<a class="anchor" id="gada4c1f90be9bb22b2b404d26fd88535c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_DisableNmiRequest </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Non-maskable interrupt (NMI) request source to be disabled.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga5a0bae480e780bdd2dd407dfd1c30816">XMC_SCU_NMIREQ_t</a> for selecting the source of NMI. Multiple sources can be combined using <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selectively disables interrupt sources from generating non maskable interrupt(NMI).<br />
<br />
NMI assertion can be individually disabled by clearing corresponding bits in the <em>NMIREQEN</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gab4cfb9545d1e561e1f24aeaa69af821c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_EnableEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to enable. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the generation of interrupt for the input events.<br />
<br />
The events are enabled by setting the respective bit fields in the SRMSK register. <br />
Note: User should separately enable the NVIC node responsible for handling the SCU interrupt. The interrupt will be generated when the respective event occurs. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>NVIC_EnableIRQ(), <a class="el" href="group___s_c_u.html#gaa814678729d6b7f41c558e768ba8ecd4">XMC_SCU_INTERRUPT_DisableEvent()</a><br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9595d70f3cb1cd35b236afdd058c5895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_EnableNmiRequest </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Non-maskable interrupt (NMI) request source to be enabled.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga5a0bae480e780bdd2dd407dfd1c30816">XMC_SCU_NMIREQ_t</a> for selecting the source of NMI. Multiple sources can be combined using <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selectively enables interrupt sources to generate non maskable interrupt(NMI).<br />
<br />
NMI assertion can be individually enabled by setting corresponding bit of an interrupt in the <em>NMIREQEN</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gada4c1f90be9bb22b2b404d26fd88535c">XMC_SCU_INTERRUPT_DisableNmiRequest()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4ae03c6bcc3ccade266b46d84f7715e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> XMC_SCU_INTERRUPT_SetEventHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event for which the interrupt handler is to be configured. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> for identifying the event. </td></tr>
    <tr><td class="paramname">handler</td><td>Name of the function to be executed when the event if detected. <br />
 <b>Range:</b> The function accepts no arguments and returns no value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>XMC_SCU_STATUS_t Status of configuring the event handler function for the selected event.<br />
 <b>Range:</b> <em>XMC_SCU_STATUS_OK</em> if the event handler is successfully configured.<br />
 <em>XMC_SCU_STATUS_ERROR</em> if the input event is invalid.<br />
</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Assigns the event handler function to be executed on occurrence of the selected event.<br />
<br />
If the input event is valid, the handler function will be assigned to a table to be executed when the interrupt is generated and the event status is set in the event status register. By using this API, polling for a particular event can be avoided. This way the CPU utilization will be optimized. Multiple SCU events can generate a common interrupt. When the interrupt is generated, a common interrupt service routine is executed. It checks for status flags of events which can generate the interrupt. The handler function will be executed if the event flag is set.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent()</a>, <a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga494b75a841498374cfee9664e6ce9cee">XMC_SCU_GetMirrorStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa55b2098ce803174e7dfd680d0c30728"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_TriggerEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to be triggered. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Triggers the event as if the hardware raised it.<br />
<br />
Event will be triggered by setting the respective bitfield in the SRSET register.<br />
Note: User should enable the NVIC node that handles the respective event for interrupt generation. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>NVIC_EnableIRQ(), <a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus()</a>, <a class="el" href="group___s_c_u.html#gabd2e577339ff5af48261d18e0e41dc50">XMC_SCU_INTERRUPT_ClearEventStatus()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow()</a>.</p>

</div>
</div>
<a class="anchor" id="gae23dfad3e5e11c78791e5d5a777c44a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> XMC_SCU_INTERUPT_GetEventStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Status of the SCU events.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of all SCU events.<br />
<br />
The status is read from the SRRAW register. To check the status of a particular event, the returned value should be masked with the bit mask of the event. The bitmask of events can be obtained using the type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>. Multiple events' status can be checked by combining the bit masks using <em>OR</em> operation. After detecting the event, the event status should be cleared using software to detect the event again. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gabd2e577339ff5af48261d18e0e41dc50">XMC_SCU_INTERRUPT_ClearEventStatus()</a>, <a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent()</a>, <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ba1ce317ce89edfea107893fbd8a0be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sr_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">sr_num</td><td>Service request number identifying the SCU interrupt generated.<br />
 <b>Range:</b> 0 to 2. XMC4x devices have one common SCU interrupt, so the value should be 0.<br />
 But XMC1x devices support 3 interrupt nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None </dd></dl>
<dl class="section user"><dt>Description</dt><dd>A common function to execute callback functions for multiple events.<br />
<br />
It checks for the status of events which can generate the interrupt with the selected service request. If the event is set, the corresponding callback function will be executed. It also clears the event status bit.<br />
<b>Note:</b> This is an internal function. It should not be called by the user application.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga494b75a841498374cfee9664e6ce9cee">XMC_SCU_GetMirrorStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga09f2786f94680cc125ead431f3c4d9c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_IsTemperatureSensorBusy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>bool Indicates if the die temperature sensor is busy.<br />
 <b>Range:</b> <em>true</em> if sensor is busy in temperature measurement. <em>false</em> if sensor is free and can accept a new request for measurement.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks whether Die Temperature Sensor (DTS) is busy in temperature measurement.<br />
<br />
The status is read from the <em>BUSY</em> bit field of the <em>DTSSTAT</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga8ac62bd07097bb83cd294a1d6625af36">XMC_SCU_GetTemperatureMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaedec5f2ce4cc799cad5026d5ec76a1f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_IsTemperatureSensorEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>Status of die temperature sensor. <br />
 <b>Range:</b> true - if temperature sensor is enabled.<br />
 false - if temperature sensor is disabled.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the die temperature sensor power status.<br />
<br />
The status is obtained by reading the PWD bit of DTSCON register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3f6a1e71b005175777c6dd9a069e325c">XMC_SCU_EnableTemperatureSensor()</a>, <a class="el" href="group___s_c_u.html#gacf86e99e8def2e37a0b484982e61256d">XMC_SCU_CalibrateTemperatureSensor()</a>, <a class="el" href="group___s_c_u.html#gabac9292e193c9804b5a6856de186737e">XMC_SCU_StartTemperatureMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga8ac62bd07097bb83cd294a1d6625af36">XMC_SCU_GetTemperatureMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gac57499ff739d75ea0f53f51d2fd51505"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_IsTemperatureSensorReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>bool Status of die temperature sensor whether it is ready to start measurement. <br />
 <b>Range:</b> <br />
 <em>true</em> if temperature sensor is ready to start measurement. <br />
 <em>false</em> if temperature sensor is not ready to start measurement.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks if the die temperature sensor is ready to start a measurement<br />
<br />
The status is obtained by reading <em>RDY</em> bit of <em>DTSSTAT</em> register. It is recommended to check the ready status of die temperature sensor before starting it. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gabac9292e193c9804b5a6856de186737e">XMC_SCU_StartTemperatureMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga09f2786f94680cc125ead431f3c4d9c4">XMC_SCU_IsTemperatureSensorBusy()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8573534003ebf11fbaa49e331238fb86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_LowTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>bool Indicates if the measured die temperature value has dropped below the configured lower limit.<br />
 <b>Range:</b> <em>true</em> if the temperature value has dropped below the configured lower limit. <em>false</em> if the temperature value is higher than the configured lower limit.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks if the measured temperature has dropped below the configured lower limit of temperature.<br />
<br />
The API checks <em>UNDERFL</em> bit (Lower LimitUnderflow Status bit) of <em>DTEMPALARM</em> register. The <em>UNDERFL</em> bit will be set if the measured temperature has dropped below the limit configured in the bitfield <em>LOWER</em> in the <em>DTEMPLIM</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>,<a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0c564412ab3d6a5d43c4fde9035cf07f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_PARITY_ClearStatus </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>The on-chip RAM type, for which the parity error status has to be cleared.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga22ea4f1155833e07a1ec13cd2c4cb4e0">XMC_SCU_PARITY_t</a> to identify the on-chip RAM type. Multiple memory status bits can be cleared by using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the parity error status bit. <br />
<br />
When a memory parity error is detected using the status bits in <em>PEFLAG</em> register. It has to be cleared by software to detect the parity error from the same memory next time. The API clears the parity error status bit of the selected peripheral by setting the respective bit in the <em>PEFLAG</em> register. Status of multiple memory parity errors can be cleared by combining the enum values using <em>OR</em> operation. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gabfb74be3c54ea80b2fd25d20e143a299">XMC_SCU_PARITY_GetStatus()</a>, <a class="el" href="group___s_c_u.html#gab020813ed43c4a858e3866254546aca3">XMC_SCU_PARITY_Enable()</a>, <a class="el" href="group___s_c_u.html#gafef433d566f700f9106db98439af3f88">XMC_SCU_PARITY_EnableTrapGeneration()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gae85c78b1d38fcd51069d4f2a131d280f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_PARITY_Disable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>The on-chip RAM type, for which the parity error checking has to be disabled.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga22ea4f1155833e07a1ec13cd2c4cb4e0">XMC_SCU_PARITY_t</a> to identify the on-chip RAM type. Multiple memory types can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables parity error checking for the selected on-chip RAM type.<br />
<br />
Parity error detection can be disabled by clearing the respective bit in the <em>PEEN</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gab020813ed43c4a858e3866254546aca3">XMC_SCU_PARITY_Enable()</a>, <a class="el" href="group___s_c_u.html#ga763ff133611bd2b42456fa9e8f3e34af">XMC_SCU_PARITY_DisableTrapGeneration()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga763ff133611bd2b42456fa9e8f3e34af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_PARITY_DisableTrapGeneration </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>The on-chip RAM type, for which the parity error trap generation has to be disabled.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga22ea4f1155833e07a1ec13cd2c4cb4e0">XMC_SCU_PARITY_t</a> to identify the on-chip RAM type. Multiple memory types can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the assertion of trap for the parity error source.<br />
<br />
Trap assertion can be disabled by clearing the respective bit of the RAM type in the <em>PETE</em> register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gafef433d566f700f9106db98439af3f88">XMC_SCU_PARITY_EnableTrapGeneration()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gab020813ed43c4a858e3866254546aca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_PARITY_Enable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>The on-chip RAM type, for which the parity error checking has to be enabled.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga22ea4f1155833e07a1ec13cd2c4cb4e0">XMC_SCU_PARITY_t</a> to identify the on-chip RAM type. Multiple memory types can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables parity error checking for the selected on-chip RAM type.<br />
<br />
Parity error checking can be enabled by setting respective bits in the <em>PEEN</em> register. Additionally parity error can be configured to generate trap when the error is detected, using the API <a class="el" href="group___s_c_u.html#gafef433d566f700f9106db98439af3f88">XMC_SCU_PARITY_EnableTrapGeneration()</a>. Such a trap can be further configured to generate non maskable interrupt(NMI) using the API <a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest()</a>. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gafef433d566f700f9106db98439af3f88">XMC_SCU_PARITY_EnableTrapGeneration()</a>, <a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gafef433d566f700f9106db98439af3f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_PARITY_EnableTrapGeneration </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>The on-chip RAM type, for which the parity error trap generation has to be enabled.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga22ea4f1155833e07a1ec13cd2c4cb4e0">XMC_SCU_PARITY_t</a> to identify the on-chip RAM type. Multiple memory types can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables trap assertion for the parity error source.<br />
<br />
Parity error detection for different types of on-chip RAM can generate trap. Trap assertion for parity error can be individually enabled by setting the respective bits in the <em>PETE</em> register. The generated trap can be additionally configured to generate non maskable interrupt(NMI) using the API <a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest()</a>. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest()</a>, <a class="el" href="group___s_c_u.html#ga763ff133611bd2b42456fa9e8f3e34af">XMC_SCU_PARITY_DisableTrapGeneration()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gabfb74be3c54ea80b2fd25d20e143a299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_PARITY_GetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Status of parity error detection for the on-chip RAM modules.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga22ea4f1155833e07a1ec13cd2c4cb4e0">XMC_SCU_PARITY_t</a> to get the bit mask of each RAM module type.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of parity error detection for the on-chip RAM modules.<br />
<br />
Parity error status information is obtained from the <em>PEFLAG</em> register. If a particular RAM module has parity error, its respective bit field will be set to 1 in the returned value. A check for the status of a particular RAM module can be done by masking the returned value with the RAM module identifier from the type <a class="el" href="group___s_c_u.html#ga22ea4f1155833e07a1ec13cd2c4cb4e0">XMC_SCU_PARITY_t</a>. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga0c564412ab3d6a5d43c4fde9035cf07f">XMC_SCU_PARITY_ClearStatus()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gacf750b3451bbdd00820d54f25100bd75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_POWER_DisableUsb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the USB PHY and also OTG comparator if available.<br />
<br />
Configures the <em>USBPHYPDQ</em> bit of <em>PWRSET</em> register to move the USB PHY to power down state. If USB OTG is available in the device, the <em>USBOTGEN</em> bit of <em>PWRSET</em> register is set to 0. This disables the USB on the go comparators.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4d0a5061d139bb8e136316a2fcc98bab">XMC_SCU_POWER_EnableUsb()</a>, <a class="el" href="group___s_c_u.html#ga5332425bae1da209b9c6cc857f53d51e">XMC_SCU_CLOCK_SetUsbClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d0a5061d139bb8e136316a2fcc98bab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_POWER_EnableUsb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the USB PHY and also OTG comparator if available.<br />
<br />
Configures the <em>USBPHYPDQ</em> bit of <em>PWRSET</em> register to move the USB PHY from power down state. If USB OTG is available in the device, the <em>USBOTGEN</em> bit of <em>PWRSET</em> register is set to 1. This enables the USB on the go comparators.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gacf750b3451bbdd00820d54f25100bd75">XMC_SCU_POWER_DisableUsb()</a>, <a class="el" href="group___s_c_u.html#ga5332425bae1da209b9c6cc857f53d51e">XMC_SCU_CLOCK_SetUsbClockSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___s_c_u.html#ga83d6d8e1bb269b8cccb8e700bd4a842a">XMC_SCU_CLOCK_GetEthernetClockFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="ga315dd2a00d282eddb3056118c86e6da9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_ReadFromRetentionMemory </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Location in the retention memory to be read.<br />
 <b>Range:</b> 4 bit address space is provided for selecting 16 words of 32 bits. equivalent to 64 bytes of data. <em>address</em> value should be from 0 to 15.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t 32 bit data read from retention memory. The API reads one word(4 bytes) of data from the address specified.<br />
 <b>Range:</b> 32 bit data.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Reads data from selected address of retention memory in hibernate domain.<br />
<br />
The retention memory is located in hibernate domain. It is used for the purpose of store/restore of context information. Access to the retention memory space is served over shared serial interface. Retention memory content is retained even in hibernate mode. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gab835560fc4cd24d8f03043d39e52b5ac">XMC_SCU_WriteToRetentionMemory()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa7000d0aa26ac656926b108b49e0f73d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_ReadGPR </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The SCU general purpose register to be read.<br />
 <b>Range:</b> 0 and 1 corresponding to GPR0 and GPR1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Data read from the selected general purpose register.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides stored data from general purpose SCU register.<br />
<br />
SCU consists of 2 general purpose registers. These registers can be used for storing data. The API reads from either GPR0 or GPR1 based on the <em>index</em> value. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gad0681ca8911f106c0c9f6fd65db89e1c">XMC_SCU_WriteGPR()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gab00fa5e7e6ed73767de6f80b9a849543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_RESET_AssertPeripheralReset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga8a897b11f9bf2e3cba0a33b127ee972a">XMC_SCU_PERIPHERAL_RESET_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral to be reset.<br />
 <b>Range:</b> Type <a class="el" href="group___s_c_u.html#ga8a897b11f9bf2e3cba0a33b127ee972a">XMC_SCU_PERIPHERAL_RESET_t</a> enumerates all the peripherals that can be reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Puts the specified peripheral in to reset state. <br />
<br />
The API achieves reset of peripherals by setting the respective bit in the <em>PRSET0</em>, <em>PRSET1</em> or <em>PRSET2</em> register. Status of reset assertion automatically stored in the <em>PRSTATn</em> register and can be checked by user software to determine the state of the system and for debug purpose.<br />
It is recommended to use following steps to assert a peripheral reset:<br />
<ul>
<li>Call <em><a class="el" href="group___s_c_u.html#gab00fa5e7e6ed73767de6f80b9a849543">XMC_SCU_RESET_AssertPeripheralReset()</a></em> with desired peripheral identifier.<br />
</li>
<li>Call <em>XMC_SCU_RESET_IsPeripheralResetAsserted</em> with same peripheral identifier to verify whether peripheral is in reset state.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga09011e9b100f1a164c3b908cc9bdf77f">XMC_SCU_RESET_IsPeripheralResetAsserted()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___e_b_u.html#gad343d9d1ddcf7e500c48db84e7ec273b">XMC_EBU_Disable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4bf9396e8b46be98f73999575d13bf6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_RESET_ClearDeviceResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the reset reason bits in the reset status register. <br />
<br />
Clearing of the reset status information in the <em>SCU_RSTSTAT</em> register via register bit <em>RSTCLR.RSCLR</em> is strongly recommended to ensure a clear indication of the cause of next reset.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3f779c81bdc29b44c644017a52aff300">XMC_SCU_RESET_GetDeviceResetReason()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gac88ad38d3473b139dafef29dc3ba5216"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_RESET_DeassertPeripheralReset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga8a897b11f9bf2e3cba0a33b127ee972a">XMC_SCU_PERIPHERAL_RESET_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral to be moved out of reset state.<br />
 <b>Range:</b> Type <a class="el" href="group___s_c_u.html#ga8a897b11f9bf2e3cba0a33b127ee972a">XMC_SCU_PERIPHERAL_RESET_t</a> enumerates all the peripherals that can be reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the specified peripheral by moving it out of reset state. <br />
<br />
Any peripheral should be moved out of reset state for executing its functionality. The API enables the peripheral by setting its respective bit in the <em>PRCLR0</em>, <em>PRCLR1</em> or <em>PRCLR2</em> register. Status of reset deassertion is automatically stored in the <em>PRSTATn</em> register and can be checked by the user software to determine the state of the system and for debug purpose.<br />
It is recommended to use following steps to deassert a peripheral reset:<br />
<ul>
<li>Call <em><a class="el" href="group___s_c_u.html#gac88ad38d3473b139dafef29dc3ba5216">XMC_SCU_RESET_DeassertPeripheralReset()</a></em> with desired peripheral identifier.<br />
</li>
<li>Call <em><a class="el" href="group___s_c_u.html#ga09011e9b100f1a164c3b908cc9bdf77f">XMC_SCU_RESET_IsPeripheralResetAsserted()</a></em> with desired peripheral identifier to verify whether peripheral has been enabled.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gab00fa5e7e6ed73767de6f80b9a849543">XMC_SCU_RESET_AssertPeripheralReset()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___e_b_u.html#ga2b1e48f7a8cc69a661558594811c3c0e">XMC_EBU_Enable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f779c81bdc29b44c644017a52aff300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_RESET_GetDeviceResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Status representing the reason for device reset.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the value representing the reason for device reset.<br />
<br />
The return value is an encoded word, which can indicate multiple reasons for the last reset. Each bit position of the returned word is representative of a last reset cause. The returned value should be appropriately masked to check the cause of reset. The cause of the last reset gets automatically stored in the <em>SCU_RSTSTAT</em> register. The reset status shall be reset after each startup in order to ensure consistent source indication after the next reset. <b>Range:</b> The type <a class="el" href="group___s_c_u.html#gae01c08f5d524dadbc6e0c4128b348dc3">XMC_SCU_RESET_REASON_t</a> can be used to get the bit masks of the reset cause.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4bf9396e8b46be98f73999575d13bf6d">XMC_SCU_RESET_ClearDeviceResetReason()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga09011e9b100f1a164c3b908cc9bdf77f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_RESET_IsPeripheralResetAsserted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga8a897b11f9bf2e3cba0a33b127ee972a">XMC_SCU_PERIPHERAL_RESET_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral, whose reset status has to be checked.<br />
 <b>Range:</b> Type <a class="el" href="group___s_c_u.html#ga8a897b11f9bf2e3cba0a33b127ee972a">XMC_SCU_PERIPHERAL_RESET_t</a> enumerates all the peripherals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>bool Status of peripheral reset. <br />
 <b>Range:</b> <em>true</em> if peripheral is in reset state. <em>false</em> if peripheral is enabled and out of reset state.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks the reset status of the selected peripheral.<br />
<br />
The API reads the reset status from <em>PRSTATn</em> register. Returns true if the peripheral is in reset state. On power up of the device, all the peripherals will be in reset state. If the peripheral is enabled, <em>false</em> will be returned as the status. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gab00fa5e7e6ed73767de6f80b9a849543">XMC_SCU_RESET_AssertPeripheralReset()</a>, <a class="el" href="group___s_c_u.html#gac88ad38d3473b139dafef29dc3ba5216">XMC_SCU_RESET_DeassertPeripheralReset()</a> <br />
<br />
<br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ebb50291e4fc5722746f2f40fadb6a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetBootMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#gaee17d2349a9e695f89aaa67972035bb6">XMC_SCU_BOOTMODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Boot mode to be configured for the device.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gaee17d2349a9e695f89aaa67972035bb6">XMC_SCU_BOOTMODE_t</a> for selecting the boot mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the desired boot mode for the device.<br />
<br />
The XMC4 series devices support multiple boot modes. A running application can set a desired bootmode and launch it by means of software reset. Switching of boot modes should be handled carefully. User should ensure that the initial boot sequence is executed. A stable execution environment should be maintained when program control is eventually handed over to the application program.<br />
It is recommended to use following steps to launch requested bootmode:<br />
<ul>
<li>Call <em><a class="el" href="group___s_c_u.html#ga3ebb50291e4fc5722746f2f40fadb6a8">XMC_SCU_SetBootMode()</a></em> with desired boot mode value.<br />
</li>
<li>Trigger a software reset using system reset request by enabling a bit <em>SYSRESETREQ</em> of AIRCR register (PPB-&gt;AIRCR |= PPB_AIRCR_SYSRESETREQ_Msk).<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga2a6d9572718fe6822b42522947fe822b">XMC_SCU_GetBootMode()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gac10ca2cd72477476ffe38a4818bcae4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetCcuTriggerHigh </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>CCU slices to be triggered synchronously via software. The value is a bitmask of CCU slice bits in the register CCUCON. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a> for bitmask of individual CCU slices. Multiple slices can be combined using <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Generates active edge(low to high) trigger for multiple CCU units at the same time.<br />
<br />
Before executing this API, all the required CCU timers should configure external start. The edge of the start signal should be selected as active edge. The input signal for the CCU slice should be selected as SCU input. The above mentioned configurations can be made using the CCU LLD API <a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>. CCU timer slice should be started using <a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a> before triggering the timer using this API.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>, <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>, <a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga53300d587bbd03bc34c5a4396f5a34b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetCcuTriggerLow </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>CCU slices to be triggered synchronously via software. The value is a bitmask of CCU slice bits in the register CCUCON. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a> for bitmask of individual CCU slices. Multiple slices can be combined using <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Generates passive edge(high to low) trigger for multiple CCU units at the same time.<br />
<br />
Before executing this API, all the required CCU timers should configure external start. The edge of the start signal should be selected as passive edge. The input signal for the CCU slice should be selected as SCU input. The above mentioned configurations can be made using the CCU LLD API <a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>. CCU timer slice should be started using <a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a> before triggering the timer using this API.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>, <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>, <a class="el" href="group___s_c_u.html#gac10ca2cd72477476ffe38a4818bcae4b">XMC_SCU_SetCcuTriggerHigh()</a><br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init()</a>, <a class="el" href="group___s_c_u.html#gabd2e577339ff5af48261d18e0e41dc50">XMC_SCU_INTERRUPT_ClearEventStatus()</a>, <a class="el" href="group___s_c_u.html#gaa814678729d6b7f41c558e768ba8ecd4">XMC_SCU_INTERRUPT_DisableEvent()</a>, <a class="el" href="group___s_c_u.html#gab4cfb9545d1e561e1f24aeaa69af821c">XMC_SCU_INTERRUPT_EnableEvent()</a>, <a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent()</a> und <a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f600fa31f024ec9d8e0c17fc767772f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetRawTempLimits </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>lower_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>upper_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_temp</td><td>Lower threshold of die temperature. If measured temperature falls below this value, alarm bit will be set in <em>UNDERFL</em> bit field of <em>DTEMPALARM</em> register. </td></tr>
    <tr><td class="paramname">upper_temp</td><td>Upper threshold of die temperature. If measured temperature exceeds this value, alarm bit will be set in <em>OVERFL</em> bit field of <em>DTEMPALARM</em> register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the lower and upper threshold of die temperature.<br />
<br />
API configures <em>DTEMPLIM</em> register for upper and lower die temperature threshold limits. When the measured temperature is outside the range defined by the limits, alarm bits <em>UNDERFL</em> or <em>OVERFL</em> will be set in the register <em>DTEMPALARM</em>.<br />
It is recommended to use following steps:<br />
<ul>
<li>Call <em>XMC_SCU_StopTempMeasurement</em> to stop temperature measurement if it was started previously.<br />
</li>
<li>Call <em>XMC_SCU_SetRawTempLimits</em> with desired lower and upper temperature threshold limit values.<br />
</li>
<li>Call <em>XMC_SCU_StartTempMeasurement</em> to start temperature measurement.<br />
</li>
<li>Use <em><a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature()</a></em> and <a class="el" href="group___s_c_u.html#ga8573534003ebf11fbaa49e331238fb86">XMC_SCU_LowTemperature()</a> to monitor the temperature.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature()</a>, <a class="el" href="group___s_c_u.html#ga8573534003ebf11fbaa49e331238fb86">XMC_SCU_LowTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gabac9292e193c9804b5a6856de186737e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> XMC_SCU_StartTemperatureMeasurement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>XMC_SCU_STATUS_t Result of starting the temperature measurement.<br />
 <b>Range:</b> <br />
 XMC_SCU_STATUS_OK if the measurement is started successfully.<br />
 XMC_SCU_STATUS_ERROR if temperature sensor is not enabled.<br />
 XMC_SCU_STATUS_BUSY if temperature sensor is busy measuring the temperature.<br />
</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Starts die temperature measurement using internal temperature sensor.<br />
<br />
The API checks if the temperature sensor is enabled and is not busy in measurement.<br />
It is recommended to use following steps:<br />
<ul>
<li>Call <em>XMC_SCU_StopTempMeasurement</em> to stop temperature measurement if it was started previously.<br />
</li>
<li>Call <em>XMC_SCU_SetRawTempLimits</em> with desired lower and upper temperature threshold limit values if it is needed.<br />
</li>
<li>Call <em>XMC_SCU_StartTempMeasurement</em> to start temperature measurement.<br />
</li>
<li>Check whether Die Temperature Sensor (DTS) is busy in conversion by calling <em><a class="el" href="group___s_c_u.html#ga09f2786f94680cc125ead431f3c4d9c4">XMC_SCU_IsTemperatureSensorBusy()</a></em> and wait till conversion complete.<br />
</li>
<li>Read the die temperature value using <em>XMC_SCU_GetTemperatureMeasurement</em> API. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3f6a1e71b005175777c6dd9a069e325c">XMC_SCU_EnableTemperatureSensor()</a>, <a class="el" href="group___s_c_u.html#gacf86e99e8def2e37a0b484982e61256d">XMC_SCU_CalibrateTemperatureSensor()</a>, <a class="el" href="group___s_c_u.html#ga8ac62bd07097bb83cd294a1d6625af36">XMC_SCU_GetTemperatureMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6fef80ad14de7e792696cbd892b1ad26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_TRAP_ClearStatus </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">trap</td><td>The event for which, trap status bit has to be cleared.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga4de86b97726dc23fabd8c4e573b1bdb0">XMC_SCU_TRAP_t</a> to identify the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the trap status of input event.<br />
<br />
Once a trap event is detected, it will have to be acknowledged and later serviced. The trap status bit should be cleared to detect the occurence of trap next time. This is useful while polling for TRAPSTAT without enabling the NMI for trap. Trap status can be cleared by setting the event bit in the <em>TRAPCLR</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest()</a>, <a class="el" href="group___s_c_u.html#gada772bc64ad61ae19612224ae7f3855c">XMC_SCU_TRAP_GetStatus()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gacfb00024734804883905d6a423f69a39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_TRAP_Disable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">trap</td><td>The event for which, trap generation has to be disabled.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga4de86b97726dc23fabd8c4e573b1bdb0">XMC_SCU_TRAP_t</a> to identify the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables assertion of trap for the selected trap event.<br />
<br />
Trap assertion can be individually disabled by setting the respective event bit in the <em>TRAPDIS</em> register in order to suppress trap generation. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga51a3e55dedfde788f1ba5e3bad7fdb4e">XMC_SCU_TRAP_Enable()</a>, <a class="el" href="group___s_c_u.html#ga6fef80ad14de7e792696cbd892b1ad26">XMC_SCU_TRAP_ClearStatus()</a>, <a class="el" href="group___s_c_u.html#gada772bc64ad61ae19612224ae7f3855c">XMC_SCU_TRAP_GetStatus()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga51a3e55dedfde788f1ba5e3bad7fdb4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_TRAP_Enable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">trap</td><td>The event for which, trap generation has to be enabled.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga4de86b97726dc23fabd8c4e573b1bdb0">XMC_SCU_TRAP_t</a> to identify the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables assertion of trap for the selected trap event.<br />
<br />
Trap assertion can be individually enabled by clearing respective bit of the event in <em>TRAPDIS</em> register in order to get an exception. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gacfb00024734804883905d6a423f69a39">XMC_SCU_TRAP_Disable()</a>, <a class="el" href="group___s_c_u.html#ga6fef80ad14de7e792696cbd892b1ad26">XMC_SCU_TRAP_ClearStatus()</a>, <a class="el" href="group___s_c_u.html#gada772bc64ad61ae19612224ae7f3855c">XMC_SCU_TRAP_GetStatus()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gada772bc64ad61ae19612224ae7f3855c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_TRAP_GetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Status of trap generating events.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga4de86b97726dc23fabd8c4e573b1bdb0">XMC_SCU_TRAP_t</a> to identify the event. The returned value indicates the status of multiple events at their respective bit positions. User should mask the bits of the events of interest using the type specified.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of trap generating events. <br />
<br />
The status is read from <em>TRAPRAW</em> register. Status of the specific events can be checked using their respective bits in the <em>TRAPRAW</em> register. The bit masks can be obtained from the enumeration type <a class="el" href="group___s_c_u.html#ga4de86b97726dc23fabd8c4e573b1bdb0">XMC_SCU_TRAP_t</a>. Multiple events can be combined using <em>OR</em> operation. A trap event is considered to be asserted if the respective bit of the event is set to 1. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest()</a>, <a class="el" href="group___s_c_u.html#ga6fef80ad14de7e792696cbd892b1ad26">XMC_SCU_TRAP_ClearStatus()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga706f23b13aabcbcd5ad3ece9cf77a58f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_TRAP_Trigger </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">trap</td><td>The event for which, trap has to be triggered.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga4de86b97726dc23fabd8c4e573b1bdb0">XMC_SCU_TRAP_t</a> to identify the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Triggers trap generation for the event specified. <br />
<br />
The trap source has to be enabled before invocation of this API. Trap event can be triggered by setting its respective bit in the <em>TRAPSET</em> register. Trap event can be configured to generate a non maskable interrupt by using the API <a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest()</a>.<br />
It is recommended to use following steps to manually assert a trap event:<br />
<ul>
<li>Call <em>XMC_SCU_TRAP_EnableEvent</em> with desired trap request source ID.<br />
</li>
<li>Call <em>XMC_SCU_TRAP_SetEvent</em> with same trap request source ID to manually assert a trap event.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga9595d70f3cb1cd35b236afdd058c5895">XMC_SCU_INTERRUPT_EnableNmiRequest()</a>, <a class="el" href="group___s_c_u.html#gada772bc64ad61ae19612224ae7f3855c">XMC_SCU_TRAP_GetStatus()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gad0681ca8911f106c0c9f6fd65db89e1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_WriteGPR </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The SCU general purpose register to be written.<br />
 <b>Range:</b> 0 and 1 corresponding to GPR0 and GPR1. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be written to the selected general purpose register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Stores data in the selected general purpose SCU register.<br />
<br />
SCU consists of 2 general purpose registers. These registers can be used for storing data. The API writes data to either GPR0 or GPR1 based on the <em>index</em> value. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaa7000d0aa26ac656926b108b49e0f73d">XMC_SCU_ReadGPR()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gab835560fc4cd24d8f03043d39e52b5ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_WriteToRetentionMemory </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Location in the retention memory to be written.<br />
 <b>Range:</b> 4 bit address space is provided for selecting 16 words of 32 bits. equivalent to 64 bytes of data. <em>address</em> value should be from 0 to 15. </td></tr>
    <tr><td class="paramname">data</td><td>32 bit data to be written into retention memory. The API writes one word(4 bytes) of data to the address specified.<br />
 <b>Range:</b> 32 bit data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Writes input data to the selected address of Retention memory in hibernate domain.<br />
<br />
The retention memory is located in hibernate domain. It is used for the purpose of store/restore of context information. Access to the retention memory space is served over shared serial interface. Retention memory content is retained even in hibernate mode. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga315dd2a00d282eddb3056118c86e6da9">XMC_SCU_ReadFromRetentionMemory()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Erzeugt am Mit Jun 22 2016 11:37:00 für XMC Peripheral Library for XMC4000 Family von &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
