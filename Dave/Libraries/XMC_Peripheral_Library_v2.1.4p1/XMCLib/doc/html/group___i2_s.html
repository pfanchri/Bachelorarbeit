<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>XMC Peripheral Library for XMC4000 Family: I2S</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family
   &#160;<span id="projectnumber">2.1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Hauptseite</span></a></li>
      <li><a href="pages.html"><span>Zus√§tzliche&#160;Informationen</span></a></li>
      <li class="current"><a href="modules.html"><span>Module</span></a></li>
      <li><a href="files.html"><span>Dateien</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Datenstrukturen</a> &#124;
<a href="#define-members">Makrodefinitionen</a> &#124;
<a href="#func-members">Funktionen</a>  </div>
  <div class="headertitle">
<div class="title">I2S<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Datenstrukturen</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___i2_s___c_h___c_o_n_f_i_g__t.html">XMC_I2S_CH_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Makrodefinitionen</h2></td></tr>
<tr class="memitem:gaca9db6d0386bd723e662653ce19620b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a></td></tr>
<tr class="separator:gaca9db6d0386bd723e662653ce19620b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7222d2a24ef59d2ab98f270c6d634d22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a></td></tr>
<tr class="separator:ga7222d2a24ef59d2ab98f270c6d634d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e6fc510d71d8e8cd1fb249dd574749"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a></td></tr>
<tr class="separator:ga66e6fc510d71d8e8cd1fb249dd574749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a744cb1b509dffe39efccde9de1fe8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a></td></tr>
<tr class="separator:ga39a744cb1b509dffe39efccde9de1fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2052bed13ae87be6b83ee0e2d3697118"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a></td></tr>
<tr class="separator:ga2052bed13ae87be6b83ee0e2d3697118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dbf4e63749d2f645a8160712666e618"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a></td></tr>
<tr class="separator:ga1dbf4e63749d2f645a8160712666e618"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funktionen</h2></td></tr>
<tr class="memitem:gaab7c4e8e4aa32520307fd34c387a9ee1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gaab7c4e8e4aa32520307fd34c387a9ee1">XMC_I2S_CH_ClearStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t flag)</td></tr>
<tr class="separator:gaab7c4e8e4aa32520307fd34c387a9ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga791fd46fa82e2c4a87eca3ff2e543813"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga791fd46fa82e2c4a87eca3ff2e543813">XMC_I2S_CH_ConfigureShiftClockOutput</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#ga6cf990895c6ccc01ceaf11c028ad35cc">XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a> clock_output)</td></tr>
<tr class="separator:ga791fd46fa82e2c4a87eca3ff2e543813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac731fe4fbd6e50a8e0b0a8819d30ed56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gac731fe4fbd6e50a8e0b0a8819d30ed56">XMC_I2S_CH_DisableDelayCompensation</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gac731fe4fbd6e50a8e0b0a8819d30ed56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624bd3292e9b6ea3bb41689d41fadb27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga624bd3292e9b6ea3bb41689d41fadb27">XMC_I2S_CH_DisableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga624bd3292e9b6ea3bb41689d41fadb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad442af0346273424ef742ccd3abe40dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gad442af0346273424ef742ccd3abe40dd">XMC_I2S_CH_DisableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gad442af0346273424ef742ccd3abe40dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca8077849ed95bc45949481d3110659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gafca8077849ed95bc45949481d3110659">XMC_I2S_CH_DisableMasterClock</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gafca8077849ed95bc45949481d3110659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6484a12dcff80b2055d1b986e8cba28d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga6484a12dcff80b2055d1b986e8cba28d">XMC_I2S_CH_EnableDelayCompensation</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga6484a12dcff80b2055d1b986e8cba28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd5f7a8841af9489527611acdfa1bd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga3dd5f7a8841af9489527611acdfa1bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfdd666f14a7897c24a7e79660179b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga3cfdd666f14a7897c24a7e79660179b5">XMC_I2S_CH_EnableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga3cfdd666f14a7897c24a7e79660179b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99608c0251e3b153d1f71b49350d5c0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga99608c0251e3b153d1f71b49350d5c0c">XMC_I2S_CH_EnableMasterClock</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga99608c0251e3b153d1f71b49350d5c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4302cec4acffcd49bc2178b1b98afcb4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga4302cec4acffcd49bc2178b1b98afcb4">XMC_I2S_CH_GetReceivedData</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga4302cec4acffcd49bc2178b1b98afcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ea6d90429a2ac4de4bbe1db35a7087c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga8ea6d90429a2ac4de4bbe1db35a7087c">XMC_I2S_CH_GetStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga8ea6d90429a2ac4de4bbe1db35a7087c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7bd3c147219fce76f9c1c61b21898a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a> channel_number)</td></tr>
<tr class="separator:ga1c7bd3c147219fce76f9c1c61b21898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9b940110725dee4580f570f54028ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gafd9b940110725dee4580f570f54028ab">XMC_I2S_CH_SelectInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#gaa876770c9147fa5b0ca79b5bbd755ce9">XMC_I2S_CH_INTERRUPT_NODE_POINTER_t</a> interrupt_node, const uint32_t service_request)</td></tr>
<tr class="separator:gafd9b940110725dee4580f570f54028ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2473a1c092b6cbb61c9996086c2ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gaff2473a1c092b6cbb61c9996086c2ea9">XMC_I2S_CH_SetBaudrate</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t rate)</td></tr>
<tr class="separator:gaff2473a1c092b6cbb61c9996086c2ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga365e507fce74d7a9d1f02a00b8db9223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga365e507fce74d7a9d1f02a00b8db9223">XMC_I2S_CH_SetBitOrderLsbFirst</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga365e507fce74d7a9d1f02a00b8db9223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a3c6090697d5df5038b3c1b5ed1c13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga33a3c6090697d5df5038b3c1b5ed1c13">XMC_I2S_CH_SetBitOrderMsbFirst</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga33a3c6090697d5df5038b3c1b5ed1c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf411f00a4585150d33d3259dfc785ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gacf411f00a4585150d33d3259dfc785ca">XMC_I2S_CH_SetFrameLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t frame_length)</td></tr>
<tr class="separator:gacf411f00a4585150d33d3259dfc785ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32572b75a2b528238622cfa91da6239f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga32572b75a2b528238622cfa91da6239f">XMC_I2S_CH_SetInputSource</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> input, const uint8_t source)</td></tr>
<tr class="separator:ga32572b75a2b528238622cfa91da6239f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af8cb0639aeede0ab9faead5fa7f55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga8af8cb0639aeede0ab9faead5fa7f55c">XMC_I2S_CH_SetInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t service_request)</td></tr>
<tr class="separator:ga8af8cb0639aeede0ab9faead5fa7f55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2198a50935a491a48686d85b53f0bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gabb2198a50935a491a48686d85b53f0bf">XMC_I2S_CH_SetSystemWordLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t sclk_cycles_system_word_length)</td></tr>
<tr class="separator:gabb2198a50935a491a48686d85b53f0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55da8db55309c3afb4d9c6f238aeb240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga55da8db55309c3afb4d9c6f238aeb240">XMC_I2S_CH_SetWordLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t word_length)</td></tr>
<tr class="separator:ga55da8db55309c3afb4d9c6f238aeb240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga398df3f0a83ceee1c0b2891c6f551da5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga398df3f0a83ceee1c0b2891c6f551da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fab03647f2593b60365e39463fe5cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga1fab03647f2593b60365e39463fe5cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga961ec248ea914b53a1e7595f4a0e8d01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga961ec248ea914b53a1e7595f4a0e8d01">XMC_I2S_CH_Transmit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t data, const <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a> channel_number)</td></tr>
<tr class="separator:ga961ec248ea914b53a1e7595f4a0e8d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4332db9df7ffbb91a633d94a05897ac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga4332db9df7ffbb91a633d94a05897ac4">XMC_I2S_CH_TriggerServiceRequest</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t service_request_line)</td></tr>
<tr class="separator:ga4332db9df7ffbb91a633d94a05897ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356145e003922d6ef50f7aab6a14afe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga356145e003922d6ef50f7aab6a14afe9">XMC_I2S_CH_WordAddressSignalPolarity</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#gaf06d8ef70b2f776bd0e3f4a4860b6dd4">XMC_I2S_CH_WA_POLARITY_t</a> wa_inversion)</td></tr>
<tr class="separator:ga356145e003922d6ef50f7aab6a14afe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Ausf√ºhrliche Beschreibung</h2>
<p>USIC IIS Features: <br />
 </p>
<h2 class="groupheader">Makro-Dokumentation</h2>
<a class="anchor" id="gaca9db6d0386bd723e662653ce19620b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S0_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 0 base address </p>

</div>
</div>
<a class="anchor" id="ga7222d2a24ef59d2ab98f270c6d634d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S0_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 1 base address </p>

</div>
</div>
<a class="anchor" id="ga66e6fc510d71d8e8cd1fb249dd574749"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S1_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 0 base address </p>

</div>
</div>
<a class="anchor" id="ga39a744cb1b509dffe39efccde9de1fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S1_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 1 base address </p>

</div>
</div>
<a class="anchor" id="ga2052bed13ae87be6b83ee0e2d3697118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S2_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 0 base address </p>

</div>
</div>
<a class="anchor" id="ga1dbf4e63749d2f645a8160712666e618"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S2_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 1 base address </p>

</div>
</div>
<h2 class="groupheader">Dokumentation der Aufz√§hlungstypen</h2>
<a class="anchor" id="ga6cf990895c6ccc01ceaf11c028ad35cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#ga6cf990895c6ccc01ceaf11c028ad35cc">XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S Baudrate Generator shift clock output. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufz√§hlungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6cf990895c6ccc01ceaf11c028ad35ccacd7860ed986e8121655856927aa72deb"></a>XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK&#160;</td><td class="fielddoc">
<p>Baudrate Generator shift clock output: SCLK </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6cf990895c6ccc01ceaf11c028ad35cca7a8efe245ea1426c808d9d07b8cb392d"></a>XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_DX1&#160;</td><td class="fielddoc">
<p>Clock obtained as input from master: DX1 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga21a01621957ee4befb0742623b7deaf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#ga21a01621957ee4befb0742623b7deaf8">XMC_I2S_CH_BUS_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the I2S bus mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufz√§hlungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga21a01621957ee4befb0742623b7deaf8ac94943f0fe50ea5db0ba76b0e7164ac9"></a>XMC_I2S_CH_BUS_MODE_MASTER&#160;</td><td class="fielddoc">
<p>I2S Master </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga21a01621957ee4befb0742623b7deaf8a482da8c823c483b895a4c1d35b969372"></a>XMC_I2S_CH_BUS_MODE_SLAVE&#160;</td><td class="fielddoc">
<p>I2S Slave </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga8e7a5c82ca942de7450cfba67907aa22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the Polarity of the WA in the SELO output lines in relation to the internal WA signal. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufz√§hlungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga8e7a5c82ca942de7450cfba67907aa22a9884bce0586ebf037f9fad4c576b6af9"></a>XMC_I2S_CH_CHANNEL_1_LEFT&#160;</td><td class="fielddoc">
<p>Channel 1 (left) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8e7a5c82ca942de7450cfba67907aa22a8aa09ec1ebaa2f86cd923b3c5a22967c"></a>XMC_I2S_CH_CHANNEL_2_RIGHT&#160;</td><td class="fielddoc">
<p>Channel 2 (right) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga0519dc913371e5e1b2fb93602e8af7eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#ga0519dc913371e5e1b2fb93602e8af7eb">XMC_I2S_CH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S events. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufz√§hlungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7eba6f555796d0e490cdb8bb21ca6668e9bf"></a>XMC_I2S_CH_EVENT_RECEIVE_START&#160;</td><td class="fielddoc">
<p>Receive start event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7eba2ec499d4478e0288bc8f36fa122760ff"></a>XMC_I2S_CH_EVENT_DATA_LOST&#160;</td><td class="fielddoc">
<p>Data lost event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7eba1c415b086e85445c3b20f60befc35e64"></a>XMC_I2S_CH_EVENT_TRANSMIT_SHIFT&#160;</td><td class="fielddoc">
<p>Transmit shift event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7ebae050d22d0c6670c83a7b3938445f3ca4"></a>XMC_I2S_CH_EVENT_TRANSMIT_BUFFER&#160;</td><td class="fielddoc">
<p>Transmit buffer event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7eba103fe11c9572f6b4f5416a7203cae51f"></a>XMC_I2S_CH_EVENT_STANDARD_RECEIVE&#160;</td><td class="fielddoc">
<p>Receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7eba451277b6303c2d2fe97f3160d73811c6"></a>XMC_I2S_CH_EVENT_ALTERNATIVE_RECEIVE&#160;</td><td class="fielddoc">
<p>Alternate receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7eba5f773a997f74338bff7f899bf84e31da"></a>XMC_I2S_CH_EVENT_BAUD_RATE_GENERATOR&#160;</td><td class="fielddoc">
<p>Baudrate generator event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7eba6f2c0491e36b530b7f0f372c0e0562c1"></a>XMC_I2S_CH_EVENT_WA_FALLING_EDGE&#160;</td><td class="fielddoc">
<p>WA falling edge event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7eba22b218a082c9d70ce83289158ff66501"></a>XMC_I2S_CH_EVENT_WA_RISING_EDGE&#160;</td><td class="fielddoc">
<p>WA rising edge event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7eba7cc0ddea3695a17c27747b418e7b16a1"></a>XMC_I2S_CH_EVENT_WA_GENERATION_END&#160;</td><td class="fielddoc">
<p>END event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0519dc913371e5e1b2fb93602e8af7ebaeec8987e03c66150a84fc0ca021330d1"></a>XMC_I2S_CH_EVENT_DX2TIEN_ACTIVATED&#160;</td><td class="fielddoc">
<p>WA input signal transition event </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf92c3536e625729aefc26a87ca915fa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S input stage selection. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufz√§hlungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf92c3536e625729aefc26a87ca915fa1a1f1c8603d2a16dd28d10fc20e07e0f23"></a>XMC_I2S_CH_INPUT_DIN0&#160;</td><td class="fielddoc">
<p>Data input stage 0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf92c3536e625729aefc26a87ca915fa1aa489eba5dd199e2763f913d9cd182ad0"></a>XMC_I2S_CH_INPUT_SLAVE_SCLKIN&#160;</td><td class="fielddoc">
<p>Clock input stage </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf92c3536e625729aefc26a87ca915fa1aa2078ff62f39e669f5d7359edc2daa10"></a>XMC_I2S_CH_INPUT_SLAVE_WA&#160;</td><td class="fielddoc">
<p>WA input stage </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf92c3536e625729aefc26a87ca915fa1a5185333fb09982c55cb169c274486b63"></a>XMC_I2S_CH_INPUT_DIN1&#160;</td><td class="fielddoc">
<p>Data input stage 1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf92c3536e625729aefc26a87ca915fa1a42fbab05215695e05b455624d9b18823"></a>XMC_I2S_CH_INPUT_DIN2&#160;</td><td class="fielddoc">
<p>Data input stage 2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf92c3536e625729aefc26a87ca915fa1a2f5da0034674287460fcd83cf7512660"></a>XMC_I2S_CH_INPUT_DIN3&#160;</td><td class="fielddoc">
<p>Data input stage 3 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaa876770c9147fa5b0ca79b5bbd755ce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#gaa876770c9147fa5b0ca79b5bbd755ce9">XMC_I2S_CH_INTERRUPT_NODE_POINTER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S channel interrupt node pointers. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufz√§hlungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaa876770c9147fa5b0ca79b5bbd755ce9ac00bde3addfb72171f5bd0607fc0426c"></a>XMC_I2S_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT&#160;</td><td class="fielddoc">
<p>Node pointer for transmit shift interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa876770c9147fa5b0ca79b5bbd755ce9a57e6d7b8a3d66799258e3ded542a872c"></a>XMC_I2S_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER&#160;</td><td class="fielddoc">
<p>Node pointer for transmit buffer interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa876770c9147fa5b0ca79b5bbd755ce9a5675f33e9565e0b87dc10342e3b541ac"></a>XMC_I2S_CH_INTERRUPT_NODE_POINTER_RECEIVE&#160;</td><td class="fielddoc">
<p>Node pointer for receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa876770c9147fa5b0ca79b5bbd755ce9a9a3f8e7dcd7d67904c74d12b399921f1"></a>XMC_I2S_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE&#160;</td><td class="fielddoc">
<p>Node pointer for alternate receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa876770c9147fa5b0ca79b5bbd755ce9ac8250779e4d8ccf20d17d66421c46660"></a>XMC_I2S_CH_INTERRUPT_NODE_POINTER_PROTOCOL&#160;</td><td class="fielddoc">
<p>Node pointer for protocol related interrupts </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga86eb677be3865bdf0545767e8818d7ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#ga86eb677be3865bdf0545767e8818d7ea">XMC_I2S_CH_STATUS_FLAG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S status flag. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufz√§hlungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaa47a2558d7b0bde69cded893a1fe0078e"></a>XMC_I2S_CH_STATUS_FLAG_WORD_ADDRESS&#160;</td><td class="fielddoc">
<p>Word Address status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaa202a435971e4df1ebd791b861d727758"></a>XMC_I2S_CH_STATUS_FLAG_DX2S&#160;</td><td class="fielddoc">
<p>Status of WA input(DX2) signal </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaab1530782132d2cf834660a322df93135"></a>XMC_I2S_CH_STATUS_FLAG_DX2T_EVENT_DETECTED&#160;</td><td class="fielddoc">
<p>Status for WA input signal transition </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaa1441fa1c8f4a37644132dc5933293ec7"></a>XMC_I2S_CH_STATUS_FLAG_WA_FALLING_EDGE_EVENT&#160;</td><td class="fielddoc">
<p>Falling edge of the WA output signal has been generated </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaa6a427d736c2dc6e7ab6c29818284c21f"></a>XMC_I2S_CH_STATUS_FLAG_WA_RISING_EDGE_EVENT&#160;</td><td class="fielddoc">
<p>Rising edge of the WA output signal has been generated </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaaf54ccb4a544ffa1218f043e1cbbda580"></a>XMC_I2S_CH_STATUS_FLAG_WA_GENERATION_END&#160;</td><td class="fielddoc">
<p>The WA generation has ended </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaa3afcb8e827cc2c2feed7d6cca2f6ed0f"></a>XMC_I2S_CH_STATUS_FLAG_RECEIVER_START_INDICATION&#160;</td><td class="fielddoc">
<p>Receive start indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaa2c33679c1d063d0705c837accd1eb368"></a>XMC_I2S_CH_STATUS_FLAG_DATA_LOST_INDICATION&#160;</td><td class="fielddoc">
<p>Data lost indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaad1d427bdbccec03368967c462e2c5a07"></a>XMC_I2S_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION&#160;</td><td class="fielddoc">
<p>Transmit shift indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaa681237dd41b82191e802ae34223f4d6d"></a>XMC_I2S_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION&#160;</td><td class="fielddoc">
<p>Transmit buffer indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaace4b8f986d8321f8c6d3596c63a29640"></a>XMC_I2S_CH_STATUS_FLAG_RECEIVE_INDICATION&#160;</td><td class="fielddoc">
<p>Receive indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaaf4bb61d7a7b20500af6662cc7a1f8053"></a>XMC_I2S_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION&#160;</td><td class="fielddoc">
<p>Alternate receive indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga86eb677be3865bdf0545767e8818d7eaa5892fcb5ffa53ea6361d0ad145be183e"></a>XMC_I2S_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION&#160;</td><td class="fielddoc">
<p>Baud rate generator indication status </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gad79d76187d3de45ba4d8ec7f17989a20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S Status. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufz√§hlungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggad79d76187d3de45ba4d8ec7f17989a20aefa3783742bd11437e465de7cf19b9d0"></a>XMC_I2S_CH_STATUS_OK&#160;</td><td class="fielddoc">
<p>Status OK </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad79d76187d3de45ba4d8ec7f17989a20a274f43657b1d0d60d6a4a3979025f6f0"></a>XMC_I2S_CH_STATUS_ERROR&#160;</td><td class="fielddoc">
<p>Status ERROR </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad79d76187d3de45ba4d8ec7f17989a20ad630d122134df50be10aaa7aeb01cf80"></a>XMC_I2S_CH_STATUS_BUSY&#160;</td><td class="fielddoc">
<p>Status BUSY </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf06d8ef70b2f776bd0e3f4a4860b6dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#gaf06d8ef70b2f776bd0e3f4a4860b6dd4">XMC_I2S_CH_WA_POLARITY_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the Polarity of the WA in the SELO output lines in relation to the internal WA signal. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufz√§hlungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf06d8ef70b2f776bd0e3f4a4860b6dd4aad9792a6807914460708783fca529b97"></a>XMC_I2S_CH_WA_POLARITY_DIRECT&#160;</td><td class="fielddoc">
<p>The SELO outputs have the same polarity as the WA signal (active high) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf06d8ef70b2f776bd0e3f4a4860b6dd4aee02f33af07c1e12c1feea0b77d4c1eb"></a>XMC_I2S_CH_WA_POLARITY_INVERTED&#160;</td><td class="fielddoc">
<p>The SELO outputs have the inverted polarity to the WA signal (active low) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Dokumentation der Funktionen</h2>
<a class="anchor" id="gaab7c4e8e4aa32520307fd34c387a9ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_ClearStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">flag</td><td>Protocol event status to be cleared for detection of next occurence. Refer @ XMC_I2S_CH_STATUS_FLAG_t for valid values. <b>OR</b> combinations of these enum item can be used as input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the events specified, by setting PSCR register.<br />
<br />
During communication the events occurred have to be cleared to detect their next occurence.<br />
e.g: During transmission Transmit buffer event occurs to indicating data word transfer has started. This event has to be cleared after transmission of each data word. Otherwise next event cannot be recognized.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga8ea6d90429a2ac4de4bbe1db35a7087c">XMC_I2S_CH_GetStatusFlag()</a> </dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a725284f672801993f9ab5dcf3ef1e5c7">XMC_USIC_CH_t::PSCR</a>.</p>

</div>
</div>
<a class="anchor" id="ga791fd46fa82e2c4a87eca3ff2e543813"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_ConfigureShiftClockOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#ga6cf990895c6ccc01ceaf11c028ad35cc">XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a>&#160;</td>
          <td class="paramname"><em>clock_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">clock_output</td><td>shift clock source.<br />
 Refer <a class="el" href="group___i2_s.html#ga6cf990895c6ccc01ceaf11c028ad35cc">XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a> for valid inputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the shift clock source by setting BRG.SCLKOSEL.<br />
<br />
In Master mode operation, shift clock is generated by the internal baud rate generator. This SCLK is made available for external slave devices by SCLKOUT signal.<br />
In Slave mode, the signal is received from the external master. So the DX1(input) stage has to be connected to input.<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#gaba9a2e95af4e455dddd73f324577c876">XMC_USIC_CH_ConfigureShiftClockOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="gac731fe4fbd6e50a8e0b0a8819d30ed56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_DisableDelayCompensation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, <a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>,<a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>,<a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>,<a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>,<a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Zu beachten</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables delay compensation.. <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga6484a12dcff80b2055d1b986e8cba28d">XMC_I2S_CH_EnableDelayCompensation()</a><br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#ga9896966f6e2e6109f8a7ca0de03d0b39">XMC_USIC_CH_DisableDelayCompensation()</a>.</p>

</div>
</div>
<a class="anchor" id="ga624bd3292e9b6ea3bb41689d41fadb27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">event</td><td>Protocol events which have to be disabled. Refer @ XMC_I2S_CH_EVENT_t for valid values. <b>OR</b> combinations of these enum item can be used as input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the I2S protocol specific events, by configuring PCR register.<br />
<br />
After disabling the events, <a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent()</a> has to be invoked to re-enable the events.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent()</a> </dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga33a3c6090697d5df5038b3c1b5ed1c13">XMC_I2S_CH_SetBitOrderMsbFirst()</a>.</p>

</div>
</div>
<a class="anchor" id="gad442af0346273424ef742ccd3abe40dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_DisableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">input</td><td>I2S channel input stage.<br />
 Refer <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> for valid inputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the polarity inversion of input data signal, by clearing DXyCR.DPOL(where y = <em>input</em>).<br />
<br />
Resets the input data polarity. Invoke <a class="el" href="group___i2_s.html#ga3cfdd666f14a7897c24a7e79660179b5">XMC_I2S_CH_EnableInputInversion()</a> to apply inversion.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga3cfdd666f14a7897c24a7e79660179b5">XMC_I2S_CH_EnableInputInversion()</a> </dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#gaa018c766c173f43dbdba8c821a90a645">XMC_USIC_CH_DisableInputInversion()</a>.</p>

</div>
</div>
<a class="anchor" id="gafca8077849ed95bc45949481d3110659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_DisableMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the generation of Master clock by clearing PCR.MCLK bit.<br />
<br />
This clock can be enabled by invoking <a class="el" href="group___i2_s.html#ga99608c0251e3b153d1f71b49350d5c0c">XMC_I2S_CH_EnableMasterClock()</a> as needed in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga99608c0251e3b153d1f71b49350d5c0c">XMC_I2S_CH_EnableMasterClock()</a> </dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#aeec549c9dd9bd6e62a584995958fc91d">XMC_USIC_CH_t::PCR_IISMode</a>.</p>

</div>
</div>
<a class="anchor" id="ga6484a12dcff80b2055d1b986e8cba28d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_EnableDelayCompensation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, <a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>,<a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>,<a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>,<a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>,<a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Zu beachten</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables delay compensation. <br />
<br />
 Delay compensation can be applied to the receive path. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gac731fe4fbd6e50a8e0b0a8819d30ed56">XMC_I2S_CH_DisableDelayCompensation()</a><br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#ga1eaad0f90219fa9bb43bfdf932ea2451">XMC_USIC_CH_EnableDelayCompensation()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3dd5f7a8841af9489527611acdfa1bd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">event</td><td>Protocol events which have to be enabled. Refer @ XMC_I2S_CH_EVENT_t for valid values. <b>OR</b> combinations of these enum items can be used as input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the I2S protocol specific events, by configuring PCR register.<br />
<br />
Events can be enabled as needed using <a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent()</a>. <a class="el" href="group___i2_s.html#ga624bd3292e9b6ea3bb41689d41fadb27">XMC_I2S_CH_DisableEvent()</a> can be used to disable the events.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga624bd3292e9b6ea3bb41689d41fadb27">XMC_I2S_CH_DisableEvent()</a> </dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga33a3c6090697d5df5038b3c1b5ed1c13">XMC_I2S_CH_SetBitOrderMsbFirst()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3cfdd666f14a7897c24a7e79660179b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_EnableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">input</td><td>I2S channel input stage.<br />
 Refer <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> for valid inputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the polarity inversion of input data signal, by setting DXyCR.DPOL(where y = <em>input</em>).<br />
<br />
This is not set in XMC_I2S_CH_Init(). Invoke <a class="el" href="group___i2_s.html#ga3cfdd666f14a7897c24a7e79660179b5">XMC_I2S_CH_EnableInputInversion()</a> as needed later in the program. To disable the inversion <a class="el" href="group___i2_s.html#gad442af0346273424ef742ccd3abe40dd">XMC_I2S_CH_DisableInputInversion()</a> can be invoked.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gad442af0346273424ef742ccd3abe40dd">XMC_I2S_CH_DisableInputInversion()</a> </dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#gae13b2003ea4d8703a9990d1e90048dc3">XMC_USIC_CH_EnableInputInversion()</a>.</p>

</div>
</div>
<a class="anchor" id="ga99608c0251e3b153d1f71b49350d5c0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_EnableMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the generation of Master clock by setting PCR.MCLK bit.<br />
<br />
This clock can be used as a clock reference for external devices. This is not enabled during initialization in XMC_I2S_CH_Init(). Invoke <a class="el" href="group___i2_s.html#ga99608c0251e3b153d1f71b49350d5c0c">XMC_I2S_CH_EnableMasterClock()</a> to enable as needed in the program, or if it is disabled by <a class="el" href="group___i2_s.html#gafca8077849ed95bc45949481d3110659">XMC_I2S_CH_DisableMasterClock()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gafca8077849ed95bc45949481d3110659">XMC_I2S_CH_DisableMasterClock()</a> </dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#aeec549c9dd9bd6e62a584995958fc91d">XMC_USIC_CH_t::PCR_IISMode</a>.</p>

</div>
</div>
<a class="anchor" id="ga4302cec4acffcd49bc2178b1b98afcb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_I2S_CH_GetReceivedData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>uint16_t Data read from the receive buffer.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Reads data from the receive buffer based on the FIFO selection.<br />
<br />
Invocation of <a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive()</a> receives the data and place it into receive buffer. After receiving the data <a class="el" href="group___i2_s.html#ga4302cec4acffcd49bc2178b1b98afcb4">XMC_I2S_CH_GetReceivedData()</a> can be used to read the data from the buffer.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive()</a> </dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ea6d90429a2ac4de4bbe1db35a7087c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_I2S_CH_GetStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>uint32_t Status of I2S protocol events.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the status of the events, by reading PSR register.<br />
<br />
This indicates the status of the all the events, for I2S communication.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gaab7c4e8e4aa32520307fd34c387a9ee1">XMC_I2S_CH_ClearStatusFlag()</a> </dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a8d6fa949b230c88cc89bfe47a9917bc7">XMC_USIC_CH_t::PSR_IISMode</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c7bd3c147219fce76f9c1c61b21898a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_Receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a>&#160;</td>
          <td class="paramname"><em>channel_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">channel_number</td><td>Communication output channel of the I2S, based on this mode TCI(Transmit control information)is updated.<br />
 Refer <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a> for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Transmits a dummy data(FFFFH) to provide clock for slave and receives the data from the slave.<br />
<br />
<a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive()</a> receives the data and places it into buffer based on the FIFO selection. After reception of data <a class="el" href="group___i2_s.html#ga4302cec4acffcd49bc2178b1b98afcb4">XMC_I2S_CH_GetReceivedData()</a> can be invoked to read the data from the buffers.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga4302cec4acffcd49bc2178b1b98afcb4">XMC_I2S_CH_GetReceivedData()</a> </dd></dl>

<p>Benutzt <a class="el" href="group___i2_s.html#ga4302cec4acffcd49bc2178b1b98afcb4">XMC_I2S_CH_GetReceivedData()</a> und <a class="el" href="group___i2_s.html#ga961ec248ea914b53a1e7595f4a0e8d01">XMC_I2S_CH_Transmit()</a>.</p>

</div>
</div>
<a class="anchor" id="gafd9b940110725dee4580f570f54028ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SelectInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#gaa876770c9147fa5b0ca79b5bbd755ce9">XMC_I2S_CH_INTERRUPT_NODE_POINTER_t</a>&#160;</td>
          <td class="paramname"><em>interrupt_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, <a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>,<a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>,<a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>,<a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>,<a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Zu beachten</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt_node</td><td>Interrupt node pointer to be configured. <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#ggaa876770c9147fa5b0ca79b5bbd755ce9ac00bde3addfb72171f5bd0607fc0426c">XMC_I2S_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT</a>, <a class="el" href="group___i2_s.html#ggaa876770c9147fa5b0ca79b5bbd755ce9a57e6d7b8a3d66799258e3ded542a872c">XMC_I2S_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER</a> etc. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number.<br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for USIC channel events. <br />
<br />
For an event to generate interrupt, node pointer should be configured with service request(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so.<br />
 Note: NVIC node should be separately enabled to generate the interrupt.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaff2473a1c092b6cbb61c9996086c2ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a> XMC_I2S_CH_SetBaudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">rate</td><td>Bus speed in bits per second</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>XMC_I2S_CH_STATUS_t Status of the I2S driver after the request for setting baudrate is processed. <br />
 XMC_I2S_CH_STATUS_OK- If the baudrate is successfully changed. <br />
 XMC_I2S_CH_STATUS_ERROR- If the new baudrate value is out of range.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the bus speed in bits per second</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_I2S_CH_Init(), <a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop()</a> </dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga365e507fce74d7a9d1f02a00b8db9223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetBitOrderLsbFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the order of data transfer from LSB to MSB, by clearing SCTR.SDIR bit.<br />
<br />
This is typically based on the slave settings. Invoke <a class="el" href="group___i2_s.html#ga365e507fce74d7a9d1f02a00b8db9223">XMC_I2S_CH_SetBitOrderLsbFirst()</a> to set direction as needed in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga33a3c6090697d5df5038b3c1b5ed1c13">XMC_I2S_CH_SetBitOrderMsbFirst()</a> </dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#ac005cdf6a4e1350830161ee7ef88b9a2">XMC_USIC_CH_t::SCTR</a>.</p>

</div>
</div>
<a class="anchor" id="ga33a3c6090697d5df5038b3c1b5ed1c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetBitOrderMsbFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the order of data transfer from MSB to LSB, by setting SCTR.SDIR bit.<br />
<br />
This is typically based on the slave settings. This is not set during XMC_I2S_CH_Init(). Invoke <a class="el" href="group___i2_s.html#ga33a3c6090697d5df5038b3c1b5ed1c13">XMC_I2S_CH_SetBitOrderMsbFirst()</a> to set direction as needed in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga365e507fce74d7a9d1f02a00b8db9223">XMC_I2S_CH_SetBitOrderLsbFirst()</a> </dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#ac005cdf6a4e1350830161ee7ef88b9a2">XMC_USIC_CH_t::SCTR</a>, <a class="el" href="group___i2_s.html#ga624bd3292e9b6ea3bb41689d41fadb27">XMC_I2S_CH_DisableEvent()</a> und <a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent()</a>.</p>

</div>
</div>
<a class="anchor" id="gacf411f00a4585150d33d3259dfc785ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetFrameLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>frame_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">frame_length</td><td>Number of bits in a frame. <br />
 <b>Range:</b> 1 to 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Define the data frame length.<br />
<br />
Set the number of bits to be serially transmitted in a frame. The frame length should be multiples of word length.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gabb9d02b8388a03cd28190c976cdb8b78">XMC_USIC_CH_SetWordLength()</a> </dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#ga23964f6d982b35388f3a7c82f5634e0f">XMC_USIC_CH_SetFrameLength()</a>.</p>

</div>
</div>
<a class="anchor" id="ga32572b75a2b528238622cfa91da6239f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetInputSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">input</td><td>I2S channel input stage.<br />
 Refer <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> for valid values </td></tr>
    <tr><td class="paramname">source</td><td>Input source select for the input stage. Range : [0 to 7]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the data source for I2S input stage, by configuring DXCR.DSEL bits.<br />
<br />
Selects the input data signal source among DXnA, DXnB.. DXnG for the input stage. The API can be used for all the input stages like DX0CR, DX1CR etc. This is not done during initialization. This has to be configured before starting the I2S communication. </dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a> und <a class="el" href="group___u_s_i_c.html#ga7986fcfe3fd6bf9982e43b1eaabb02c2">XMC_USIC_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8af8cb0639aeede0ab9faead5fa7f55c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number. Range: [0 to 5]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for I2S channel events.<br />
<br />
For an event to generate interrupt, node pointer should be configured with service request(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so. This is not configured in XMC_I2S_CH_Init() during initialization.</dd></dl>
<dl class="section user"><dt>Note::</dt><dd><ol type="1">
<li>NVIC node should be separately enabled to generate the interrupt.</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga6f9467a0f290d65f7292b45cc29e32b4">XMC_USIC_CH_EnableEvent()</a> </dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#gga074b5b1abff43f98316c7a5b69523e62a3b99d0d6e93882ea791e8952cc993a7b">XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL</a> und <a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="gabb2198a50935a491a48686d85b53f0bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetSystemWordLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sclk_cycles_system_word_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">sclk_cycles_system_word_length</td><td>system word length in terms of sclk clock cycles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the system word length by setting BRG.DCTQ bit field.<br />
<br />
This value has to be always higher than 1U and lower than the data with (SCTR.FLE) </dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga55da8db55309c3afb4d9c6f238aeb240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetWordLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>word_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">word_length</td><td>Number of bits to be configured for a data word. <br />
 <b>Range:</b> 1 to 16.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Defines the data word length.<br />
<br />
Sets the number of bits to represent a data word. Frame length should be a multiple of word length.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gacf411f00a4585150d33d3259dfc785ca">XMC_I2S_CH_SetFrameLength()</a> </dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#gabb9d02b8388a03cd28190c976cdb8b78">XMC_USIC_CH_SetWordLength()</a>.</p>

</div>
</div>
<a class="anchor" id="ga398df3f0a83ceee1c0b2891c6f551da5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the selected USIC channel to operate in I2S mode, by setting CCR.MODE bits.<br />
<br />
It should be executed after XMC_I2S_CH_Init() during initialization. By invoking <a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop()</a>, the MODE is set to IDLE state. Call <a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a> to set the I2S mode again, as needed later in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_I2S_CH_Init(), <a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop()</a> </dd></dl>

<p>Benutzt <a class="el" href="group___i2_s.html#gaff2473a1c092b6cbb61c9996086c2ea9">XMC_I2S_CH_SetBaudrate()</a>, <a class="el" href="group___i2_s.html#gabb2198a50935a491a48686d85b53f0bf">XMC_I2S_CH_SetSystemWordLength()</a>, <a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop()</a>, <a class="el" href="group___i2_s.html#ga961ec248ea914b53a1e7595f4a0e8d01">XMC_I2S_CH_Transmit()</a>, <a class="el" href="group___u_s_i_c.html#ggac052842418ff3dda00900219ebda5de7a567f54d1a3c96472fca5d6039d5e3cbc">XMC_USIC_CH_OPERATING_MODE_I2S</a> und <a class="el" href="group___u_s_i_c.html#ga8c04c213fd44c14b1bed871bb658683c">XMC_USIC_CH_SetMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1fab03647f2593b60365e39463fe5cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a> XMC_I2S_CH_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>XMC_I2S_CH_STATUS_t Status of the I2S driver after the request for stopping is processed. <br />
 XMC_I2S_CH_STATUS_OK- If the USIC channel is successfully put to IDLE mode. <br />
 XMC_I2S_CH_STATUS_BUSY- If the USIC channel is busy transmitting data.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the selected I2S channel to IDLE mode, by clearing CCR.MODE bits.<br />
<br />
After calling XMC_I2S_CH_Stop, channel is IDLE mode. So no communication is supported. <a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a> has to be invoked to start the communication again.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a> </dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga961ec248ea914b53a1e7595f4a0e8d01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_Transmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a>&#160;</td>
          <td class="paramname"><em>channel_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be transmitted </td></tr>
    <tr><td class="paramname">channel_number</td><td>Communication output channel of the I2S, based on this channel selection TCI(Transmit control information)is updated.<br />
 Refer <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a> for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Puts the data into FIFO, if FIFO mode is enabled or else into standard buffer, by setting the proper mode.<br />
<br />
TCI(Transmit Control Information) allows dynamic control of output channel during data transfers. To support this auto update, TCSR.WAMD(Automatic WA mode) will be enabled during the initialization using XMC_I2S_CH_Init() for all modes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive()</a> </dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive()</a> und <a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4332db9df7ffbb91a633d94a05897ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_TriggerServiceRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, <a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>,<a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>,<a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>,<a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>,<a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Zu beachten</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_request_line</td><td>service request number of the event to be triggered. <br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Trigger a I2S interrupt service request.<br />
<br />
When the I2S service request is triggered, the NVIC interrupt associated with it will be generated if enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gafd9b940110725dee4580f570f54028ab">XMC_I2S_CH_SelectInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#ga6fa0313a4dfcade23a7098631edefc50">XMC_USIC_CH_TriggerServiceRequest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga356145e003922d6ef50f7aab6a14afe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_WordAddressSignalPolarity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#gaf06d8ef70b2f776bd0e3f4a4860b6dd4">XMC_I2S_CH_WA_POLARITY_t</a>&#160;</td>
          <td class="paramname"><em>wa_inversion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">wa_inversion</td><td>Polarity of the word address signal.<br />
 Refer <a class="el" href="group___i2_s.html#gaf06d8ef70b2f776bd0e3f4a4860b6dd4">XMC_I2S_CH_WA_POLARITY_t</a> for valid values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>R√ºckgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Set the polarity of the word address signal, by configuring PCR.SELINV bit.<br />
<br />
Normally WA signal is active low level signal. This is configured in XMC_I2S_CH_Init() during initialization. Invoke <a class="el" href="group___i2_s.html#ga356145e003922d6ef50f7aab6a14afe9">XMC_I2S_CH_WordAddressSignalPolarity()</a> with desired settings as needed later in the program. </dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#aeec549c9dd9bd6e62a584995958fc91d">XMC_USIC_CH_t::PCR_IISMode</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Erzeugt am Mit Jun 22 2016 11:36:59 f√ºr XMC Peripheral Library for XMC4000 Family von &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
