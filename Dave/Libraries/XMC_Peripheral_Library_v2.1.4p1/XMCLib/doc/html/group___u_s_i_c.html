<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>XMC Peripheral Library for XMC4000 Family: USIC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family
   &#160;<span id="projectnumber">2.1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Hauptseite</span></a></li>
      <li><a href="pages.html"><span>Zusätzliche&#160;Informationen</span></a></li>
      <li class="current"><a href="modules.html"><span>Module</span></a></li>
      <li><a href="files.html"><span>Dateien</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Datenstrukturen</a> &#124;
<a href="#define-members">Makrodefinitionen</a> &#124;
<a href="#typedef-members">Typdefinitionen</a> &#124;
<a href="#enum-members">Aufzählungen</a> &#124;
<a href="#func-members">Funktionen</a>  </div>
  <div class="headertitle">
<div class="title">USIC<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Datenstrukturen</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Makrodefinitionen</h2></td></tr>
<tr class="memitem:ga857b16f38336b2f0bda76d514c341748"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga857b16f38336b2f0bda76d514c341748">USIC_CH_DXCR_CM_Msk</a>&#160;&#160;&#160;USIC_CH_DX0CR_CM_Msk</td></tr>
<tr class="separator:ga857b16f38336b2f0bda76d514c341748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac37ea251ee432c469f3ca780f00a0a82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gac37ea251ee432c469f3ca780f00a0a82">USIC_CH_DXCR_CM_Pos</a>&#160;&#160;&#160;USIC_CH_DX0CR_CM_Pos</td></tr>
<tr class="separator:gac37ea251ee432c469f3ca780f00a0a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd79dd61fa38db0bc2a735c9c2d7e272"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gacd79dd61fa38db0bc2a735c9c2d7e272">USIC_CH_DXCR_DFEN_Msk</a>&#160;&#160;&#160;USIC_CH_DX0CR_DFEN_Msk</td></tr>
<tr class="separator:gacd79dd61fa38db0bc2a735c9c2d7e272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe4d28d8e09425ff5fd0f2c98ea85e1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gafe4d28d8e09425ff5fd0f2c98ea85e1b">USIC_CH_DXCR_DPOL_Msk</a>&#160;&#160;&#160;USIC_CH_DX0CR_DPOL_Msk</td></tr>
<tr class="separator:gafe4d28d8e09425ff5fd0f2c98ea85e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422029f5a94b9e2960a712fb3cb437d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga422029f5a94b9e2960a712fb3cb437d0">USIC_CH_DXCR_DSEL_Msk</a>&#160;&#160;&#160;USIC_CH_DX0CR_DSEL_Msk</td></tr>
<tr class="separator:ga422029f5a94b9e2960a712fb3cb437d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3fe0ed0b13c04904e25ccee9eeb084c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gad3fe0ed0b13c04904e25ccee9eeb084c">USIC_CH_DXCR_DSEL_Pos</a>&#160;&#160;&#160;USIC_CH_DX0CR_DSEL_Pos</td></tr>
<tr class="separator:gad3fe0ed0b13c04904e25ccee9eeb084c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00a9eaab71452bf3b16b78aa080cb25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaf00a9eaab71452bf3b16b78aa080cb25">USIC_CH_DXCR_DSEN_Msk</a>&#160;&#160;&#160;USIC_CH_DX0CR_DSEN_Msk</td></tr>
<tr class="separator:gaf00a9eaab71452bf3b16b78aa080cb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e60cb55d2c3135d5e1fcd317b0bcdbe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga9e60cb55d2c3135d5e1fcd317b0bcdbe">USIC_CH_DXCR_INSW_Msk</a>&#160;&#160;&#160;USIC_CH_DX0CR_INSW_Msk</td></tr>
<tr class="separator:ga9e60cb55d2c3135d5e1fcd317b0bcdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a305fbc3474056c2becf2ae00dd2fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga65a305fbc3474056c2becf2ae00dd2fd">USIC_CH_DXCR_INSW_pos</a>&#160;&#160;&#160;USIC_CH_DX0CR_INSW_Pos</td></tr>
<tr class="separator:ga65a305fbc3474056c2becf2ae00dd2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40b6e977acd2290853cfa788ec56dc5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaa40b6e977acd2290853cfa788ec56dc5">USIC_CH_DXCR_SFSEL_Msk</a>&#160;&#160;&#160;USIC_CH_DX0CR_SFSEL_Msk</td></tr>
<tr class="separator:gaa40b6e977acd2290853cfa788ec56dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad780e0ceed2e148c84ddb0f0e2df2a44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gad780e0ceed2e148c84ddb0f0e2df2a44">USIC_CH_DXCR_SFSEL_Pos</a>&#160;&#160;&#160;USIC_CH_DX0CR_SFSEL_Pos</td></tr>
<tr class="separator:gad780e0ceed2e148c84ddb0f0e2df2a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5471c5fff228b5b9695356e7d2fc98a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gab5471c5fff228b5b9695356e7d2fc98a">XMC_USIC0</a>&#160;&#160;&#160;((<a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *)USIC0_BASE)</td></tr>
<tr class="separator:gab5471c5fff228b5b9695356e7d2fc98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28dd6da4b742e7336b12ae6fa8de5e9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC0_CH0_BASE)</td></tr>
<tr class="separator:ga28dd6da4b742e7336b12ae6fa8de5e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c9a3765e7d637114fc67951cf20c5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a>&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC0_CH1_BASE)</td></tr>
<tr class="separator:gab7c9a3765e7d637114fc67951cf20c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb00ed8ca0740c0b213c6684d636678"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gabeb00ed8ca0740c0b213c6684d636678">XMC_USIC1</a>&#160;&#160;&#160;((<a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *)USIC1_BASE)</td></tr>
<tr class="separator:gabeb00ed8ca0740c0b213c6684d636678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3012ea0f6b1dddc5b1c05425e15c4a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a>&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC1_CH0_BASE)</td></tr>
<tr class="separator:gab3012ea0f6b1dddc5b1c05425e15c4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8892cec48c6246ff3e470178e4273f99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a>&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC1_CH1_BASE)</td></tr>
<tr class="separator:ga8892cec48c6246ff3e470178e4273f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fa3c2b59871d42c4a0918d1de5e1b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga13fa3c2b59871d42c4a0918d1de5e1b3">XMC_USIC2</a>&#160;&#160;&#160;((<a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *)USIC2_BASE)</td></tr>
<tr class="separator:ga13fa3c2b59871d42c4a0918d1de5e1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab79d676f4efb3235bd3d8c977b83b1cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a>&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC2_CH0_BASE)</td></tr>
<tr class="separator:gab79d676f4efb3235bd3d8c977b83b1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f71692f25917f0dcd77bb77e5518313"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a>&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC2_CH1_BASE)</td></tr>
<tr class="separator:ga6f71692f25917f0dcd77bb77e5518313"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typdefinitionen</h2></td></tr>
<tr class="memitem:ga953ad8cb6043e854f32ab9a53042aedb"><td class="memItemLeft" align="right" valign="top">typedef USIC_GLOBAL_TypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a></td></tr>
<tr class="separator:ga953ad8cb6043e854f32ab9a53042aedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Aufzählungen</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funktionen</h2></td></tr>
<tr class="memitem:ga00c6419dfc0f8ed4c4eab13ded598144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga00c6419dfc0f8ed4c4eab13ded598144">XMC_USIC_CH_ConfigExternalInputSignalToBRG</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t pdiv, const uint32_t oversampling, const <a class="el" href="group___u_s_i_c.html#ga4c50ae5a7f12a5496d82d2bc665e1db2">XMC_USIC_CH_INPUT_COMBINATION_MODE_t</a> combination_mode)</td></tr>
<tr class="separator:ga00c6419dfc0f8ed4c4eab13ded598144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba9a2e95af4e455dddd73f324577c876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaba9a2e95af4e455dddd73f324577c876">XMC_USIC_CH_ConfigureShiftClockOutput</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#gaabdebf7dc81a008ca887ab0336f9b3de">XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t</a> passive_level, const <a class="el" href="group___u_s_i_c.html#ga373c90ba61a8cc0013f395840bc9acfd">XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a> clock_output)</td></tr>
<tr class="separator:gaba9a2e95af4e455dddd73f324577c876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61291bfe08ea6012739d90d7524fa1bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga61291bfe08ea6012739d90d7524fa1bd">XMC_USIC_CH_ConnectInputDataShiftToDataInput</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga61291bfe08ea6012739d90d7524fa1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5aabc85e73a242eea72dd6838ee3e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga1c5aabc85e73a242eea72dd6838ee3e5">XMC_USIC_CH_ConnectInputDataShiftToPPP</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga1c5aabc85e73a242eea72dd6838ee3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaba8dc6e2fe4c5cf3fd3418d532a9412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaaba8dc6e2fe4c5cf3fd3418d532a9412">XMC_USIC_CH_Disable</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaaba8dc6e2fe4c5cf3fd3418d532a9412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9896966f6e2e6109f8a7ca0de03d0b39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga9896966f6e2e6109f8a7ca0de03d0b39">XMC_USIC_CH_DisableDelayCompensation</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga9896966f6e2e6109f8a7ca0de03d0b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2520619d1b8420b50501c24b2155c02a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga2520619d1b8420b50501c24b2155c02a">XMC_USIC_CH_DisableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga2520619d1b8420b50501c24b2155c02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga923439c666ca95a5d7907c920891c111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga923439c666ca95a5d7907c920891c111">XMC_USIC_CH_DisableFrameLengthControl</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga923439c666ca95a5d7907c920891c111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db3c5e7fe198de01001e0ee43dd4fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga1db3c5e7fe198de01001e0ee43dd4fef">XMC_USIC_CH_DisableInputDigitalFilter</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga1db3c5e7fe198de01001e0ee43dd4fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa018c766c173f43dbdba8c821a90a645"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaa018c766c173f43dbdba8c821a90a645">XMC_USIC_CH_DisableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gaa018c766c173f43dbdba8c821a90a645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad85027beef2c0cf3dd897e889acf939"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaad85027beef2c0cf3dd897e889acf939">XMC_USIC_CH_DisableInputSync</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gaad85027beef2c0cf3dd897e889acf939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4227196c29ecd683240b968aa54b7758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga4227196c29ecd683240b968aa54b7758">XMC_USIC_CH_DisableTBUFDataValidTrigger</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga4227196c29ecd683240b968aa54b7758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a5bbfcfa061c76a12505e4183d832d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gae5a5bbfcfa061c76a12505e4183d832d">XMC_USIC_CH_DisableTimeMeasurement</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gae5a5bbfcfa061c76a12505e4183d832d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0567321036170adb335fef9b36dc3b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga0567321036170adb335fef9b36dc3b71">XMC_USIC_CH_Enable</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga0567321036170adb335fef9b36dc3b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eaad0f90219fa9bb43bfdf932ea2451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga1eaad0f90219fa9bb43bfdf932ea2451">XMC_USIC_CH_EnableDelayCompensation</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga1eaad0f90219fa9bb43bfdf932ea2451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9467a0f290d65f7292b45cc29e32b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga6f9467a0f290d65f7292b45cc29e32b4">XMC_USIC_CH_EnableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga6f9467a0f290d65f7292b45cc29e32b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d2b03bb1350dfc628f0bfa9fb6ffb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaf1d2b03bb1350dfc628f0bfa9fb6ffb0">XMC_USIC_CH_EnableFrameLengthControl</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaf1d2b03bb1350dfc628f0bfa9fb6ffb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a776750022b67a7d4075fb06eac39dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga6a776750022b67a7d4075fb06eac39dc">XMC_USIC_CH_EnableInputDigitalFilter</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga6a776750022b67a7d4075fb06eac39dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae13b2003ea4d8703a9990d1e90048dc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gae13b2003ea4d8703a9990d1e90048dc3">XMC_USIC_CH_EnableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gae13b2003ea4d8703a9990d1e90048dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a5edb9ab8796da1f86be687fab65f32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga1a5edb9ab8796da1f86be687fab65f32">XMC_USIC_CH_EnableInputSync</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga1a5edb9ab8796da1f86be687fab65f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e8a1fa11993aedfd8d9fb1bf6daf36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga7e8a1fa11993aedfd8d9fb1bf6daf36c">XMC_USIC_CH_EnableTBUFDataValidTrigger</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga7e8a1fa11993aedfd8d9fb1bf6daf36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb5f590b8867d286b7a9f4e52fd3a6a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gadb5f590b8867d286b7a9f4e52fd3a6a9">XMC_USIC_CH_EnableTimeMeasurement</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gadb5f590b8867d286b7a9f4e52fd3a6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6987b85c22a6f6e220042e07f255ca7d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga6987b85c22a6f6e220042e07f255ca7d">XMC_USIC_CH_GetReceiveBufferStatus</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga6987b85c22a6f6e220042e07f255ca7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga091c9637a98727f1dce0d159764aea24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_i_c.html#ga1139d992c4767497e1ead00f098d7024">XMC_USIC_CH_TBUF_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga091c9637a98727f1dce0d159764aea24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f2d42836e73b8a200c437e69611474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga92f2d42836e73b8a200c437e69611474">XMC_USIC_CH_RXFIFO_ClearEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga92f2d42836e73b8a200c437e69611474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ba419dd17bdb7e7be5f5ca757910a00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga4ba419dd17bdb7e7be5f5ca757910a00">XMC_USIC_CH_RXFIFO_Configure</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t data_pointer, const <a class="el" href="group___u_s_i_c.html#gafdd0a07bee93d72936191b7e8555aefe">XMC_USIC_CH_FIFO_SIZE_t</a> size, const uint32_t limit)</td></tr>
<tr class="separator:ga4ba419dd17bdb7e7be5f5ca757910a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f963f40c8ab670bffe6ce88cdf462d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaf5f963f40c8ab670bffe6ce88cdf462d">XMC_USIC_CH_RXFIFO_DisableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:gaf5f963f40c8ab670bffe6ce88cdf462d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4cdb767e1ac3a256b1335a19d2c33ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gad4cdb767e1ac3a256b1335a19d2c33ad">XMC_USIC_CH_RXFIFO_EnableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:gad4cdb767e1ac3a256b1335a19d2c33ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8a59ec35554be7dbf41778888d2b69f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gab8a59ec35554be7dbf41778888d2b69f">XMC_USIC_CH_RXFIFO_Flush</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gab8a59ec35554be7dbf41778888d2b69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661b9482d7cc6b983f178bb6a30a5c76"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga661b9482d7cc6b983f178bb6a30a5c76">XMC_USIC_CH_RXFIFO_GetData</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga661b9482d7cc6b983f178bb6a30a5c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674dcaba8a7a575983ab61b27a580b2d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga674dcaba8a7a575983ab61b27a580b2d">XMC_USIC_CH_RXFIFO_GetEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga674dcaba8a7a575983ab61b27a580b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac69592a81e495b0adf515547a0e8037e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gac69592a81e495b0adf515547a0e8037e">XMC_USIC_CH_RXFIFO_GetLevel</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gac69592a81e495b0adf515547a0e8037e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa81c3a8fab62930c291910628a08f575"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaa81c3a8fab62930c291910628a08f575">XMC_USIC_CH_RXFIFO_IsEmpty</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaa81c3a8fab62930c291910628a08f575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23338f848d35ee56a38af652e4a9db6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga23338f848d35ee56a38af652e4a9db6a">XMC_USIC_CH_RXFIFO_IsFull</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga23338f848d35ee56a38af652e4a9db6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cce6b36f9c5fc6b9487dcee14a04e1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga0cce6b36f9c5fc6b9487dcee14a04e1a">XMC_USIC_CH_RXFIFO_SetInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga4b1bb4e4041f310e46c635b007ee2c73">XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t</a> interrupt_node, const uint32_t service_request)</td></tr>
<tr class="separator:ga0cce6b36f9c5fc6b9487dcee14a04e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9984f496fe787c05b84dc6d1d65ee2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gae9984f496fe787c05b84dc6d1d65ee2e">XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#gafdd0a07bee93d72936191b7e8555aefe">XMC_USIC_CH_FIFO_SIZE_t</a> size, const uint32_t limit)</td></tr>
<tr class="separator:gae9984f496fe787c05b84dc6d1d65ee2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9feec95c73b09889e494ec6d6898f4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_i_c.html#gaf0ce1333656386f14f018b400beb9e39">XMC_USIC_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gac9feec95c73b09889e494ec6d6898f4f">XMC_USIC_CH_SetBaudrate</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t rate, uint32_t oversampling)</td></tr>
<tr class="separator:gac9feec95c73b09889e494ec6d6898f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2876a325930da4b77ef46ec4e0acda0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga2876a325930da4b77ef46ec4e0acda0d">XMC_USIC_CH_SetBRGInputClockSource</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga4a6a3d9ca8a64d7689f25c8c688cbab9">XMC_USIC_CH_BRG_CLOCK_SOURCE_t</a> clock_source)</td></tr>
<tr class="separator:ga2876a325930da4b77ef46ec4e0acda0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga920a20a26fbff1aaeb240af921f61ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga920a20a26fbff1aaeb240af921f61ce4">XMC_USIC_CH_SetDataOutputMode</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#gab277976402d3da779839621f911fe89a">XMC_USIC_CH_DATA_OUTPUT_MODE_t</a> data_output_mode)</td></tr>
<tr class="separator:ga920a20a26fbff1aaeb240af921f61ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23964f6d982b35388f3a7c82f5634e0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga23964f6d982b35388f3a7c82f5634e0f">XMC_USIC_CH_SetFrameLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t frame_length)</td></tr>
<tr class="separator:ga23964f6d982b35388f3a7c82f5634e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ed1338593c1492f35321494aedfa48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga77ed1338593c1492f35321494aedfa48">XMC_USIC_CH_SetInputSamplingFreq</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input, const <a class="el" href="group___u_s_i_c.html#ga4eabf4e044ae33972f726f904e788f8a">XMC_USIC_CH_INPUT_SAMPLING_FREQ_t</a> sampling_freq)</td></tr>
<tr class="separator:ga77ed1338593c1492f35321494aedfa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7986fcfe3fd6bf9982e43b1eaabb02c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga7986fcfe3fd6bf9982e43b1eaabb02c2">XMC_USIC_CH_SetInputSource</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input, const uint8_t source)</td></tr>
<tr class="separator:ga7986fcfe3fd6bf9982e43b1eaabb02c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef58e03c1253fce5b8a456f5d8c6da6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaeef58e03c1253fce5b8a456f5d8c6da6">XMC_USIC_CH_SetInputTriggerCombinationMode</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a> input, const <a class="el" href="group___u_s_i_c.html#ga4c50ae5a7f12a5496d82d2bc665e1db2">XMC_USIC_CH_INPUT_COMBINATION_MODE_t</a> combination_mode)</td></tr>
<tr class="separator:gaeef58e03c1253fce5b8a456f5d8c6da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52f9fc18049dbc906b127e1f3662b4b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga074b5b1abff43f98316c7a5b69523e62">XMC_USIC_CH_INTERRUPT_NODE_POINTER_t</a> interrupt_node, const uint32_t service_request)</td></tr>
<tr class="separator:ga52f9fc18049dbc906b127e1f3662b4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9deda88e97525978786d4711aa75067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaf9deda88e97525978786d4711aa75067">XMC_USIC_CH_SetMclkOutputPassiveLevel</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#gae9d3fa2244d754db4311c49fb624115e">XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL_t</a> passive_level)</td></tr>
<tr class="separator:gaf9deda88e97525978786d4711aa75067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c04c213fd44c14b1bed871bb658683c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga8c04c213fd44c14b1bed871bb658683c">XMC_USIC_CH_SetMode</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#gac052842418ff3dda00900219ebda5de7">XMC_USIC_CH_OPERATING_MODE_t</a> mode)</td></tr>
<tr class="separator:ga8c04c213fd44c14b1bed871bb658683c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46806897ccf781fb6289a8e12c11f9bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga46806897ccf781fb6289a8e12c11f9bf">XMC_USIC_CH_SetPassiveDataLevel</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga352121d35153623dc793f3b59c075eb0">XMC_USIC_CH_PASSIVE_DATA_LEVEL_t</a> passive_level)</td></tr>
<tr class="separator:ga46806897ccf781fb6289a8e12c11f9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b02352ba5e94e8f79751dea304084e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga3b02352ba5e94e8f79751dea304084e0">XMC_USIC_CH_SetStartTransmisionMode</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#gae2db2ec4c7c43ae1454373789443b793">XMC_USIC_CH_START_TRANSMISION_MODE_t</a> start_transmision_mode)</td></tr>
<tr class="separator:ga3b02352ba5e94e8f79751dea304084e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d92409ce4c718ecee4f9498d06346c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga2d92409ce4c718ecee4f9498d06346c6">XMC_USIC_CH_SetTransmitBufferStatus</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#ga46769f2474ad4be950bcfc47582f5f87">XMC_USIC_CH_TBUF_STATUS_SET_t</a> transmit_buffer_status)</td></tr>
<tr class="separator:ga2d92409ce4c718ecee4f9498d06346c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb9d02b8388a03cd28190c976cdb8b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gabb9d02b8388a03cd28190c976cdb8b78">XMC_USIC_CH_SetWordLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t word_length)</td></tr>
<tr class="separator:gabb9d02b8388a03cd28190c976cdb8b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fa0313a4dfcade23a7098631edefc50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga6fa0313a4dfcade23a7098631edefc50">XMC_USIC_CH_TriggerServiceRequest</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t service_request_line)</td></tr>
<tr class="separator:ga6fa0313a4dfcade23a7098631edefc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6c7228b9e6c44332c077acf720f12b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaf6c7228b9e6c44332c077acf720f12b9">XMC_USIC_CH_TXFIFO_ClearEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:gaf6c7228b9e6c44332c077acf720f12b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cfe52daa733ba40e9b93fec60b04406"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga7cfe52daa733ba40e9b93fec60b04406">XMC_USIC_CH_TXFIFO_Configure</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t data_pointer, const <a class="el" href="group___u_s_i_c.html#gafdd0a07bee93d72936191b7e8555aefe">XMC_USIC_CH_FIFO_SIZE_t</a> size, const uint32_t limit)</td></tr>
<tr class="separator:ga7cfe52daa733ba40e9b93fec60b04406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e72155477de1a0495e4f85362fad86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga11e72155477de1a0495e4f85362fad86">XMC_USIC_CH_TXFIFO_DisableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga11e72155477de1a0495e4f85362fad86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4688634fee0d7fbdefca290999ca7b49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga4688634fee0d7fbdefca290999ca7b49">XMC_USIC_CH_TXFIFO_EnableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga4688634fee0d7fbdefca290999ca7b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab075189d6283b3cff45bb4f38d1bd4aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gab075189d6283b3cff45bb4f38d1bd4aa">XMC_USIC_CH_TXFIFO_Flush</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gab075189d6283b3cff45bb4f38d1bd4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadad2288d7f198fbc582dc4af7d1386c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gadad2288d7f198fbc582dc4af7d1386c5">XMC_USIC_CH_TXFIFO_GetEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gadad2288d7f198fbc582dc4af7d1386c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8724f831f2fc77366ece9f4b91bc095f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga8724f831f2fc77366ece9f4b91bc095f">XMC_USIC_CH_TXFIFO_GetLevel</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga8724f831f2fc77366ece9f4b91bc095f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb5c1c2623ce6281ed8683007da127b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga0cb5c1c2623ce6281ed8683007da127b">XMC_USIC_CH_TXFIFO_IsEmpty</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga0cb5c1c2623ce6281ed8683007da127b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee9b8efb56290224bfe1d5ac9b273a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gaaee9b8efb56290224bfe1d5ac9b273a3">XMC_USIC_CH_TXFIFO_IsFull</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaaee9b8efb56290224bfe1d5ac9b273a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae96e9afeaefe2585b687e36f6227727f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#gae96e9afeaefe2585b687e36f6227727f">XMC_USIC_CH_TXFIFO_PutData</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t data)</td></tr>
<tr class="separator:gae96e9afeaefe2585b687e36f6227727f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f14560e863b15c6bd123e534332e9f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga0f14560e863b15c6bd123e534332e9f5">XMC_USIC_CH_TXFIFO_PutDataFLEMode</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t data, const uint32_t frame_length)</td></tr>
<tr class="separator:ga0f14560e863b15c6bd123e534332e9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e10af0afcde1c73c39cd6522ac0614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga63e10af0afcde1c73c39cd6522ac0614">XMC_USIC_CH_TXFIFO_SetInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#gaed66b290b2c45854fcd04580fb6349a1">XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t</a> interrupt_node, const uint32_t service_request)</td></tr>
<tr class="separator:ga63e10af0afcde1c73c39cd6522ac0614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f77f046f48083e3e86735636e86490b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga6f77f046f48083e3e86735636e86490b">XMC_USIC_CH_TXFIFO_SetSizeTriggerLimit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_s_i_c.html#gafdd0a07bee93d72936191b7e8555aefe">XMC_USIC_CH_FIFO_SIZE_t</a> size, const uint32_t limit)</td></tr>
<tr class="separator:ga6f77f046f48083e3e86735636e86490b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90d18508eb69fc4254bd0c3774d16150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga90d18508eb69fc4254bd0c3774d16150">XMC_USIC_CH_WriteToTBUF</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t data)</td></tr>
<tr class="separator:ga90d18508eb69fc4254bd0c3774d16150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40eb0199fd41ec5993971dad8a0e2d40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga40eb0199fd41ec5993971dad8a0e2d40">XMC_USIC_CH_WriteToTBUFTCI</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t data, const uint32_t transmit_control_information)</td></tr>
<tr class="separator:ga40eb0199fd41ec5993971dad8a0e2d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d7f987aa7be2cc8497a0895f2ba3f90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga5d7f987aa7be2cc8497a0895f2ba3f90">XMC_USIC_Disable</a> (<a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *const usic)</td></tr>
<tr class="separator:ga5d7f987aa7be2cc8497a0895f2ba3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48113f030b655f6eaa3b9f6b73474785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_i_c.html#ga48113f030b655f6eaa3b9f6b73474785">XMC_USIC_Enable</a> (<a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *const usic)</td></tr>
<tr class="separator:ga48113f030b655f6eaa3b9f6b73474785"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Ausführliche Beschreibung</h2>
<p>The Universal Serial Interface Channel(USIC) module is a flexible interface module covering several serial communication protocols. A USIC module contains two independent communication channels named USICx_CH0 and USICx_CH1, with x being the number of the USIC module. The user can program, during run-time, which protocol will be handled by each communication channel and which pins are used. The driver provides APIs, configuration structures and enumerations to configure common features of multiple serial communication protocols.</p>
<p>USIC driver features:</p><ol type="1">
<li>Allows configuration of FIFO for transmit and receive functions.</li>
<li>Provides a structure type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> to represent the USIC channel registers in a programmer friendly format.</li>
<li>Allows configuration of automatic update for frame length, word length, slave select or slave address.</li>
<li>Allows transmission of data to FIFO using <a class="el" href="group___u_s_i_c.html#gae96e9afeaefe2585b687e36f6227727f">XMC_USIC_CH_TXFIFO_PutData()</a> and <a class="el" href="group___u_s_i_c.html#ga0f14560e863b15c6bd123e534332e9f5">XMC_USIC_CH_TXFIFO_PutDataFLEMode()</a></li>
<li>Allows reading of received data in FIFO using <a class="el" href="group___u_s_i_c.html#ga661b9482d7cc6b983f178bb6a30a5c76">XMC_USIC_CH_RXFIFO_GetData()</a></li>
<li>Allows configuration of baudrate using <a class="el" href="group___u_s_i_c.html#gac9feec95c73b09889e494ec6d6898f4f">XMC_USIC_CH_SetBaudrate()</a></li>
<li>Provides API to trigger interrupts using <a class="el" href="group___u_s_i_c.html#ga6fa0313a4dfcade23a7098631edefc50">XMC_USIC_CH_TriggerServiceRequest()</a> </li>
</ol>
<h2 class="groupheader">Makro-Dokumentation</h2>
<a class="anchor" id="ga857b16f38336b2f0bda76d514c341748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_CM_Msk&#160;&#160;&#160;USIC_CH_DX0CR_CM_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for CM bitfield mask in DXnCR register </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#gaeef58e03c1253fce5b8a456f5d8c6da6">XMC_USIC_CH_SetInputTriggerCombinationMode()</a>.</p>

</div>
</div>
<a class="anchor" id="gac37ea251ee432c469f3ca780f00a0a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_CM_Pos&#160;&#160;&#160;USIC_CH_DX0CR_CM_Pos</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for CM bitfield position in DXnCR register </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#gaeef58e03c1253fce5b8a456f5d8c6da6">XMC_USIC_CH_SetInputTriggerCombinationMode()</a>.</p>

</div>
</div>
<a class="anchor" id="gacd79dd61fa38db0bc2a735c9c2d7e272"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_DFEN_Msk&#160;&#160;&#160;USIC_CH_DX0CR_DFEN_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for DFEN bitfield mask in DXnCR register </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga1db3c5e7fe198de01001e0ee43dd4fef">XMC_USIC_CH_DisableInputDigitalFilter()</a> und <a class="el" href="group___u_s_i_c.html#ga6a776750022b67a7d4075fb06eac39dc">XMC_USIC_CH_EnableInputDigitalFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="gafe4d28d8e09425ff5fd0f2c98ea85e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_DPOL_Msk&#160;&#160;&#160;USIC_CH_DX0CR_DPOL_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for DPOL bitfield mask in DXnCR register </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#gaa018c766c173f43dbdba8c821a90a645">XMC_USIC_CH_DisableInputInversion()</a> und <a class="el" href="group___u_s_i_c.html#gae13b2003ea4d8703a9990d1e90048dc3">XMC_USIC_CH_EnableInputInversion()</a>.</p>

</div>
</div>
<a class="anchor" id="ga422029f5a94b9e2960a712fb3cb437d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_DSEL_Msk&#160;&#160;&#160;USIC_CH_DX0CR_DSEL_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for DSEL bitfield mask in DXnCR register </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga7986fcfe3fd6bf9982e43b1eaabb02c2">XMC_USIC_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gad3fe0ed0b13c04904e25ccee9eeb084c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_DSEL_Pos&#160;&#160;&#160;USIC_CH_DX0CR_DSEL_Pos</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for DSEL bitfield position in DXnCR register </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga7986fcfe3fd6bf9982e43b1eaabb02c2">XMC_USIC_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf00a9eaab71452bf3b16b78aa080cb25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_DSEN_Msk&#160;&#160;&#160;USIC_CH_DX0CR_DSEN_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for DSEN bitfield mask in DXnCR register </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#gaad85027beef2c0cf3dd897e889acf939">XMC_USIC_CH_DisableInputSync()</a> und <a class="el" href="group___u_s_i_c.html#ga1a5edb9ab8796da1f86be687fab65f32">XMC_USIC_CH_EnableInputSync()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e60cb55d2c3135d5e1fcd317b0bcdbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_INSW_Msk&#160;&#160;&#160;USIC_CH_DX0CR_INSW_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for INSW bitfield mask in DXnCR register </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga61291bfe08ea6012739d90d7524fa1bd">XMC_USIC_CH_ConnectInputDataShiftToDataInput()</a> und <a class="el" href="group___u_s_i_c.html#ga1c5aabc85e73a242eea72dd6838ee3e5">XMC_USIC_CH_ConnectInputDataShiftToPPP()</a>.</p>

</div>
</div>
<a class="anchor" id="ga65a305fbc3474056c2becf2ae00dd2fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_INSW_pos&#160;&#160;&#160;USIC_CH_DX0CR_INSW_Pos</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for INSW bitfield position in DXnCR register </p>

</div>
</div>
<a class="anchor" id="gaa40b6e977acd2290853cfa788ec56dc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_SFSEL_Msk&#160;&#160;&#160;USIC_CH_DX0CR_SFSEL_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for SFSEL bitfield mask in DXnCR register </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga77ed1338593c1492f35321494aedfa48">XMC_USIC_CH_SetInputSamplingFreq()</a>.</p>

</div>
</div>
<a class="anchor" id="gad780e0ceed2e148c84ddb0f0e2df2a44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USIC_CH_DXCR_SFSEL_Pos&#160;&#160;&#160;USIC_CH_DX0CR_SFSEL_Pos</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common mask for SFSEL bitfield position in DXnCR register </p>

</div>
</div>
<a class="anchor" id="gab5471c5fff228b5b9695356e7d2fc98a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USIC0&#160;&#160;&#160;((<a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *)USIC0_BASE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 module base address </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#gaa7e00ca6654c493f25076f002c48dad6">XMC_USIC_IsModuleValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga28dd6da4b742e7336b12ae6fa8de5e9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USIC0_CH0&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC0_CH0_BASE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 0 base address </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="gab7c9a3765e7d637114fc67951cf20c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USIC0_CH1&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC0_CH1_BASE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 1 base address </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="gabeb00ed8ca0740c0b213c6684d636678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USIC1&#160;&#160;&#160;((<a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *)USIC1_BASE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 module base address </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#gaa7e00ca6654c493f25076f002c48dad6">XMC_USIC_IsModuleValid()</a>.</p>

</div>
</div>
<a class="anchor" id="gab3012ea0f6b1dddc5b1c05425e15c4a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USIC1_CH0&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC1_CH0_BASE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 0 base address </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8892cec48c6246ff3e470178e4273f99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USIC1_CH1&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC1_CH1_BASE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 1 base address </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga13fa3c2b59871d42c4a0918d1de5e1b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USIC2&#160;&#160;&#160;((<a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *)USIC2_BASE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 module base address </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#gaa7e00ca6654c493f25076f002c48dad6">XMC_USIC_IsModuleValid()</a>.</p>

</div>
</div>
<a class="anchor" id="gab79d676f4efb3235bd3d8c977b83b1cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USIC2_CH0&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC2_CH0_BASE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 0 base address </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f71692f25917f0dcd77bb77e5518313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USIC2_CH1&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *)USIC2_CH1_BASE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 1 base address </p>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<h2 class="groupheader">Dokumentation der benutzerdefinierten Typen</h2>
<a class="anchor" id="ga953ad8cb6043e854f32ab9a53042aedb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef USIC_GLOBAL_TypeDef <a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC module structure </p>

</div>
</div>
<h2 class="groupheader">Dokumentation der Aufzählungstypen</h2>
<a class="anchor" id="ga5917220b11972dd6f2fdeb20e344f99c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga5917220b11972dd6f2fdeb20e344f99c">XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel baudrate generator divider mode </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga5917220b11972dd6f2fdeb20e344f99cab6c56797b2cfa846072e77ed260939b9"></a>XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_DISABLED&#160;</td><td class="fielddoc">
<p>Baudrate generator clock divider: Disabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5917220b11972dd6f2fdeb20e344f99ca94521f0e91a523cb28af682c05de59f6"></a>XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL&#160;</td><td class="fielddoc">
<p>Baudrate generator clock divider: Normal mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5917220b11972dd6f2fdeb20e344f99cafb8bb99ad350096545bc4e2a14b8812a"></a>XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL&#160;</td><td class="fielddoc">
<p>Baudrate generator clock divider: Fractional mode </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4a6a3d9ca8a64d7689f25c8c688cbab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga4a6a3d9ca8a64d7689f25c8c688cbab9">XMC_USIC_CH_BRG_CLOCK_SOURCE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel baudrate generator clock source </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4a6a3d9ca8a64d7689f25c8c688cbab9ac70865c32728b5c7eb4bfc294887997e"></a>XMC_USIC_CH_BRG_CLOCK_SOURCE_DIVIDER&#160;</td><td class="fielddoc">
<p>Baudrate generator clock source : Source divider. (Internal clock source) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4a6a3d9ca8a64d7689f25c8c688cbab9aef37beb1ab4b3e3d12108669137c3361"></a>XMC_USIC_CH_BRG_CLOCK_SOURCE_DX1T&#160;</td><td class="fielddoc">
<p>Baudrate generator clock source : DX1T. (External clock source) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae9d3fa2244d754db4311c49fb624115e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#gae9d3fa2244d754db4311c49fb624115e">XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel baudrate generator master clock passive level </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae9d3fa2244d754db4311c49fb624115ea0fac1e2e39d4aa98d32a523e76240106"></a>XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL_0&#160;</td><td class="fielddoc">
<p>Baudrate generator master clock passive level(idle mode signal level) 0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae9d3fa2244d754db4311c49fb624115ea387e03692c7d6b05d34825b4ada8422f"></a>XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL_1&#160;</td><td class="fielddoc">
<p>Baudrate generator master clock passive level((idle mode signal level)) 1 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga373c90ba61a8cc0013f395840bc9acfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga373c90ba61a8cc0013f395840bc9acfd">XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel baudrate generator shift clock output </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga373c90ba61a8cc0013f395840bc9acfda9491b02e6b95460911ccdbfd916dd28f"></a>XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK&#160;</td><td class="fielddoc">
<p>Baudrate generator shift clock output: SCL.(Internally generated shift clock) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga373c90ba61a8cc0013f395840bc9acfdabcd84dcb72da7b117900df0eb5c43660"></a>XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_DX1&#160;</td><td class="fielddoc">
<p>Baudrate generator shift clock output: DX1. (External input shift clock) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaabdebf7dc81a008ca887ab0336f9b3de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#gaabdebf7dc81a008ca887ab0336f9b3de">XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel baudrate generator shift clock passive level </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaabdebf7dc81a008ca887ab0336f9b3dea73b5e738a2fbe968b46ea6aae3466956"></a>XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_DISABLED&#160;</td><td class="fielddoc">
<p>Shift clock passive level 0, delay disabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaabdebf7dc81a008ca887ab0336f9b3deaf4a7841504a26dfd70873f1962f5ba89"></a>XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED&#160;</td><td class="fielddoc">
<p>Shift clock passive level 1, delay disabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaabdebf7dc81a008ca887ab0336f9b3deabb31d132a979405f51e7a6ab44071f46"></a>XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_ENABLED&#160;</td><td class="fielddoc">
<p>Shift clock passive level 0, delay enabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaabdebf7dc81a008ca887ab0336f9b3deac496300b9f7d9f340bed2bf4dfb1b8d6"></a>XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_ENABLED&#160;</td><td class="fielddoc">
<p>Shift clock passive level 1, delay enabled </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab277976402d3da779839621f911fe89a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#gab277976402d3da779839621f911fe89a">XMC_USIC_CH_DATA_OUTPUT_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel data output mode </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab277976402d3da779839621f911fe89aa2ee23e3a426e82d5e9142079a16f00bf"></a>XMC_USIC_CH_DATA_OUTPUT_MODE_NORMAL&#160;</td><td class="fielddoc">
<p>Data output normal mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab277976402d3da779839621f911fe89aa984f346629f34906201bbde3a6863ede"></a>XMC_USIC_CH_DATA_OUTPUT_MODE_INVERTED&#160;</td><td class="fielddoc">
<p>Data output inverted mode </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9101f93a9a9c4c5a27f1418e3335b012"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga9101f93a9a9c4c5a27f1418e3335b012">XMC_USIC_CH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel events </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9101f93a9a9c4c5a27f1418e3335b012ab27889da7076d1a9ab4e249b19b71cb1"></a>XMC_USIC_CH_EVENT_RECEIVE_START&#160;</td><td class="fielddoc">
<p>Receive start event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9101f93a9a9c4c5a27f1418e3335b012a948a392bad3aca7de34a4acfd2b5eb7e"></a>XMC_USIC_CH_EVENT_DATA_LOST&#160;</td><td class="fielddoc">
<p>Data lost event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9101f93a9a9c4c5a27f1418e3335b012a62c2e30dc6b1f4dc5029bb3769bc54f1"></a>XMC_USIC_CH_EVENT_TRANSMIT_SHIFT&#160;</td><td class="fielddoc">
<p>Transmit shift event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9101f93a9a9c4c5a27f1418e3335b012a1c843b5c4cf9d9fe0c0911b1ad73b981"></a>XMC_USIC_CH_EVENT_TRANSMIT_BUFFER&#160;</td><td class="fielddoc">
<p>Transmit buffer event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9101f93a9a9c4c5a27f1418e3335b012a990e43a9a742c483efae77fb16689406"></a>XMC_USIC_CH_EVENT_STANDARD_RECEIVE&#160;</td><td class="fielddoc">
<p>Receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9101f93a9a9c4c5a27f1418e3335b012aa3a0511be20785278677eb0699ef924e"></a>XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE&#160;</td><td class="fielddoc">
<p>Alternate receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9101f93a9a9c4c5a27f1418e3335b012a0bd21a2c8da9ee272006fe1ec7abb2d9"></a>XMC_USIC_CH_EVENT_BAUD_RATE_GENERATOR&#160;</td><td class="fielddoc">
<p>Baudrate generator event </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gafdd0a07bee93d72936191b7e8555aefe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#gafdd0a07bee93d72936191b7e8555aefe">XMC_USIC_CH_FIFO_SIZE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel receive FIFO size </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggafdd0a07bee93d72936191b7e8555aefea1c189be4c15d2176b740037fa220e4a4"></a>XMC_USIC_CH_FIFO_DISABLED&#160;</td><td class="fielddoc">
<p>FIFO Disabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggafdd0a07bee93d72936191b7e8555aefeac2b3558621719f1d4e64d55a0febb166"></a>XMC_USIC_CH_FIFO_SIZE_2WORDS&#160;</td><td class="fielddoc">
<p>FIFO size: 2 words </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggafdd0a07bee93d72936191b7e8555aefeaa26264021f8318df9187f0edb55b093e"></a>XMC_USIC_CH_FIFO_SIZE_4WORDS&#160;</td><td class="fielddoc">
<p>FIFO size: 4 words </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggafdd0a07bee93d72936191b7e8555aefea7eb82cbde316bc34b32a4935719e3485"></a>XMC_USIC_CH_FIFO_SIZE_8WORDS&#160;</td><td class="fielddoc">
<p>FIFO size: 8 words </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggafdd0a07bee93d72936191b7e8555aefeade956d53b256464afd024854c48f3cdc"></a>XMC_USIC_CH_FIFO_SIZE_16WORDS&#160;</td><td class="fielddoc">
<p>FIFO size: 16 words </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggafdd0a07bee93d72936191b7e8555aefeaa368b5bf667c1b4ba6bbf1071ff6ebd0"></a>XMC_USIC_CH_FIFO_SIZE_32WORDS&#160;</td><td class="fielddoc">
<p>FIFO size: 32 words </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggafdd0a07bee93d72936191b7e8555aefead702883ad36b39b6014e45b31f1655e8"></a>XMC_USIC_CH_FIFO_SIZE_64WORDS&#160;</td><td class="fielddoc">
<p>FIFO size: 64 words </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4c50ae5a7f12a5496d82d2bc665e1db2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga4c50ae5a7f12a5496d82d2bc665e1db2">XMC_USIC_CH_INPUT_COMBINATION_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel input combination mode </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4c50ae5a7f12a5496d82d2bc665e1db2a84a7d20ea5095174ad36f6b0569e5746"></a>XMC_USIC_CH_INPUT_COMBINATION_MODE_TRIGGER_DISABLED&#160;</td><td class="fielddoc">
<p>The trigger activation is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4c50ae5a7f12a5496d82d2bc665e1db2a96738f5f29e01869760b3b303ee5ba5c"></a>XMC_USIC_CH_INPUT_COMBINATION_MODE_RISING_EDGE&#160;</td><td class="fielddoc">
<p>A rising edge activates DXnT </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4c50ae5a7f12a5496d82d2bc665e1db2a57148dae73908e188f45a14eaabf266d"></a>XMC_USIC_CH_INPUT_COMBINATION_MODE_FALLING_EDGE&#160;</td><td class="fielddoc">
<p>A falling edge activates DXnT </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4c50ae5a7f12a5496d82d2bc665e1db2aa48b1f45d1c95a5db012305e02c3e2d2"></a>XMC_USIC_CH_INPUT_COMBINATION_MODE_BOTH_EDGES&#160;</td><td class="fielddoc">
<p>Both edges activate DXnT </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4eabf4e044ae33972f726f904e788f8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga4eabf4e044ae33972f726f904e788f8a">XMC_USIC_CH_INPUT_SAMPLING_FREQ_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel input source sampling frequency </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4eabf4e044ae33972f726f904e788f8aa140d9db737218ef374f79f19d16f67e5"></a>XMC_USIC_CH_INPUT_SAMPLING_FREQ_FPERIPH&#160;</td><td class="fielddoc">
<p>Use fperiph frequency for input source sampling </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4eabf4e044ae33972f726f904e788f8aa8ad2708c596461047862f7a3c71c3892"></a>XMC_USIC_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER&#160;</td><td class="fielddoc">
<p>Common mask for SFSEL bitfield position in DXnCR register Use fFD(fractional divider) frequency for input source sampling </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7b7c285b4dfe6c9132f2f478a59b2ac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel inputs </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee"></a>XMC_USIC_CH_INPUT_DX0&#160;</td><td class="fielddoc">
<p>DX0 input </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7b7c285b4dfe6c9132f2f478a59b2ac5a6925b9516396378ecbe92b01d8d1bcda"></a>XMC_USIC_CH_INPUT_DX1&#160;</td><td class="fielddoc">
<p>DX1 input </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7b7c285b4dfe6c9132f2f478a59b2ac5a433047983054df98c04e1dbd974c59ed"></a>XMC_USIC_CH_INPUT_DX2&#160;</td><td class="fielddoc">
<p>DX2 input </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7b7c285b4dfe6c9132f2f478a59b2ac5ae6ce0ad774f54bea6c653ce5ffe13132"></a>XMC_USIC_CH_INPUT_DX3&#160;</td><td class="fielddoc">
<p>DX3 input </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7b7c285b4dfe6c9132f2f478a59b2ac5a7247770ce9d6895fd69800b89b918a27"></a>XMC_USIC_CH_INPUT_DX4&#160;</td><td class="fielddoc">
<p>DX4 input </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd"></a>XMC_USIC_CH_INPUT_DX5&#160;</td><td class="fielddoc">
<p>DX5 input </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga074b5b1abff43f98316c7a5b69523e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga074b5b1abff43f98316c7a5b69523e62">XMC_USIC_CH_INTERRUPT_NODE_POINTER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel interrupt node pointers </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga074b5b1abff43f98316c7a5b69523e62ac3d37f726e6214704f420586ff8effc3"></a>XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT&#160;</td><td class="fielddoc">
<p>Node pointer for transmit shift interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga074b5b1abff43f98316c7a5b69523e62a2298fc6a0fcee48a76f0aea1eb95e3a6"></a>XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER&#160;</td><td class="fielddoc">
<p>Node pointer for transmit buffer interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga074b5b1abff43f98316c7a5b69523e62acd626621eaea679896369d2f9c1b44c8"></a>XMC_USIC_CH_INTERRUPT_NODE_POINTER_RECEIVE&#160;</td><td class="fielddoc">
<p>Node pointer for receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga074b5b1abff43f98316c7a5b69523e62a9e0ff35d1ba446c2a1c9bff1b39e5740"></a>XMC_USIC_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE&#160;</td><td class="fielddoc">
<p>Node pointer for alternate receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga074b5b1abff43f98316c7a5b69523e62a3b99d0d6e93882ea791e8952cc993a7b"></a>XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL&#160;</td><td class="fielddoc">
<p>Node pointer for protocol related interrupts </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga27d9dafa74ddfc6aa6591e2f712eccfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga27d9dafa74ddfc6aa6591e2f712eccfe">XMC_USIC_CH_KERNEL_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel kernel mode </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga27d9dafa74ddfc6aa6591e2f712eccfea893e918851d8065d780e499435292378"></a>XMC_USIC_CH_KERNEL_MODE_RUN_0&#160;</td><td class="fielddoc">
<p>Run mode 0 (transmission and reception possible) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga27d9dafa74ddfc6aa6591e2f712eccfea779d6f7025d6d6bcd0dfdd709af0305e"></a>XMC_USIC_CH_KERNEL_MODE_RUN_1&#160;</td><td class="fielddoc">
<p>Run mode 1 (transmission and reception possible) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga27d9dafa74ddfc6aa6591e2f712eccfea24c6cfeac1bb9c05c16aa057e591b3c0"></a>XMC_USIC_CH_KERNEL_MODE_STOP_0&#160;</td><td class="fielddoc">
<p>Stop mode 0 (no transmission, but reception possible) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga27d9dafa74ddfc6aa6591e2f712eccfeab9105c0d985506f426ef2ff0a36983b6"></a>XMC_USIC_CH_KERNEL_MODE_STOP_1&#160;</td><td class="fielddoc">
<p>Stop mode 1 (both transmission and reception not possible) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gac052842418ff3dda00900219ebda5de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#gac052842418ff3dda00900219ebda5de7">XMC_USIC_CH_OPERATING_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel operating mode </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggac052842418ff3dda00900219ebda5de7a0f42d929665110fb0a00c7adbaf5a763"></a>XMC_USIC_CH_OPERATING_MODE_IDLE&#160;</td><td class="fielddoc">
<p>USIC channel idle </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac052842418ff3dda00900219ebda5de7a899e292213839edfb7d88e356cb9d18f"></a>XMC_USIC_CH_OPERATING_MODE_SPI&#160;</td><td class="fielddoc">
<p>SPI mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac052842418ff3dda00900219ebda5de7a0130416b257e28bf39a388658dd61469"></a>XMC_USIC_CH_OPERATING_MODE_UART&#160;</td><td class="fielddoc">
<p>UART mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac052842418ff3dda00900219ebda5de7a567f54d1a3c96472fca5d6039d5e3cbc"></a>XMC_USIC_CH_OPERATING_MODE_I2S&#160;</td><td class="fielddoc">
<p>I2S mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac052842418ff3dda00900219ebda5de7a4dad9ad4de2fe7406c1685606a651503"></a>XMC_USIC_CH_OPERATING_MODE_I2C&#160;</td><td class="fielddoc">
<p>I2C mode </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga0a55c03c810078ffc9fa8b512dc57e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga0a55c03c810078ffc9fa8b512dc57e37">XMC_USIC_CH_PARITY_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel parity mode </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga0a55c03c810078ffc9fa8b512dc57e37a41914c3176bcc9f17327bd7195dd39b6"></a>XMC_USIC_CH_PARITY_MODE_NONE&#160;</td><td class="fielddoc">
<p>Disable parity mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0a55c03c810078ffc9fa8b512dc57e37a1680b6d1bae664e1479de091cf8c61ea"></a>XMC_USIC_CH_PARITY_MODE_EVEN&#160;</td><td class="fielddoc">
<p>Enable even parity mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0a55c03c810078ffc9fa8b512dc57e37a59e6188e4d02d8d1ac50e8ade251093e"></a>XMC_USIC_CH_PARITY_MODE_ODD&#160;</td><td class="fielddoc">
<p>Enable odd parity mode </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga352121d35153623dc793f3b59c075eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga352121d35153623dc793f3b59c075eb0">XMC_USIC_CH_PASSIVE_DATA_LEVEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel output signal passive data level </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga352121d35153623dc793f3b59c075eb0a66effdf4e324ee2d69f90126db5fb21d"></a>XMC_USIC_CH_PASSIVE_DATA_LEVEL0&#160;</td><td class="fielddoc">
<p>Passive level(idle mode signal level) 0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga352121d35153623dc793f3b59c075eb0aaf5284d9c00837ad1a2caf6dd72315b5"></a>XMC_USIC_CH_PASSIVE_DATA_LEVEL1&#160;</td><td class="fielddoc">
<p>Passive level(idle mode signal level) 1 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9444afb3de969ce1ad5e7d413a9e0148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga9444afb3de969ce1ad5e7d413a9e0148">XMC_USIC_CH_RBUF_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel receive buffer status </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9444afb3de969ce1ad5e7d413a9e0148a65f600df2669714e1597f530144a011b"></a>XMC_USIC_CH_RBUF_STATUS_DATA_VALID0&#160;</td><td class="fielddoc">
<p>RBUF0 data has not yet been read out </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9444afb3de969ce1ad5e7d413a9e0148aa5bc9e75620be0519da1917345a4509e"></a>XMC_USIC_CH_RBUF_STATUS_DATA_VALID1&#160;</td><td class="fielddoc">
<p>RBUF1 data has not yet been read out </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4b8a7556ad13b0d7540a620c3d067689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga4b8a7556ad13b0d7540a620c3d067689">XMC_USIC_CH_RXFIFO_EVENT_CONF_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel receive FIFO event configuration </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4b8a7556ad13b0d7540a620c3d067689ac9ff6cf12767f7879611f5098732bd99"></a>XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD&#160;</td><td class="fielddoc">
<p>Enable FIFO standard receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4b8a7556ad13b0d7540a620c3d067689ae36c9608a19fddadd13a0dbeb6474709"></a>XMC_USIC_CH_RXFIFO_EVENT_CONF_ERROR&#160;</td><td class="fielddoc">
<p>Enable receive FIFO error interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4b8a7556ad13b0d7540a620c3d067689a48a5635b9e02bd166fe93bc2fa6304e6"></a>XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE&#160;</td><td class="fielddoc">
<p>Enable FIFO alternative receive interrupt </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9f69efc0352072596048eca6e3da29c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga9f69efc0352072596048eca6e3da29c6">XMC_USIC_CH_RXFIFO_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel receive FIFO status </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9f69efc0352072596048eca6e3da29c6a66c92990f46257208c42d175ccc3533c"></a>XMC_USIC_CH_RXFIFO_EVENT_STANDARD&#160;</td><td class="fielddoc">
<p>Receive FIFO status: Standard event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9f69efc0352072596048eca6e3da29c6a3bf2b90bd5dfa7a2fe3827225e9cda40"></a>XMC_USIC_CH_RXFIFO_EVENT_ERROR&#160;</td><td class="fielddoc">
<p>Receive FIFO status: Error event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9f69efc0352072596048eca6e3da29c6a01cc9c90a0e05d5fa537b76884e20d5c"></a>XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE&#160;</td><td class="fielddoc">
<p>Receive FIFO status: Alternative event </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4b1bb4e4041f310e46c635b007ee2c73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga4b1bb4e4041f310e46c635b007ee2c73">XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel receive FIFO interrupt node pointers </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4b1bb4e4041f310e46c635b007ee2c73a572414a4e5097bd3b8f6ca8b607e7c1e"></a>XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD&#160;</td><td class="fielddoc">
<p>Node pointer for FIFO standard receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4b1bb4e4041f310e46c635b007ee2c73a393b1acb8b60d2baebbc57ef8b64a718"></a>XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE&#160;</td><td class="fielddoc">
<p>Node pointer for FIFO alternative receive interrupt </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae2db2ec4c7c43ae1454373789443b793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#gae2db2ec4c7c43ae1454373789443b793">XMC_USIC_CH_START_TRANSMISION_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel data transmission start modes. Data shifted out of the transmit pin depends on the value configured for the TDEN bitfield of the TCSR register. Following enum values are used for configuring the TCSR-&gt;TDEN bitfield. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae2db2ec4c7c43ae1454373789443b793a92234bf742ccdef5a487ab9fc7b7b47e"></a>XMC_USIC_CH_START_TRANSMISION_DISABLED&#160;</td><td class="fielddoc">
<p>Passive data level is sent out on transmission. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae2db2ec4c7c43ae1454373789443b793a7464a12e43e762ae3809838ed60b0848"></a>XMC_USIC_CH_START_TRANSMISION_ON_TDV&#160;</td><td class="fielddoc">
<p>Transmission of the data word in TBUF can be started if TDV = 1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae2db2ec4c7c43ae1454373789443b793ad79ea1b2ea37a89eac8eec9905499589"></a>XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_0&#160;</td><td class="fielddoc">
<p>Transmission of the data word in TBUF can be started if TDV = 1 while DX2S_0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae2db2ec4c7c43ae1454373789443b793a21bcda749a5e1eda8108ce39f8b97b7a"></a>XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_1&#160;</td><td class="fielddoc">
<p>Transmission of the data word in TBUF can be started if TDV = 1 while DX2S_1 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf0ce1333656386f14f018b400beb9e39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#gaf0ce1333656386f14f018b400beb9e39">XMC_USIC_CH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel driver status </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf0ce1333656386f14f018b400beb9e39a7f5eeda6309c7b3a3e8f08380ed47e3c"></a>XMC_USIC_CH_STATUS_OK&#160;</td><td class="fielddoc">
<p>USIC driver status : OK </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf0ce1333656386f14f018b400beb9e39af9cf48d10eb977902d20eeaed491bcf0"></a>XMC_USIC_CH_STATUS_ERROR&#160;</td><td class="fielddoc">
<p>USIC driver status : ERROR </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf0ce1333656386f14f018b400beb9e39a512a392025bbc6a006aa9ad088919809"></a>XMC_USIC_CH_STATUS_BUSY&#160;</td><td class="fielddoc">
<p>USIC driver status : BUSY </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga46769f2474ad4be950bcfc47582f5f87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga46769f2474ad4be950bcfc47582f5f87">XMC_USIC_CH_TBUF_STATUS_SET_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel data transmit buffer status modification </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga46769f2474ad4be950bcfc47582f5f87a8d5a660f1632c9201fc8360b5580d2cf"></a>XMC_USIC_CH_TBUF_STATUS_SET_BUSY&#160;</td><td class="fielddoc">
<p>Set Transfer buffer status to busy </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga46769f2474ad4be950bcfc47582f5f87a2b4f44bf752d0b8913f2fa99cc5c28e6"></a>XMC_USIC_CH_TBUF_STATUS_SET_IDLE&#160;</td><td class="fielddoc">
<p>Set Transfer buffer status to idle </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga1139d992c4767497e1ead00f098d7024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga1139d992c4767497e1ead00f098d7024">XMC_USIC_CH_TBUF_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel data transmit buffer status </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1139d992c4767497e1ead00f098d7024ad797491e36963500982f41247c0edb75"></a>XMC_USIC_CH_TBUF_STATUS_IDLE&#160;</td><td class="fielddoc">
<p>Transfer buffer is currently idle </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1139d992c4767497e1ead00f098d7024ab228b9efcdbf98d83e2e6521883460b5"></a>XMC_USIC_CH_TBUF_STATUS_BUSY&#160;</td><td class="fielddoc">
<p>Transfer buffer is currently busy </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gac7690c669fbca7c9710ba7294df39a6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#gac7690c669fbca7c9710ba7294df39a6d">XMC_USIC_CH_TXFIFO_EVENT_CONF_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel transmit FIFO event configuration </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggac7690c669fbca7c9710ba7294df39a6da7c276cdb2192352c70a55dbff71fdb83"></a>XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD&#160;</td><td class="fielddoc">
<p>Enable FIFO standard transmit interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac7690c669fbca7c9710ba7294df39a6da3b3243be368a3fe2293e1a8669755c37"></a>XMC_USIC_CH_TXFIFO_EVENT_CONF_ERROR&#160;</td><td class="fielddoc">
<p>Enable transmit FIFO error interrupt </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga6e964201594d82a691896a52cbfd5620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#ga6e964201594d82a691896a52cbfd5620">XMC_USIC_CH_TXFIFO_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel transmit FIFO status </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6e964201594d82a691896a52cbfd5620a1e44a086ab5e16b5832160e1ce085eac"></a>XMC_USIC_CH_TXFIFO_EVENT_STANDARD&#160;</td><td class="fielddoc">
<p>Transmit FIFO status: Standard event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6e964201594d82a691896a52cbfd5620a309215a549219964d0d04ebcc22f6e33"></a>XMC_USIC_CH_TXFIFO_EVENT_ERROR&#160;</td><td class="fielddoc">
<p>Transmit FIFO status: Error event </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaed66b290b2c45854fcd04580fb6349a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_i_c.html#gaed66b290b2c45854fcd04580fb6349a1">XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC channel transmit FIFO interrupt node pointers </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaed66b290b2c45854fcd04580fb6349a1a5f3f135726f0f39eb99ab43cfdf699cf"></a>XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD&#160;</td><td class="fielddoc">
<p>Node pointer for FIFO standard transmit interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaed66b290b2c45854fcd04580fb6349a1aef96e8370ec2178615f3a24a04da19fe"></a>XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE&#160;</td><td class="fielddoc">
<p>Node pointer for transmit FIFO error interrupt </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Dokumentation der Funktionen</h2>
<a class="anchor" id="ga00c6419dfc0f8ed4c4eab13ded598144"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_ConfigExternalInputSignalToBRG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>pdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>oversampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga4c50ae5a7f12a5496d82d2bc665e1db2">XMC_USIC_CH_INPUT_COMBINATION_MODE_t</a>&#160;</td>
          <td class="paramname"><em>combination_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">pdiv</td><td>Desired divider for the external frequency input. <b>Range:</b> minimum value = 1, maximum value = 1024 <br />
</td></tr>
    <tr><td class="paramname">oversampling</td><td>Required oversampling. The value indicates the number of time quanta for one symbol of data. <br />
 This can be related to the number of samples for each logic state of the data signal. <br />
 <b>Range:</b> 1 to 32. Value should be chosen based on the protocol used. </td></tr>
    <tr><td class="paramname">combination_mode</td><td>Selects which edge of the synchronized(and optionally filtered) signal DXnS actives the trigger output DXnT of the input stage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the external frequency input for the Baudrate Generator and configures the divider, oversampling and the combination mode of the USIC channel. <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga2876a325930da4b77ef46ec4e0acda0d">XMC_USIC_CH_SetBRGInputClockSource()</a>, <a class="el" href="group___u_s_i_c.html#gaeef58e03c1253fce5b8a456f5d8c6da6">XMC_USIC_CH_SetInputTriggerCombinationMode()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga63149dd65f853cc69ed57add87f34627">XMC_I2C_CH_ConfigExternalInputSignalToBRG()</a>, <a class="el" href="group___s_p_i.html#gac19e7d5bf3ff9b28764463d224b6e581">XMC_SPI_CH_ConfigExternalInputSignalToBRG()</a> und <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="gaba9a2e95af4e455dddd73f324577c876"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_ConfigureShiftClockOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#gaabdebf7dc81a008ca887ab0336f9b3de">XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t</a>&#160;</td>
          <td class="paramname"><em>passive_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga373c90ba61a8cc0013f395840bc9acfd">XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a>&#160;</td>
          <td class="paramname"><em>clock_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">passive_level</td><td>Passive level for the clock output. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggaabdebf7dc81a008ca887ab0336f9b3dea73b5e738a2fbe968b46ea6aae3466956">XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_DISABLED</a>, <a class="el" href="group___u_s_i_c.html#ggaabdebf7dc81a008ca887ab0336f9b3deabb31d132a979405f51e7a6ab44071f46">XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_ENABLED</a>, <a class="el" href="group___u_s_i_c.html#ggaabdebf7dc81a008ca887ab0336f9b3deaf4a7841504a26dfd70873f1962f5ba89">XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED</a>, <a class="el" href="group___u_s_i_c.html#ggaabdebf7dc81a008ca887ab0336f9b3deac496300b9f7d9f340bed2bf4dfb1b8d6">XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_ENABLED</a>, </td></tr>
    <tr><td class="paramname">clock_output</td><td>Shift clock source selection. <br />
 <b>Range:</b> Use <a class="el" href="group___u_s_i_c.html#gga373c90ba61a8cc0013f395840bc9acfda9491b02e6b95460911ccdbfd916dd28f">XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK</a>, <a class="el" href="group___u_s_i_c.html#gga373c90ba61a8cc0013f395840bc9acfdabcd84dcb72da7b117900df0eb5c43660">XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_DX1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the idle mode shift clock output level and selects the shift clock source. <br />
<br />
Shift clock idle mode output level can be set to logic high or low. Shift clock output can be configured to have a delay of half shift clock period. Both the configurations are available as enumeration values defined with type <a class="el" href="group___u_s_i_c.html#gaabdebf7dc81a008ca887ab0336f9b3de">XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t</a>. This value should be configured based on the slave device requirement. Shift clock source can be selected between internal clock(master) and external input(slave). </dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a60442d8bed2e194af31a7bedbabf0c16">XMC_USIC_CH_t::BRG</a>.</p>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga791fd46fa82e2c4a87eca3ff2e543813">XMC_I2S_CH_ConfigureShiftClockOutput()</a> und <a class="el" href="group___s_p_i.html#gadaf15fe97c6fc0b78ac661e923521ee3">XMC_SPI_CH_ConfigureShiftClockOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="ga61291bfe08ea6012739d90d7524fa1bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_ConnectInputDataShiftToDataInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>The input of the data shift unit is connected to the selected data input line. <br />
<br />
 This setting is used if the signals are directly derived from an input pin without treatment by the protocol preprocessor. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga1c5aabc85e73a242eea72dd6838ee3e5">XMC_USIC_CH_ConnectInputDataShiftToPPP()</a><br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for INSW bitfield mask in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a> und <a class="el" href="group___u_s_i_c.html#ga9e60cb55d2c3135d5e1fcd317b0bcdbe">USIC_CH_DXCR_INSW_Msk</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c5aabc85e73a242eea72dd6838ee3e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_ConnectInputDataShiftToPPP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>The input of the data shift unit is controlled by the protocol pre-processor. <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga61291bfe08ea6012739d90d7524fa1bd">XMC_USIC_CH_ConnectInputDataShiftToDataInput()</a><br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for INSW bitfield mask in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a> und <a class="el" href="group___u_s_i_c.html#ga9e60cb55d2c3135d5e1fcd317b0bcdbe">USIC_CH_DXCR_INSW_Msk</a>.</p>

</div>
</div>
<a class="anchor" id="gaaba8dc6e2fe4c5cf3fd3418d532a9412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the USIC channel.<br />
<br />
USIC channel is disabled by setting the module enable bit(MDEN) to 0 in the register KSCFG.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga0567321036170adb335fef9b36dc3b71">XMC_USIC_CH_Enable()</a>, <a class="el" href="group___u_s_i_c.html#ga5d7f987aa7be2cc8497a0895f2ba3f90">XMC_USIC_Disable()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9896966f6e2e6109f8a7ca0de03d0b39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_DisableDelayCompensation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables delay compensation.. <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga1eaad0f90219fa9bb43bfdf932ea2451">XMC_USIC_CH_EnableDelayCompensation()</a><br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a>.</p>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#gac731fe4fbd6e50a8e0b0a8819d30ed56">XMC_I2S_CH_DisableDelayCompensation()</a> und <a class="el" href="group___s_p_i.html#gac0b5cdd04a90124e347ba3ef897dc545">XMC_SPI_CH_DisableDelayCompensation()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2520619d1b8420b50501c24b2155c02a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Bit mask of the channel events to be disabled. Use <a class="el" href="group___u_s_i_c.html#ga9101f93a9a9c4c5a27f1418e3335b012">XMC_USIC_CH_EVENT_t</a> for the bit masks. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga9101f93a9a9c4c5a27f1418e3335b012ab27889da7076d1a9ab4e249b19b71cb1">XMC_USIC_CH_EVENT_RECEIVE_START</a>, <a class="el" href="group___u_s_i_c.html#gga9101f93a9a9c4c5a27f1418e3335b012a948a392bad3aca7de34a4acfd2b5eb7e">XMC_USIC_CH_EVENT_DATA_LOST</a> etc. Multiple events can be combined using <em>OR</em> operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disable the channel interrupt events. <br />
<br />
Multiple events can be combined using the bitwise OR operation and configured in one function call. XMC_USIC_CH_EVENT_t enumerates multiple protocol event bitmasks. These enumerations can be used as input to the API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga6f9467a0f290d65f7292b45cc29e32b4">XMC_USIC_CH_EnableEvent()</a>, <a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a5e1322e27c40bf91d172f9673f205c97">XMC_USIC_CH_t::CCR</a> und <a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga923439c666ca95a5d7907c920891c111"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_DisableFrameLengthControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables automatic update of frame length. <br />
<br />
When automatic update of frame length is disabled, frame length has to configured explicitly. Frame length remains fixed until it is changed again.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga923439c666ca95a5d7907c920891c111">XMC_USIC_CH_DisableFrameLengthControl()</a>, <a class="el" href="group___u_s_i_c.html#ga23964f6d982b35388f3a7c82f5634e0f">XMC_USIC_CH_SetFrameLength()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1db3c5e7fe198de01001e0ee43dd4fef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_DisableInputDigitalFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the input digital filter for USIC channel input data signal. <br />
<br />
Input data signal from the selected multiplexer will not be digitally filtered.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga6a776750022b67a7d4075fb06eac39dc">XMC_USIC_CH_EnableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for DFEN bitfield mask in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a> und <a class="el" href="group___u_s_i_c.html#gacd79dd61fa38db0bc2a735c9c2d7e272">USIC_CH_DXCR_DFEN_Msk</a>.</p>

<p>Wird benutzt von <a class="el" href="group___u_a_r_t.html#gaef225ec3a0bc7db11ddf0b4f260a905c">XMC_UART_CH_DisableInputDigitalFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa018c766c173f43dbdba8c821a90a645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_DisableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables input inversion for USIC channel. <br />
<br />
 Resets the input data polarity for the USIC channel input data signal. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gae13b2003ea4d8703a9990d1e90048dc3">XMC_USIC_CH_EnableInputInversion()</a><br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for DPOL bitfield mask in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a> und <a class="el" href="group___u_s_i_c.html#gafe4d28d8e09425ff5fd0f2c98ea85e1b">USIC_CH_DXCR_DPOL_Msk</a>.</p>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#gad442af0346273424ef742ccd3abe40dd">XMC_I2S_CH_DisableInputInversion()</a>, <a class="el" href="group___s_p_i.html#gadf00d5c823846ca5c13f627baa541663">XMC_SPI_CH_DisableInputInversion()</a> und <a class="el" href="group___u_a_r_t.html#gafd566960d84740ec0c0713197839b071">XMC_UART_CH_DisableInputInversion()</a>.</p>

</div>
</div>
<a class="anchor" id="gaad85027beef2c0cf3dd897e889acf939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_DisableInputSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables input synchronization for the USIC channel input data signal. <br />
<br />
Input data signal from the selected multiplexer will not be synchronized.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga1a5edb9ab8796da1f86be687fab65f32">XMC_USIC_CH_EnableInputSync()</a>, <a class="el" href="group___u_s_i_c.html#ga1db3c5e7fe198de01001e0ee43dd4fef">XMC_USIC_CH_DisableInputDigitalFilter()</a> <br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for DSEN bitfield mask in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a> und <a class="el" href="group___u_s_i_c.html#gaf00a9eaab71452bf3b16b78aa080cb25">USIC_CH_DXCR_DSEN_Msk</a>.</p>

<p>Wird benutzt von <a class="el" href="group___u_a_r_t.html#ga655549975b9c7dce3fb9f28c89b5685f">XMC_UART_CH_DisableInputSync()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4227196c29ecd683240b968aa54b7758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_DisableTBUFDataValidTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the trigger of TDV depending on DX2T signal. <br />
<br />
Bit TCSR.TE is permanently set.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga7e8a1fa11993aedfd8d9fb1bf6daf36c">XMC_USIC_CH_EnableTBUFDataValidTrigger()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gae5a5bbfcfa061c76a12505e4183d832d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_DisableTimeMeasurement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables time measurement using the capture mode timer. <br />
<br />
Time measurement is disabled by clearing the timer enable flag in BRG register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gadb5f590b8867d286b7a9f4e52fd3a6a9">XMC_USIC_CH_EnableTimeMeasurement()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a60442d8bed2e194af31a7bedbabf0c16">XMC_USIC_CH_t::BRG</a>.</p>

</div>
</div>
<a class="anchor" id="ga0567321036170adb335fef9b36dc3b71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the USIC channel. <br />
<br />
USIC channel is enabled by setting the module enable bit in KSCFG register bitfield MODEN. On enabling, the channel is set to idle mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gaaba8dc6e2fe4c5cf3fd3418d532a9412">XMC_USIC_CH_Disable()</a>, <a class="el" href="group___u_s_i_c.html#ga48113f030b655f6eaa3b9f6b73474785">XMC_USIC_Enable()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1eaad0f90219fa9bb43bfdf932ea2451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_EnableDelayCompensation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables delay compensation. <br />
<br />
 Delay compensation can be applied to the receive path. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga9896966f6e2e6109f8a7ca0de03d0b39">XMC_USIC_CH_DisableDelayCompensation()</a><br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a>.</p>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga6484a12dcff80b2055d1b986e8cba28d">XMC_I2S_CH_EnableDelayCompensation()</a> und <a class="el" href="group___s_p_i.html#gab1fb0a57f619c0d1872482196399a443">XMC_SPI_CH_EnableDelayCompensation()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f9467a0f290d65f7292b45cc29e32b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Bit mask of the channel events to be enabled. Use <a class="el" href="group___u_s_i_c.html#ga9101f93a9a9c4c5a27f1418e3335b012">XMC_USIC_CH_EVENT_t</a> for the bit masks. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga9101f93a9a9c4c5a27f1418e3335b012ab27889da7076d1a9ab4e249b19b71cb1">XMC_USIC_CH_EVENT_RECEIVE_START</a>, <a class="el" href="group___u_s_i_c.html#gga9101f93a9a9c4c5a27f1418e3335b012a948a392bad3aca7de34a4acfd2b5eb7e">XMC_USIC_CH_EVENT_DATA_LOST</a> etc. Multiple events can be combined using <em>OR</em> operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enable the channel interrupt events.<br />
<br />
Common channel events related to serial communication can be configured using this API. Multiple events can be combined using the bitwise OR operation and configured in one function call. XMC_USIC_CH_EVENT_t enumerates multiple protocol event bitmasks. These enumerations can be used as input to the API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga2520619d1b8420b50501c24b2155c02a">XMC_USIC_CH_DisableEvent()</a>, <a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a5e1322e27c40bf91d172f9673f205c97">XMC_USIC_CH_t::CCR</a>.</p>

</div>
</div>
<a class="anchor" id="gaf1d2b03bb1350dfc628f0bfa9fb6ffb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_EnableFrameLengthControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables automatic update of frame length. <br />
<br />
When the automatic update of frame length is enabled, frame length is configured based on the index of the TBUF[]/IN[] register array. When the data is written to TBUF[x], frame length is configured with the mask value of <em>x</em> at the last 5 bit positions. Same logic is applicable if data is written to IN[x] register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga923439c666ca95a5d7907c920891c111">XMC_USIC_CH_DisableFrameLengthControl()</a>, <a class="el" href="group___u_s_i_c.html#ga0f14560e863b15c6bd123e534332e9f5">XMC_USIC_CH_TXFIFO_PutDataFLEMode()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6a776750022b67a7d4075fb06eac39dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_EnableInputDigitalFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the input digital filter for USIC channel input data signal. <br />
<br />
Input data signal from the selected multiplexer will be digitally filtered.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga1db3c5e7fe198de01001e0ee43dd4fef">XMC_USIC_CH_DisableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for DFEN bitfield mask in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a> und <a class="el" href="group___u_s_i_c.html#gacd79dd61fa38db0bc2a735c9c2d7e272">USIC_CH_DXCR_DFEN_Msk</a>.</p>

<p>Wird benutzt von <a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="gae13b2003ea4d8703a9990d1e90048dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_EnableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables input inversion for USIC channel input data signal. <br />
<br />
 Polarity of the input source can be changed to provide inverted data input. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gaa018c766c173f43dbdba8c821a90a645">XMC_USIC_CH_DisableInputInversion()</a><br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for DPOL bitfield mask in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a> und <a class="el" href="group___u_s_i_c.html#gafe4d28d8e09425ff5fd0f2c98ea85e1b">USIC_CH_DXCR_DPOL_Msk</a>.</p>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga3cfdd666f14a7897c24a7e79660179b5">XMC_I2S_CH_EnableInputInversion()</a>, <a class="el" href="group___s_p_i.html#ga68c629a48d4d82c08c1017a9c822deeb">XMC_SPI_CH_EnableInputInversion()</a> und <a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1a5edb9ab8796da1f86be687fab65f32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_EnableInputSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables input synchronization for the USIC channel input data signal. <br />
<br />
Input data signal from the selected multiplexer will be synchronized with fPERIPH. A noisy signal can be synchronized and filtered by enabling the digital filter.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gaad85027beef2c0cf3dd897e889acf939">XMC_USIC_CH_DisableInputSync()</a>, <a class="el" href="group___u_s_i_c.html#ga6a776750022b67a7d4075fb06eac39dc">XMC_USIC_CH_EnableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for DSEN bitfield mask in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a> und <a class="el" href="group___u_s_i_c.html#gaf00a9eaab71452bf3b16b78aa080cb25">USIC_CH_DXCR_DSEN_Msk</a>.</p>

<p>Wird benutzt von <a class="el" href="group___u_a_r_t.html#ga52aa3807f291f58be66b4d946aec7d47">XMC_UART_CH_EnableInputSync()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e8a1fa11993aedfd8d9fb1bf6daf36c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_EnableTBUFDataValidTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Bit TCSR.TE is set if DX2T becomes active while TDV = 1. <br />
<br />
Enables the transfer trigger unit to set bit TCSR.TE if the trigger signal DX2T becomes active for event driven transfer starts.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga4227196c29ecd683240b968aa54b7758">XMC_USIC_CH_DisableTBUFDataValidTrigger()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gadb5f590b8867d286b7a9f4e52fd3a6a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_EnableTimeMeasurement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables time measurement using the capture mode timer. <br />
<br />
Time measurement is enabled by setting the timer enable flag in BRG register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gae5a5bbfcfa061c76a12505e4183d832d">XMC_USIC_CH_DisableTimeMeasurement()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a60442d8bed2e194af31a7bedbabf0c16">XMC_USIC_CH_t::BRG</a>.</p>

</div>
</div>
<a class="anchor" id="ga6987b85c22a6f6e220042e07f255ca7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_USIC_CH_GetReceiveBufferStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get receive buffer status. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Status of data validity check for RBUF0 and RBUF1. <br />
 Returned value should be masked with RDV0 and RDV1 bits to know the status. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga9444afb3de969ce1ad5e7d413a9e0148a65f600df2669714e1597f530144a011b">XMC_USIC_CH_RBUF_STATUS_DATA_VALID0</a>, <a class="el" href="group___u_s_i_c.html#gga9444afb3de969ce1ad5e7d413a9e0148aa5bc9e75620be0519da1917345a4509e">XMC_USIC_CH_RBUF_STATUS_DATA_VALID1</a>.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks if RBUF0 and RBUF1 have valid unread data. <br />
<br />
It checks the bits RDV0 and RDV1 of the RBUFSR register. Returns the value of RBUFSR masked with bitmasks of RDV0 and RDV1. It can be used to decide whether 2bytes has to be read from RBUF or 1 byte. If both bitmasks XMC_USIC_CH_RBUF_STATUS_DATA_VALID0 and XMC_USIC_CH_RBUF_STATUS_DATA_VALID1 are set, then 2 bytes can be read from RBUF. If only either of them is set, then only one byte can be read from RBUF. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a53e4f754cd62e00d1aec53dd408336c6">XMC_USIC_CH_t::RBUFSR</a>.</p>

</div>
</div>
<a class="anchor" id="ga091c9637a98727f1dce0d159764aea24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_i_c.html#ga1139d992c4767497e1ead00f098d7024">XMC_USIC_CH_TBUF_STATUS_t</a> XMC_USIC_CH_GetTransmitBufferStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Stataus <a class="el" href="group___u_s_i_c.html#gga1139d992c4767497e1ead00f098d7024ad797491e36963500982f41247c0edb75">XMC_USIC_CH_TBUF_STATUS_IDLE</a> if transmit buffer is free, <a class="el" href="group___u_s_i_c.html#gga1139d992c4767497e1ead00f098d7024ab228b9efcdbf98d83e2e6521883460b5">XMC_USIC_CH_TBUF_STATUS_BUSY</a> if transmit buffer is busy.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Gets transmit buffer status. <br />
<br />
Status indicates whether the transmit buffer is free, or busy transmitting data. The status depends on the value of TDV flag in TCSR register. This status can be used while transmitting data. Transmit data when the transmit buffer status is <a class="el" href="group___u_s_i_c.html#gga1139d992c4767497e1ead00f098d7024ad797491e36963500982f41247c0edb75">XMC_USIC_CH_TBUF_STATUS_IDLE</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga920a20a26fbff1aaeb240af921f61ce4">XMC_USIC_CH_SetDataOutputMode()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga92f2d42836e73b8a200c437e69611474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_RXFIFO_ClearEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Receive FIFO events to be cleared. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga9f69efc0352072596048eca6e3da29c6a66c92990f46257208c42d175ccc3533c">XMC_USIC_CH_RXFIFO_EVENT_STANDARD</a>, <a class="el" href="group___u_s_i_c.html#gga9f69efc0352072596048eca6e3da29c6a3bf2b90bd5dfa7a2fe3827225e9cda40">XMC_USIC_CH_RXFIFO_EVENT_ERROR</a>, <a class="el" href="group___u_s_i_c.html#gga9f69efc0352072596048eca6e3da29c6a01cc9c90a0e05d5fa537b76884e20d5c">XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the receive FIFO event flags in the status register. <br />
<br />
USIC channel peripheral does not clear the event flags after they are read. This API clears the events provided in the <em>mask</em> value. XMC_USIC_CH_RXFIFO_EVENT enumeration can be used as input. Multiple events can be cleared by providing a mask value obtained by bitwise OR operation of multiple event enumerations.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga674dcaba8a7a575983ab61b27a580b2d">XMC_USIC_CH_RXFIFO_GetEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#aa4ebd1cc49417ade270040dd5ae90a76">XMC_USIC_CH_t::TRBSCR</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ba419dd17bdb7e7be5f5ca757910a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_RXFIFO_Configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>data_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#gafdd0a07bee93d72936191b7e8555aefe">XMC_USIC_CH_FIFO_SIZE_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">data_pointer</td><td>Start position inside the FIFO buffer. <br />
 <b>Range:</b> 0 to 63. </td></tr>
    <tr><td class="paramname">size</td><td>Required size of the receive FIFO. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefea1c189be4c15d2176b740037fa220e4a4">XMC_USIC_CH_FIFO_DISABLED</a>, <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefeac2b3558621719f1d4e64d55a0febb166">XMC_USIC_CH_FIFO_SIZE_2WORDS</a>.. <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefead702883ad36b39b6014e45b31f1655e8">XMC_USIC_CH_FIFO_SIZE_64WORDS</a> </td></tr>
    <tr><td class="paramname">limit</td><td>Threshold of receive FIFO filling level to be considered for generating events. <br />
 <b>Range:</b> 0 to <em>size</em> -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the receive FIFO. <br />
<br />
Receive FIFO is the subset of a common FIFO sized 64 words. This FIFO is shared between 2 channels of the USIC module. Each channel can share the FIFO for transmission and reception. <em>data_pointer</em> represents the start index in the common FIFO, from where received data can be put. <em>size</em> represents the size of receive FIFO as a multiple of 2. Since the FIFO is shared between 2 USIC channels, FIFO size should be carefully selected. A FIFO standard receive buffer event or alternative receive buffer event is generated when the FIFO filling level exceeds the <em>limit</em> value.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gad4cdb767e1ac3a256b1335a19d2c33ad">XMC_USIC_CH_RXFIFO_EnableEvent()</a>, <a class="el" href="group___u_s_i_c.html#ga0cce6b36f9c5fc6b9487dcee14a04e1a">XMC_USIC_CH_RXFIFO_SetInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#gaf6c7228b9e6c44332c077acf720f12b9">XMC_USIC_CH_TXFIFO_ClearEvent()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf5f963f40c8ab670bffe6ce88cdf462d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_RXFIFO_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Events to be disabled. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga4b8a7556ad13b0d7540a620c3d067689ac9ff6cf12767f7879611f5098732bd99">XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD</a>, <a class="el" href="group___u_s_i_c.html#gga4b8a7556ad13b0d7540a620c3d067689ae36c9608a19fddadd13a0dbeb6474709">XMC_USIC_CH_RXFIFO_EVENT_CONF_ERROR</a>, <a class="el" href="group___u_s_i_c.html#gga4b8a7556ad13b0d7540a620c3d067689a48a5635b9e02bd166fe93bc2fa6304e6">XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the selected interrupt events related to receive FIFO. <br />
<br />
By disabling the interrupt events, generation of interrupt is stopped. User can poll the event flags from the status register using the API <a class="el" href="group___u_s_i_c.html#ga674dcaba8a7a575983ab61b27a580b2d">XMC_USIC_CH_RXFIFO_GetEvent()</a>. Event bitmasks can be constructed using the enumeration <em>XMC_USIC_CH_RXFIFO_EVENT_CONF</em>. For providing multiple events, combine the events using bitwise OR operation.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga674dcaba8a7a575983ab61b27a580b2d">XMC_USIC_CH_RXFIFO_GetEvent()</a>, <a class="el" href="group___u_s_i_c.html#gad4cdb767e1ac3a256b1335a19d2c33ad">XMC_USIC_CH_RXFIFO_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a85045a6d4b52fe95abdb1aa23479f348">XMC_USIC_CH_t::RBCTR</a> und <a class="el" href="group___u_s_i_c.html#ga0cce6b36f9c5fc6b9487dcee14a04e1a">XMC_USIC_CH_RXFIFO_SetInterruptNodePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="gad4cdb767e1ac3a256b1335a19d2c33ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_RXFIFO_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Events to be enabled. Multiple events can be bitwise OR combined. <a class="el" href="group___u_s_i_c.html#ga4b8a7556ad13b0d7540a620c3d067689">XMC_USIC_CH_RXFIFO_EVENT_CONF_t</a><br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the interrupt events related to transmit FIFO. <br />
<br />
Event bitmasks can be constructed using the enumeration <a class="el" href="group___u_s_i_c.html#ga4b8a7556ad13b0d7540a620c3d067689">XMC_USIC_CH_RXFIFO_EVENT_CONF_t</a>. Multiple events can be enabled by providing multiple events in a single call. For providing multiple events, combine the events using bitwise OR operation.<br />
</dd></dl>
<p>Note: API only enables the events. For interrupt generation, interrupt node must be configured and NVIC node must be enabled.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga0cce6b36f9c5fc6b9487dcee14a04e1a">XMC_USIC_CH_RXFIFO_SetInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a85045a6d4b52fe95abdb1aa23479f348">XMC_USIC_CH_t::RBCTR</a>.</p>

</div>
</div>
<a class="anchor" id="gab8a59ec35554be7dbf41778888d2b69f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_RXFIFO_Flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the contents of receive FIFO. <br />
<br />
Receive FIFO contents will be cleared and the filling level will be reset to 0.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gac69592a81e495b0adf515547a0e8037e">XMC_USIC_CH_RXFIFO_GetLevel()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#aa4ebd1cc49417ade270040dd5ae90a76">XMC_USIC_CH_t::TRBSCR</a>.</p>

</div>
</div>
<a class="anchor" id="ga661b9482d7cc6b983f178bb6a30a5c76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_USIC_CH_RXFIFO_GetData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Value read from the receive FIFO. <br />
 <b>Range:</b> 16bit data. Length of data depends on the word length configuration.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Gets data from the receive FIFO. <br />
<br />
Receive FIFO should be read only if data is availble in the FIFO. This can be checked using the API <a class="el" href="group___u_s_i_c.html#gaa81c3a8fab62930c291910628a08f575">XMC_USIC_CH_RXFIFO_IsEmpty()</a>. Receive FIFO error flag will be set if an attempt is made to read from an empty receive FIFO. To read all the received data, user should keep reading data until receive FIFO is empty.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga92f2d42836e73b8a200c437e69611474">XMC_USIC_CH_RXFIFO_ClearEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#ae703f8c37a21dd534cac2e0aedf8359f">XMC_USIC_CH_t::OUTR</a>.</p>

</div>
</div>
<a class="anchor" id="ga674dcaba8a7a575983ab61b27a580b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_USIC_CH_RXFIFO_GetEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Status of standard receive buffer, alternative receive buffer and receive buffer error events. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga9f69efc0352072596048eca6e3da29c6a66c92990f46257208c42d175ccc3533c">XMC_USIC_CH_RXFIFO_EVENT_STANDARD</a>, <a class="el" href="group___u_s_i_c.html#gga9f69efc0352072596048eca6e3da29c6a3bf2b90bd5dfa7a2fe3827225e9cda40">XMC_USIC_CH_RXFIFO_EVENT_ERROR</a>, <a class="el" href="group___u_s_i_c.html#gga9f69efc0352072596048eca6e3da29c6a01cc9c90a0e05d5fa537b76884e20d5c">XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE</a>.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Gets the receive FIFO events' status. <br />
<br />
Gives the status of receive FIFO standard receive buffer event, alternative receive buffer event and receive buffer error event. The status bits are located at their bitpositions in the TRBSR register in the returned value. User can make use of the XMC_USIC_CH_RXFIFO_EVENT enumeration for checking the status of return value. The status can be found by using the bitwise AND operation on the returned value with the enumerated value.<br />
</dd></dl>
<p>Note: Event status flags should be cleared by the user explicitly.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga92f2d42836e73b8a200c437e69611474">XMC_USIC_CH_RXFIFO_ClearEvent()</a><br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a9c79cb9e505b1157be614ba619b3d545">XMC_USIC_CH_t::TRBSR</a>.</p>

</div>
</div>
<a class="anchor" id="gac69592a81e495b0adf515547a0e8037e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_USIC_CH_RXFIFO_GetLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Receive FIFO filling level. <br />
 <b>Range:</b> minimum= 0(FIFO empty), maximum= receive FIFO size.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Gets the receive FIFO filling level. <br />
<br />
For every word received, the filling level is incremented. The API gives the value of this filling level. The filling level is decremented when the data is read out of the receive FIFO.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gab8a59ec35554be7dbf41778888d2b69f">XMC_USIC_CH_RXFIFO_Flush()</a>, XMC_USIC_CH_RXFIFO_PutData() <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a9c79cb9e505b1157be614ba619b3d545">XMC_USIC_CH_t::TRBSR</a>.</p>

</div>
</div>
<a class="anchor" id="gaa81c3a8fab62930c291910628a08f575"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_USIC_CH_RXFIFO_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Status <em>true</em> if receive FIFO is empty, <em>false</em> if receive FIFO has some data.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks if receive FIFO is empty. <br />
<br />
When the receive FIFO is empty, received data will be put in receive FIFO. When the last received word in the FIFO is read, FIFO empty flag is set. Any attempt to read from an empty receive FIFO will set the receive FIFO error flag.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gab8a59ec35554be7dbf41778888d2b69f">XMC_USIC_CH_RXFIFO_Flush()</a>, XMC_USIC_CH_RXFIFO_PutData() <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a9c79cb9e505b1157be614ba619b3d545">XMC_USIC_CH_t::TRBSR</a>.</p>

</div>
</div>
<a class="anchor" id="ga23338f848d35ee56a38af652e4a9db6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_USIC_CH_RXFIFO_IsFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Status <em>true</em> if receive FIFO is full <em>false</em> if receive FIFO is not full.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks if receive FIFO is full. <br />
<br />
When the receive FIFO filling level reaches the configured size, FIFO full flag is set. Any data received when the receive FIFO is full, is lost.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gaa81c3a8fab62930c291910628a08f575">XMC_USIC_CH_RXFIFO_IsEmpty()</a>, <a class="el" href="group___u_s_i_c.html#gab8a59ec35554be7dbf41778888d2b69f">XMC_USIC_CH_RXFIFO_Flush()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a9c79cb9e505b1157be614ba619b3d545">XMC_USIC_CH_t::TRBSR</a>.</p>

</div>
</div>
<a class="anchor" id="ga0cce6b36f9c5fc6b9487dcee14a04e1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga4b1bb4e4041f310e46c635b007ee2c73">XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t</a>&#160;</td>
          <td class="paramname"><em>interrupt_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">interrupt_node</td><td>Node pointer representing the receive FIFO events. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga4b1bb4e4041f310e46c635b007ee2c73a572414a4e5097bd3b8f6ca8b607e7c1e">XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD</a>, <a class="el" href="group___u_s_i_c.html#gga4b1bb4e4041f310e46c635b007ee2c73a393b1acb8b60d2baebbc57ef8b64a718">XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE</a> </td></tr>
    <tr><td class="paramname">service_request</td><td>The service request to be used for interrupt generation.<br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets an interrupt node for the receive FIFO events. <br />
<br />
A node pointer represents one or more interrupt events. Service request represents the interrupt node to be used among the 6 interrupt nodes available for USIC module. API configures the service request to be used for interrupt generation for the events selected. A receive FIFO event can generate an interrupt only if the interrupt node is configured for the event and the interrupt generation is enabled for the event. For example, transmit FIFO standard transmit buffer interrupt is generated if the interrupt node for the same is set and interrupt is enabled.<br />
</dd></dl>
<p>Note: NVIC node should be explicitly enabled for the interrupt generation.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gad4cdb767e1ac3a256b1335a19d2c33ad">XMC_USIC_CH_RXFIFO_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#gaf5f963f40c8ab670bffe6ce88cdf462d">XMC_USIC_CH_RXFIFO_DisableEvent()</a>.</p>

</div>
</div>
<a class="anchor" id="gae9984f496fe787c05b84dc6d1d65ee2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#gafdd0a07bee93d72936191b7e8555aefe">XMC_USIC_CH_FIFO_SIZE_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">size</td><td>Required size of the receive FIFO. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefea1c189be4c15d2176b740037fa220e4a4">XMC_USIC_CH_FIFO_DISABLED</a>, <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefeac2b3558621719f1d4e64d55a0febb166">XMC_USIC_CH_FIFO_SIZE_2WORDS</a>.. <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefead702883ad36b39b6014e45b31f1655e8">XMC_USIC_CH_FIFO_SIZE_64WORDS</a> </td></tr>
    <tr><td class="paramname">limit</td><td>Threshold for receive FIFO filling level to be considered for generating events. <br />
 <b>Range:</b> 0 to <em>size</em> -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the size and trigger limit for the receive FIFO. <br />
<br />
The API is not to be called for initializing the receive FIFO. The API shall be used for the runtime change of receive FIFO trigger limit. FIFO start position will not be affected on execution.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga6f77f046f48083e3e86735636e86490b">XMC_USIC_CH_TXFIFO_SetSizeTriggerLimit()</a>\ n<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#gaf6c7228b9e6c44332c077acf720f12b9">XMC_USIC_CH_TXFIFO_ClearEvent()</a>.</p>

</div>
</div>
<a class="anchor" id="gac9feec95c73b09889e494ec6d6898f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_i_c.html#gaf0ce1333656386f14f018b400beb9e39">XMC_USIC_CH_STATUS_t</a> XMC_USIC_CH_SetBaudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>oversampling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">rate</td><td>Desired baudrate. <b>Range:</b> minimum value = 100, maximum value depends on the peripheral clock frequency <br />
 and <em>oversampling</em>. Maximum baudrate can be derived using the formula: (fperiph * 1023)/(1024 * oversampling) </td></tr>
    <tr><td class="paramname">oversampling</td><td>Required oversampling. The value indicates the number of time quanta for one symbol of data. <br />
 This can be related to the number of samples for each logic state of the data signal. <br />
 <b>Range:</b> 1 to 32. Value should be chosen based on the protocol used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Status indicating the baudrate configuration.<br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggaf0ce1333656386f14f018b400beb9e39a7f5eeda6309c7b3a3e8f08380ed47e3c">XMC_USIC_CH_STATUS_OK</a> if baudrate is successfully configured, <a class="el" href="group___u_s_i_c.html#ggaf0ce1333656386f14f018b400beb9e39af9cf48d10eb977902d20eeaed491bcf0">XMC_USIC_CH_STATUS_ERROR</a> if desired baudrate or oversampling is invalid.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the baudrate of the USIC channel. <br />
<br />
Baudrate is configured by considering the peripheral frequency and the desired baudrate. Optimum values of FDR-&gt;STEP and BRG-&gt;PDIV are calulated and used for generating the desired baudrate.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga3b02352ba5e94e8f79751dea304084e0">XMC_USIC_CH_SetStartTransmisionMode()</a>, <a class="el" href="group___u_s_i_c.html#ga7986fcfe3fd6bf9982e43b1eaabb02c2">XMC_USIC_CH_SetInputSource()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2876a325930da4b77ef46ec4e0acda0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetBRGInputClockSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga4a6a3d9ca8a64d7689f25c8c688cbab9">XMC_USIC_CH_BRG_CLOCK_SOURCE_t</a>&#160;</td>
          <td class="paramname"><em>clock_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">clock_source</td><td>clock source for the BRG. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the clock source for the BRG. <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gaeef58e03c1253fce5b8a456f5d8c6da6">XMC_USIC_CH_SetInputTriggerCombinationMode()</a>, XMC_USIC_CH_SetExternalClockBRGDivider()<br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a60442d8bed2e194af31a7bedbabf0c16">XMC_USIC_CH_t::BRG</a>.</p>

</div>
</div>
<a class="anchor" id="ga920a20a26fbff1aaeb240af921f61ce4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetDataOutputMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#gab277976402d3da779839621f911fe89a">XMC_USIC_CH_DATA_OUTPUT_MODE_t</a>&#160;</td>
          <td class="paramname"><em>data_output_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">data_output_mode</td><td>Data output mode. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggab277976402d3da779839621f911fe89aa2ee23e3a426e82d5e9142079a16f00bf">XMC_USIC_CH_DATA_OUTPUT_MODE_NORMAL</a>, <a class="el" href="group___u_s_i_c.html#ggab277976402d3da779839621f911fe89aa984f346629f34906201bbde3a6863ede">XMC_USIC_CH_DATA_OUTPUT_MODE_INVERTED</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the mode for data output. <br />
<br />
USIC channel can be configured to shift inverted data or direct data based on the input to the API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga3b02352ba5e94e8f79751dea304084e0">XMC_USIC_CH_SetStartTransmisionMode()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#ac005cdf6a4e1350830161ee7ef88b9a2">XMC_USIC_CH_t::SCTR</a>.</p>

</div>
</div>
<a class="anchor" id="ga23964f6d982b35388f3a7c82f5634e0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetFrameLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>frame_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">frame_length</td><td>Number of bits in a frame. <br />
 <b>Range:</b> minimum= 1, maximum= 0x3f. The maximum value for fixed frame size is 0x3f. <br />
 e.g: For a frame length of 16, <em>frame_length</em> should be provided as 16. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Define the data frame length.<br />
<br />
Set the number of bits to be serially transmitted in a frame. The frame length should be multiples of word length. If the value is set to 0x40, the frame length has to be controlled explicitly.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gabb9d02b8388a03cd28190c976cdb8b78">XMC_USIC_CH_SetWordLength()</a>, <a class="el" href="group___u_s_i_c.html#gaf1d2b03bb1350dfc628f0bfa9fb6ffb0">XMC_USIC_CH_EnableFrameLengthControl()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#ac005cdf6a4e1350830161ee7ef88b9a2">XMC_USIC_CH_t::SCTR</a>.</p>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#gacf411f00a4585150d33d3259dfc785ca">XMC_I2S_CH_SetFrameLength()</a>, <a class="el" href="group___s_p_i.html#gaedb545863be3b85d6b2ec51503926432">XMC_SPI_CH_SetFrameLength()</a> und <a class="el" href="group___u_a_r_t.html#ga9f6eb4a3265729b4b7cf7e3d198130d6">XMC_UART_CH_SetFrameLength()</a>.</p>

</div>
</div>
<a class="anchor" id="ga77ed1338593c1492f35321494aedfa48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetInputSamplingFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga4eabf4e044ae33972f726f904e788f8a">XMC_USIC_CH_INPUT_SAMPLING_FREQ_t</a>&#160;</td>
          <td class="paramname"><em>sampling_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support.. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
    <tr><td class="paramname">sampling_freq</td><td>Sampling frequency value of type <em>XMC_USIC_CH_INPUT_SAMPLING_FREQ_t</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets sampling frequency for USIC channel input data signal. <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga7986fcfe3fd6bf9982e43b1eaabb02c2">XMC_USIC_CH_SetInputSource()</a>, <a class="el" href="group___u_s_i_c.html#ga1a5edb9ab8796da1f86be687fab65f32">XMC_USIC_CH_EnableInputSync()</a>, <a class="el" href="group___u_s_i_c.html#ga6a776750022b67a7d4075fb06eac39dc">XMC_USIC_CH_EnableInputDigitalFilter()</a> <br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for SFSEL bitfield mask in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a> und <a class="el" href="group___u_s_i_c.html#gaa40b6e977acd2290853cfa788ec56dc5">USIC_CH_DXCR_SFSEL_Msk</a>.</p>

<p>Wird benutzt von <a class="el" href="group___u_a_r_t.html#gad6c3cf150769886938ceb811557db243">XMC_UART_CH_SetInputSamplingFreq()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7986fcfe3fd6bf9982e43b1eaabb02c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetInputSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
    <tr><td class="paramname">source</td><td>Input source select for the input stage. The table below maps the enum value with the input channel. <table class="doxtable">
<tr>
<td>0</td><td>DXnA</td></tr>
<tr>
<td>1</td><td>DXnB</td></tr>
<tr>
<td>2</td><td>DXnC</td></tr>
<tr>
<td>3</td><td>DXnD </td></tr>
<tr>
<td>4</td><td>DXnE</td></tr>
<tr>
<td>5</td><td>DXnF</td></tr>
<tr>
<td>6</td><td>DXnG</td></tr>
<tr>
<td>7</td><td>Always 1 </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the data source for USIC input stage.<br />
<br />
Selects the input data signal source among DXnA, DXnB.. DXnG for the input stage. The API can be used for all the input stages like DX0CR, DX1CR etc.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gae13b2003ea4d8703a9990d1e90048dc3">XMC_USIC_CH_EnableInputInversion()</a>, <a class="el" href="group___u_s_i_c.html#ga6a776750022b67a7d4075fb06eac39dc">XMC_USIC_CH_EnableInputDigitalFilter()</a>, <a class="el" href="group___u_s_i_c.html#ga1a5edb9ab8796da1f86be687fab65f32">XMC_USIC_CH_EnableInputSync()</a>, <a class="el" href="group___u_s_i_c.html#ga77ed1338593c1492f35321494aedfa48">XMC_USIC_CH_SetInputSamplingFreq()</a><br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for DSEL bitfield mask in DXnCR register</p>
<p>&lt; Common mask for DSEL bitfield position in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a>, <a class="el" href="group___u_s_i_c.html#ga422029f5a94b9e2960a712fb3cb437d0">USIC_CH_DXCR_DSEL_Msk</a> und <a class="el" href="group___u_s_i_c.html#gad3fe0ed0b13c04904e25ccee9eeb084c">USIC_CH_DXCR_DSEL_Pos</a>.</p>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>, <a class="el" href="group___i2_s.html#ga32572b75a2b528238622cfa91da6239f">XMC_I2S_CH_SetInputSource()</a>, <a class="el" href="group___s_p_i.html#gab5800f69155c1ecadedf587fd567e2b3">XMC_SPI_CH_SetInputSource()</a> und <a class="el" href="group___u_a_r_t.html#ga1f6aded563def78ca10e8638889bd898">XMC_UART_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeef58e03c1253fce5b8a456f5d8c6da6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetInputTriggerCombinationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga4c50ae5a7f12a5496d82d2bc665e1db2">XMC_USIC_CH_INPUT_COMBINATION_MODE_t</a>&#160;</td>
          <td class="paramname"><em>combination_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support.. </td></tr>
    <tr><td class="paramname">input</td><td>USIC channel input stage of type <a class="el" href="group___u_s_i_c.html#ga7b7c285b4dfe6c9132f2f478a59b2ac5">XMC_USIC_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5a218c2b06596afed7bf9bc41fb6db47ee">XMC_USIC_CH_INPUT_DX0</a> to <a class="el" href="group___u_s_i_c.html#gga7b7c285b4dfe6c9132f2f478a59b2ac5ae3ff15e93aa354e43133246bc552effd">XMC_USIC_CH_INPUT_DX5</a> </td></tr>
    <tr><td class="paramname">combination_mode</td><td>Combination mode value of type <em>XMC_USIC_CH_INPUT_COMBINATION_MODE_t</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects which edge of the synchronized signal DXnS activates the trigger output DXnT of the input stage. <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga7986fcfe3fd6bf9982e43b1eaabb02c2">XMC_USIC_CH_SetInputSource()</a>, <a class="el" href="group___u_s_i_c.html#ga1a5edb9ab8796da1f86be687fab65f32">XMC_USIC_CH_EnableInputSync()</a>, <a class="el" href="group___u_s_i_c.html#ga6a776750022b67a7d4075fb06eac39dc">XMC_USIC_CH_EnableInputDigitalFilter()</a> <br />
<br />
<br />
</dd></dl>
<p>&lt; Common mask for CM bitfield mask in DXnCR register</p>
<p>&lt; Common mask for CM bitfield position in DXnCR register </p>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a>, <a class="el" href="group___u_s_i_c.html#ga857b16f38336b2f0bda76d514c341748">USIC_CH_DXCR_CM_Msk</a> und <a class="el" href="group___u_s_i_c.html#gac37ea251ee432c469f3ca780f00a0a82">USIC_CH_DXCR_CM_Pos</a>.</p>

</div>
</div>
<a class="anchor" id="ga52f9fc18049dbc906b127e1f3662b4b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga074b5b1abff43f98316c7a5b69523e62">XMC_USIC_CH_INTERRUPT_NODE_POINTER_t</a>&#160;</td>
          <td class="paramname"><em>interrupt_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">interrupt_node</td><td>Interrupt node pointer to be configured. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga074b5b1abff43f98316c7a5b69523e62ac3d37f726e6214704f420586ff8effc3">XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT</a>, <a class="el" href="group___u_s_i_c.html#gga074b5b1abff43f98316c7a5b69523e62a2298fc6a0fcee48a76f0aea1eb95e3a6">XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER</a> etc. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number.<br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for USIC channel events. <br />
<br />
For an event to generate interrupt, node pointer should be configured with service request(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so.<br />
 Note: NVIC node should be separately enabled to generate the interrupt.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga6f9467a0f290d65f7292b45cc29e32b4">XMC_USIC_CH_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga0caf9dbe9035171cc4826ad279a857a3">XMC_I2C_CH_SelectInterruptNodePointer()</a>, <a class="el" href="group___i2_c.html#gada2c698290a70ed692f067756ececd4d">XMC_I2C_CH_SetInterruptNodePointer()</a>, <a class="el" href="group___i2_s.html#gafd9b940110725dee4580f570f54028ab">XMC_I2S_CH_SelectInterruptNodePointer()</a>, <a class="el" href="group___i2_s.html#ga8af8cb0639aeede0ab9faead5fa7f55c">XMC_I2S_CH_SetInterruptNodePointer()</a>, <a class="el" href="group___s_p_i.html#ga4a6b621ddf701529b5256181d40bbdac">XMC_SPI_CH_SelectInterruptNodePointer()</a>, <a class="el" href="group___s_p_i.html#ga14b1f10c37e326b76cd214f7c006add2">XMC_SPI_CH_SetInterruptNodePointer()</a>, <a class="el" href="group___u_a_r_t.html#gadd72632ef25d7f44d8518141fde99a2c">XMC_UART_CH_SelectInterruptNodePointer()</a>, <a class="el" href="group___u_a_r_t.html#gaa013e09337b1c9c05b41eac29b2518ea">XMC_UART_CH_SetInterruptNodePointer()</a> und <a class="el" href="group___u_s_i_c.html#ga2520619d1b8420b50501c24b2155c02a">XMC_USIC_CH_DisableEvent()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf9deda88e97525978786d4711aa75067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetMclkOutputPassiveLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#gae9d3fa2244d754db4311c49fb624115e">XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL_t</a>&#160;</td>
          <td class="paramname"><em>passive_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">passive_level</td><td>Passive level for the master clock output. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggae9d3fa2244d754db4311c49fb624115ea0fac1e2e39d4aa98d32a523e76240106">XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL_0</a>, <a class="el" href="group___u_s_i_c.html#ggae9d3fa2244d754db4311c49fb624115ea387e03692c7d6b05d34825b4ada8422f">XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL_1</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the idle mode pin level for the master clock output. <br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a60442d8bed2e194af31a7bedbabf0c16">XMC_USIC_CH_t::BRG</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c04c213fd44c14b1bed871bb658683c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#gac052842418ff3dda00900219ebda5de7">XMC_USIC_CH_OPERATING_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">mode</td><td>USIC channel operation mode. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggac052842418ff3dda00900219ebda5de7a0f42d929665110fb0a00c7adbaf5a763">XMC_USIC_CH_OPERATING_MODE_IDLE</a>, <a class="el" href="group___u_s_i_c.html#ggac052842418ff3dda00900219ebda5de7a899e292213839edfb7d88e356cb9d18f">XMC_USIC_CH_OPERATING_MODE_SPI</a>, <a class="el" href="group___u_s_i_c.html#ggac052842418ff3dda00900219ebda5de7a0130416b257e28bf39a388658dd61469">XMC_USIC_CH_OPERATING_MODE_UART</a>, <a class="el" href="group___u_s_i_c.html#ggac052842418ff3dda00900219ebda5de7a567f54d1a3c96472fca5d6039d5e3cbc">XMC_USIC_CH_OPERATING_MODE_I2S</a>, <a class="el" href="group___u_s_i_c.html#ggac052842418ff3dda00900219ebda5de7a4dad9ad4de2fe7406c1685606a651503">XMC_USIC_CH_OPERATING_MODE_I2C</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the USIC channel operation mode.<br />
<br />
A USIC channel can support multiple serial communication protocols like UART, SPI, I2C and I2S. The API sets the input operation mode to the USIC channel.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga48113f030b655f6eaa3b9f6b73474785">XMC_USIC_Enable()</a>, <a class="el" href="group___u_s_i_c.html#ga0567321036170adb335fef9b36dc3b71">XMC_USIC_CH_Enable()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a5e1322e27c40bf91d172f9673f205c97">XMC_USIC_CH_t::CCR</a>.</p>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#gad3de1b923c1a3c0a2b1ea9a8d9ff1d91">XMC_I2C_CH_Start()</a>, <a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a> und <a class="el" href="group___s_p_i.html#ga4e3869696f61ef196fd2ea66a667bb0e">XMC_SPI_CH_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga46806897ccf781fb6289a8e12c11f9bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetPassiveDataLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga352121d35153623dc793f3b59c075eb0">XMC_USIC_CH_PASSIVE_DATA_LEVEL_t</a>&#160;</td>
          <td class="paramname"><em>passive_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">passive_level</td><td>Value of passive level for the channel. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga352121d35153623dc793f3b59c075eb0a66effdf4e324ee2d69f90126db5fb21d">XMC_USIC_CH_PASSIVE_DATA_LEVEL0</a>, <a class="el" href="group___u_s_i_c.html#gga352121d35153623dc793f3b59c075eb0aaf5284d9c00837ad1a2caf6dd72315b5">XMC_USIC_CH_PASSIVE_DATA_LEVEL1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Set the passive data level of the output signal. <br />
<br />
When the USIC channel transmit stage is idle, the output signal level stays at the configured passive level.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a>, <a class="el" href="group___u_s_i_c.html#ga3b02352ba5e94e8f79751dea304084e0">XMC_USIC_CH_SetStartTransmisionMode()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#ac005cdf6a4e1350830161ee7ef88b9a2">XMC_USIC_CH_t::SCTR</a>, <a class="el" href="group___u_s_i_c.html#ga7cfe52daa733ba40e9b93fec60b04406">XMC_USIC_CH_TXFIFO_Configure()</a> und <a class="el" href="group___u_s_i_c.html#ga6f77f046f48083e3e86735636e86490b">XMC_USIC_CH_TXFIFO_SetSizeTriggerLimit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b02352ba5e94e8f79751dea304084e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetStartTransmisionMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#gae2db2ec4c7c43ae1454373789443b793">XMC_USIC_CH_START_TRANSMISION_MODE_t</a>&#160;</td>
          <td class="paramname"><em>start_transmision_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">start_transmision_mode</td><td>Transmission mode to be enabled. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggae2db2ec4c7c43ae1454373789443b793a92234bf742ccdef5a487ab9fc7b7b47e">XMC_USIC_CH_START_TRANSMISION_DISABLED</a>, <a class="el" href="group___u_s_i_c.html#ggae2db2ec4c7c43ae1454373789443b793a7464a12e43e762ae3809838ed60b0848">XMC_USIC_CH_START_TRANSMISION_ON_TDV</a>, <a class="el" href="group___u_s_i_c.html#ggae2db2ec4c7c43ae1454373789443b793ad79ea1b2ea37a89eac8eec9905499589">XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_0</a>, <a class="el" href="group___u_s_i_c.html#ggae2db2ec4c7c43ae1454373789443b793a21bcda749a5e1eda8108ce39f8b97b7a">XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_1</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures data transmission. <br />
<br />
The configuration affects the data shifted on the DOUT0 pin.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a>, <a class="el" href="group___u_s_i_c.html#ga920a20a26fbff1aaeb240af921f61ce4">XMC_USIC_CH_SetDataOutputMode()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2d92409ce4c718ecee4f9498d06346c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetTransmitBufferStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga46769f2474ad4be950bcfc47582f5f87">XMC_USIC_CH_TBUF_STATUS_SET_t</a>&#160;</td>
          <td class="paramname"><em>transmit_buffer_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">transmit_buffer_status</td><td>clearing or setting the TDV flag. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Modify TCSR.TDV and TCSR.TE to control the start of a data word transmission by software.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a4f306d0f14e17555e82b55f6782be566">XMC_USIC_CH_t::FMR</a>.</p>

</div>
</div>
<a class="anchor" id="gabb9d02b8388a03cd28190c976cdb8b78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_SetWordLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>word_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">word_length</td><td>Number of bits to be configured for a data word. <br />
 <b>Range:</b> minimum= 1, maximum= 16. <br />
 e.g: For word length of 8, <em>word_length</em> should be provided as 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the data word length in number of bits. <br />
<br />
Sets the number of bits to represent a data word. Frame length should be a multiple of word length.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga23964f6d982b35388f3a7c82f5634e0f">XMC_USIC_CH_SetFrameLength()</a><br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#ac005cdf6a4e1350830161ee7ef88b9a2">XMC_USIC_CH_t::SCTR</a>.</p>

<p>Wird benutzt von <a class="el" href="group___i2_s.html#ga55da8db55309c3afb4d9c6f238aeb240">XMC_I2S_CH_SetWordLength()</a>, <a class="el" href="group___s_p_i.html#ga874157094bd9b28c5a5493eee577df72">XMC_SPI_CH_SetWordLength()</a> und <a class="el" href="group___u_a_r_t.html#ga6b12b3bdebda3d3a6c28d5c79a12735b">XMC_UART_CH_SetWordLength()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6fa0313a4dfcade23a7098631edefc50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_TriggerServiceRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">service_request_line</td><td>service request number of the event to be triggered. <br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Trigger a USIC interrupt service request.<br />
<br />
When the USIC service request is triggered, the NVIC interrupt associated with it will be generated if enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a4f306d0f14e17555e82b55f6782be566">XMC_USIC_CH_t::FMR</a>.</p>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga72d5d08ec30a105175f9a789ab38c1c7">XMC_I2C_CH_TriggerServiceRequest()</a>, <a class="el" href="group___i2_s.html#ga4332db9df7ffbb91a633d94a05897ac4">XMC_I2S_CH_TriggerServiceRequest()</a>, <a class="el" href="group___s_p_i.html#ga69901d79102b4efda87bc822b0d1e5d0">XMC_SPI_CH_TriggerServiceRequest()</a> und <a class="el" href="group___u_a_r_t.html#ga3a3d22e4821ed95b364793b3a7e711c0">XMC_UART_CH_TriggerServiceRequest()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf6c7228b9e6c44332c077acf720f12b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_TXFIFO_ClearEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Transmit FIFO events to be cleared. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gga6e964201594d82a691896a52cbfd5620a1e44a086ab5e16b5832160e1ce085eac">XMC_USIC_CH_TXFIFO_EVENT_STANDARD</a>, <a class="el" href="group___u_s_i_c.html#gga6e964201594d82a691896a52cbfd5620a309215a549219964d0d04ebcc22f6e33">XMC_USIC_CH_TXFIFO_EVENT_ERROR</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the transmit FIFO event flags in the status register. <br />
<br />
USIC channel peripheral does not clear the event flags after they are read. This API clears the events provided in the <em>mask</em> value. XMC_USIC_CH_TXFIFO_EVENT enumeration can be used as input. Multiple events can be cleared by providing a mask value obtained by bitwise OR operation of multiple event enumerations.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gadad2288d7f198fbc582dc4af7d1386c5">XMC_USIC_CH_TXFIFO_GetEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#aa4ebd1cc49417ade270040dd5ae90a76">XMC_USIC_CH_t::TRBSCR</a>, <a class="el" href="group___u_s_i_c.html#ga4ba419dd17bdb7e7be5f5ca757910a00">XMC_USIC_CH_RXFIFO_Configure()</a> und <a class="el" href="group___u_s_i_c.html#gae9984f496fe787c05b84dc6d1d65ee2e">XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7cfe52daa733ba40e9b93fec60b04406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_TXFIFO_Configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>data_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#gafdd0a07bee93d72936191b7e8555aefe">XMC_USIC_CH_FIFO_SIZE_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">data_pointer</td><td>Start position inside the FIFO buffer. <br />
 <b>Range:</b> 0 to 63. </td></tr>
    <tr><td class="paramname">size</td><td>Required size of the transmit FIFO. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefea1c189be4c15d2176b740037fa220e4a4">XMC_USIC_CH_FIFO_DISABLED</a>, <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefeac2b3558621719f1d4e64d55a0febb166">XMC_USIC_CH_FIFO_SIZE_2WORDS</a>.. <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefead702883ad36b39b6014e45b31f1655e8">XMC_USIC_CH_FIFO_SIZE_64WORDS</a> </td></tr>
    <tr><td class="paramname">limit</td><td>Threshold of transmit FIFO filling level to be considered for generating events. <br />
 <b>Range:</b> 0 to <em>size</em> -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes the transmit FIFO. <br />
<br />
Transmit FIFO is a subset of a common FIFO sized 64 words. This FIFO is shared between 2 channels of the USIC module. Each channel can share the FIFO for transmission and reception. <em>data_pointer</em> represents the start index in the common FIFO, from where transmit data can be put, for the selected USIC channel. <em>size</em> represents the size of transmit FIFO as a multiple of<ol type="1">
<li>Since the FIFO is shared between 2 USIC channels, FIFO size should be carefully selected. A FIFO standard transmit buffer event is generated when the FIFO filling level falls below the <em>limit</em> value.</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga4688634fee0d7fbdefca290999ca7b49">XMC_USIC_CH_TXFIFO_EnableEvent()</a>, <a class="el" href="group___u_s_i_c.html#ga63e10af0afcde1c73c39cd6522ac0614">XMC_USIC_CH_TXFIFO_SetInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga46806897ccf781fb6289a8e12c11f9bf">XMC_USIC_CH_SetPassiveDataLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga11e72155477de1a0495e4f85362fad86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_TXFIFO_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Events to be disabled. <a class="el" href="group___u_s_i_c.html#gac7690c669fbca7c9710ba7294df39a6d">XMC_USIC_CH_TXFIFO_EVENT_CONF_t</a> <br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the interrupt events related to transmit FIFO. <br />
<br />
By disabling the interrupt events, generation of interrupt is stopped. User can poll the event flags from the status register using the API <a class="el" href="group___u_s_i_c.html#gadad2288d7f198fbc582dc4af7d1386c5">XMC_USIC_CH_TXFIFO_GetEvent()</a>. Event bitmasks can be constructed using the enumeration <a class="el" href="group___u_s_i_c.html#gac7690c669fbca7c9710ba7294df39a6d">XMC_USIC_CH_TXFIFO_EVENT_CONF_t</a>. For providing multiple events, combine the events using bitwise OR operation.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gadad2288d7f198fbc582dc4af7d1386c5">XMC_USIC_CH_TXFIFO_GetEvent()</a>, <a class="el" href="group___u_s_i_c.html#ga4688634fee0d7fbdefca290999ca7b49">XMC_USIC_CH_TXFIFO_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a296a4090d20090679ec849b77af2ad5b">XMC_USIC_CH_t::TBCTR</a> und <a class="el" href="group___u_s_i_c.html#ga63e10af0afcde1c73c39cd6522ac0614">XMC_USIC_CH_TXFIFO_SetInterruptNodePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4688634fee0d7fbdefca290999ca7b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_TXFIFO_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Events to be enabled. Multiple events can be bitwise OR combined. <a class="el" href="group___u_s_i_c.html#gac7690c669fbca7c9710ba7294df39a6d">XMC_USIC_CH_TXFIFO_EVENT_CONF_t</a> <br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the interrupt events related to transmit FIFO. <br />
<br />
Event bitmasks can be constructed using the enumeration <a class="el" href="group___u_s_i_c.html#gac7690c669fbca7c9710ba7294df39a6d">XMC_USIC_CH_TXFIFO_EVENT_CONF_t</a>. Multiple events can be enabled by providing multiple events in a single call. For providing multiple events, combine the events using bitwise OR operation. Events are configured in the TBCTR register.<br />
</dd></dl>
<p>Note: API only enables the events. For interrupt generation, interrupt node must be configured and NVIC node must be enabled.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga63e10af0afcde1c73c39cd6522ac0614">XMC_USIC_CH_TXFIFO_SetInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a296a4090d20090679ec849b77af2ad5b">XMC_USIC_CH_t::TBCTR</a>.</p>

</div>
</div>
<a class="anchor" id="gab075189d6283b3cff45bb4f38d1bd4aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_TXFIFO_Flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the contents of transmit FIFO. <br />
<br />
Transmit FIFO contents will be cleared and the filling level will be reset to 0.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga8724f831f2fc77366ece9f4b91bc095f">XMC_USIC_CH_TXFIFO_GetLevel()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#aa4ebd1cc49417ade270040dd5ae90a76">XMC_USIC_CH_t::TRBSCR</a>.</p>

</div>
</div>
<a class="anchor" id="gadad2288d7f198fbc582dc4af7d1386c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_USIC_CH_TXFIFO_GetEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Status of standard transmit and transmit buffer error events. <a class="el" href="group___u_s_i_c.html#ga6e964201594d82a691896a52cbfd5620">XMC_USIC_CH_TXFIFO_EVENT_t</a> <br />
 </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Gets the transmit FIFO event status. <br />
<br />
Gives the status of transmit FIFO standard transmit buffer event and transmit buffer error event. The status bits are located at their bit positions in the TRBSR register in the returned value. User can make use of the <a class="el" href="group___u_s_i_c.html#ga6e964201594d82a691896a52cbfd5620">XMC_USIC_CH_TXFIFO_EVENT_t</a> enumeration for checking the status of return value. The status can be found by using the bitwise AND operation on the returned value with the enumerated value.<br />
</dd></dl>
<p>Note: Event status flags should be cleared by the user explicitly.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gaf6c7228b9e6c44332c077acf720f12b9">XMC_USIC_CH_TXFIFO_ClearEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a9c79cb9e505b1157be614ba619b3d545">XMC_USIC_CH_t::TRBSR</a>.</p>

</div>
</div>
<a class="anchor" id="ga8724f831f2fc77366ece9f4b91bc095f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_USIC_CH_TXFIFO_GetLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Transmit FIFO filling level. <br />
 <b>Range:</b> minimum= 0(FIFO empty), maximum= transmit FIFO size.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Gets the transmit FIFO filling level. <br />
<br />
For every word written to the FIFO, filling level is updated. The API gives the value of this filling level.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gab075189d6283b3cff45bb4f38d1bd4aa">XMC_USIC_CH_TXFIFO_Flush()</a>, <a class="el" href="group___u_s_i_c.html#gae96e9afeaefe2585b687e36f6227727f">XMC_USIC_CH_TXFIFO_PutData()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a9c79cb9e505b1157be614ba619b3d545">XMC_USIC_CH_t::TRBSR</a>.</p>

</div>
</div>
<a class="anchor" id="ga0cb5c1c2623ce6281ed8683007da127b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_USIC_CH_TXFIFO_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Status <em>true</em> if transmit FIFO is empty <em>false</em> if transmit FIFO has some data.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks if transmit FIFO is empty. <br />
<br />
When the transmit FIFO is empty, data can be written to FIFO. When the last written word to the transmit FIFO is transmitted out of the FIFO, FIFO empty flag is set.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gab075189d6283b3cff45bb4f38d1bd4aa">XMC_USIC_CH_TXFIFO_Flush()</a>, <a class="el" href="group___u_s_i_c.html#gae96e9afeaefe2585b687e36f6227727f">XMC_USIC_CH_TXFIFO_PutData()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a9c79cb9e505b1157be614ba619b3d545">XMC_USIC_CH_t::TRBSR</a>.</p>

</div>
</div>
<a class="anchor" id="gaaee9b8efb56290224bfe1d5ac9b273a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_USIC_CH_TXFIFO_IsFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Status <em>true</em> if transmit FIFO is full <em>false</em> if transmit FIFO is not full.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Checks if transmit FIFO is full. <br />
<br />
When the transmit FIFO filling level reaches the configured size, FIFO full flag is set. User should not write to the FIFO when the transmit FIFO is full.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga0cb5c1c2623ce6281ed8683007da127b">XMC_USIC_CH_TXFIFO_IsEmpty()</a>, <a class="el" href="group___u_s_i_c.html#gab075189d6283b3cff45bb4f38d1bd4aa">XMC_USIC_CH_TXFIFO_Flush()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a9c79cb9e505b1157be614ba619b3d545">XMC_USIC_CH_t::TRBSR</a>.</p>

</div>
</div>
<a class="anchor" id="gae96e9afeaefe2585b687e36f6227727f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_TXFIFO_PutData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be transmitted. <br />
 <b>Range:</b> 16bit unsigned data. minimum= 0, maximum= 65535 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Writes data into the transmit FIFO. <br />
<br />
The data provided is placed in the transmit FIFO. The transmit FIFO should be configured before calling this API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga4688634fee0d7fbdefca290999ca7b49">XMC_USIC_CH_TXFIFO_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#aa7baca4bb2ca5b8e9a3ab21a8c248a6d">XMC_USIC_CH_t::IN</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f14560e863b15c6bd123e534332e9f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_TXFIFO_PutDataFLEMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>frame_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be transmitted. </td></tr>
    <tr><td class="paramname">frame_length</td><td>Frame length to be configured while transmitting the data. <br />
 <b>Range:</b> minimum= 0, maximum= 31. e.g: For a frame length of 16, set <em>frame_length</em> as 15. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Writes data to the transmit FIFO in frame length control mode. <br />
<br />
When frame length control is enabled for dynamic update of frame length, this API can be used. <em>frame_length</em> represents the frame length to be updated by the peripheral. <em>frame_length</em> is used as index for the IN[] register array.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gaf1d2b03bb1350dfc628f0bfa9fb6ffb0">XMC_USIC_CH_EnableFrameLengthControl()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#aa7baca4bb2ca5b8e9a3ab21a8c248a6d">XMC_USIC_CH_t::IN</a>.</p>

</div>
</div>
<a class="anchor" id="ga63e10af0afcde1c73c39cd6522ac0614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#gaed66b290b2c45854fcd04580fb6349a1">XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t</a>&#160;</td>
          <td class="paramname"><em>interrupt_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">interrupt_node</td><td>Node pointer representing the transmit FIFO events. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggaed66b290b2c45854fcd04580fb6349a1a5f3f135726f0f39eb99ab43cfdf699cf">XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD</a>, <a class="el" href="group___u_s_i_c.html#ggaed66b290b2c45854fcd04580fb6349a1aef96e8370ec2178615f3a24a04da19fe">XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE</a> </td></tr>
    <tr><td class="paramname">service_request</td><td>The service request to be used for interrupt generation. <br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets an interrupt node for the transmit FIFO events.<br />
<br />
A node pointer represents one or more interrupt events. Service request represents the interrupt node to be used among the 6 interrupt nodes available for USIC module. API configures the service request to be used for interrupt generation for the events selected. A transmit FIFO event can generate an interrupt only if the interrupt node is configured for the event and the interrupt generation is enabled for the event. For example, transmit FIFO standard transmit buffer interrupt is generated if the interrupt node for the same is set and interrupt is enabled.<br />
</dd></dl>
<p>Note: NVIC node should be explicitly enabled for the interrupt generation.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga4688634fee0d7fbdefca290999ca7b49">XMC_USIC_CH_TXFIFO_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga11e72155477de1a0495e4f85362fad86">XMC_USIC_CH_TXFIFO_DisableEvent()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f77f046f48083e3e86735636e86490b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_TXFIFO_SetSizeTriggerLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#gafdd0a07bee93d72936191b7e8555aefe">XMC_USIC_CH_FIFO_SIZE_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">size</td><td>Required size of the transmit FIFO. <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefea1c189be4c15d2176b740037fa220e4a4">XMC_USIC_CH_FIFO_DISABLED</a>, <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefeac2b3558621719f1d4e64d55a0febb166">XMC_USIC_CH_FIFO_SIZE_2WORDS</a>.. <a class="el" href="group___u_s_i_c.html#ggafdd0a07bee93d72936191b7e8555aefead702883ad36b39b6014e45b31f1655e8">XMC_USIC_CH_FIFO_SIZE_64WORDS</a> </td></tr>
    <tr><td class="paramname">limit</td><td>Threshold for transmit FIFO filling level to be considered for generating events. <br />
 <b>Range:</b> 0 to <em>size</em> -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the size and trigger limit for the transmit FIFO. <br />
<br />
The API is not to be called for initializing the transmit FIFO. The API shall be used for the runtime change of transmit FIFO trigger limit. FIFO start position will not be affected on execution.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gae9984f496fe787c05b84dc6d1d65ee2e">XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga46806897ccf781fb6289a8e12c11f9bf">XMC_USIC_CH_SetPassiveDataLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga90d18508eb69fc4254bd0c3774d16150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_WriteToTBUF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be transmitted. <br />
 <b>Range:</b> 16bit unsigned data. minimum= 0, maximum= 65535 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Writes data into the transmit buffer. <br />
<br />
The data provided is placed in TBUF[0U].</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga40eb0199fd41ec5993971dad8a0e2d40">XMC_USIC_CH_WriteToTBUFTCI()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#abcb6aeeb845eea4d2035fb8efeb5f490">XMC_USIC_CH_t::TBUF</a>.</p>

</div>
</div>
<a class="anchor" id="ga40eb0199fd41ec5993971dad8a0e2d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_CH_WriteToTBUFTCI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>transmit_control_information</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a> based on device support. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be transmitted. </td></tr>
    <tr><td class="paramname">transmit_control_information</td><td>transmit control information to be configured while transmitting the data. <br />
 <b>Range:</b> minimum= 0, maximum= 31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Writes data to the transmit buffer in a control mode. <br />
<br />
When the respective control mode is enabled , this API can be used.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga90d18508eb69fc4254bd0c3774d16150">XMC_USIC_CH_WriteToTBUF()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#abcb6aeeb845eea4d2035fb8efeb5f490">XMC_USIC_CH_t::TBUF</a>.</p>

</div>
</div>
<a class="anchor" id="ga5d7f987aa7be2cc8497a0895f2ba3f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *const&#160;</td>
          <td class="paramname"><em>usic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">usic</td><td>Pointer to USIC module handler of type <a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a>.<br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gab5471c5fff228b5b9695356e7d2fc98a">XMC_USIC0</a> to <a class="el" href="group___u_s_i_c.html#ga13fa3c2b59871d42c4a0918d1de5e1b3">XMC_USIC2</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the USIC module.<br />
<br />
Disables the clock for the USIC module by following the clock disabling sequence for the selected device.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gaaba8dc6e2fe4c5cf3fd3418d532a9412">XMC_USIC_CH_Disable()</a>, <a class="el" href="group___u_s_i_c.html#ga48113f030b655f6eaa3b9f6b73474785">XMC_USIC_Enable()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga48113f030b655f6eaa3b9f6b73474785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USIC_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *const&#160;</td>
          <td class="paramname"><em>usic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">usic</td><td>Pointer to USIC module handler of type <a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a>.<br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#gab5471c5fff228b5b9695356e7d2fc98a">XMC_USIC0</a> to <a class="el" href="group___u_s_i_c.html#ga13fa3c2b59871d42c4a0918d1de5e1b3">XMC_USIC2</a> based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the USIC module.<br />
<br />
Enables the clock for the USIC module by following the clock enabling sequence for the selected device.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga0567321036170adb335fef9b36dc3b71">XMC_USIC_CH_Enable()</a>, <a class="el" href="group___u_s_i_c.html#ga5d7f987aa7be2cc8497a0895f2ba3f90">XMC_USIC_Disable()</a> <br />
<br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___u_s_i_c.html#ga175c3f24ef75607b827888bc8b84fff5">XMC_USIC_IsChannelValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga175c3f24ef75607b827888bc8b84fff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_USIC_IsChannelValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; USIC0 channel 0 base address</p>
<p>&lt; USIC0 channel 1 base address</p>
<p>&lt; USIC1 channel 0 base address</p>
<p>&lt; USIC1 channel 1 base address</p>
<p>&lt; USIC2 channel 0 base address</p>
<p>&lt; USIC2 channel 1 base address </p>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a>, <a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a>, <a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a>, <a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a>, <a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a>, <a class="el" href="group___u_s_i_c.html#ga00c6419dfc0f8ed4c4eab13ded598144">XMC_USIC_CH_ConfigExternalInputSignalToBRG()</a>, <a class="el" href="group___u_s_i_c.html#gaaba8dc6e2fe4c5cf3fd3418d532a9412">XMC_USIC_CH_Disable()</a>, <a class="el" href="group___u_s_i_c.html#ga0567321036170adb335fef9b36dc3b71">XMC_USIC_CH_Enable()</a>, <a class="el" href="group___u_s_i_c.html#gac9feec95c73b09889e494ec6d6898f4f">XMC_USIC_CH_SetBaudrate()</a>, <a class="el" href="group___u_s_i_c.html#ga5d7f987aa7be2cc8497a0895f2ba3f90">XMC_USIC_Disable()</a> und <a class="el" href="group___u_s_i_c.html#ga48113f030b655f6eaa3b9f6b73474785">XMC_USIC_Enable()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa7e00ca6654c493f25076f002c48dad6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_USIC_IsModuleValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga953ad8cb6043e854f32ab9a53042aedb">XMC_USIC_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; USIC0 module base address</p>
<p>&lt; USIC1 module base address</p>
<p>&lt; USIC2 module base address </p>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#gab5471c5fff228b5b9695356e7d2fc98a">XMC_USIC0</a>, <a class="el" href="group___u_s_i_c.html#gabeb00ed8ca0740c0b213c6684d636678">XMC_USIC1</a> und <a class="el" href="group___u_s_i_c.html#ga13fa3c2b59871d42c4a0918d1de5e1b3">XMC_USIC2</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Erzeugt am Mit Jun 22 2016 11:37:00 für XMC Peripheral Library for XMC4000 Family von &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
