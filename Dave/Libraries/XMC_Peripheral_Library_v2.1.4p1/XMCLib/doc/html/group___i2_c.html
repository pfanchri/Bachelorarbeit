<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>XMC Peripheral Library for XMC4000 Family: I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family
   &#160;<span id="projectnumber">2.1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Hauptseite</span></a></li>
      <li><a href="pages.html"><span>Zusätzliche&#160;Informationen</span></a></li>
      <li class="current"><a href="modules.html"><span>Module</span></a></li>
      <li><a href="files.html"><span>Dateien</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Datenstrukturen</a> &#124;
<a href="#define-members">Makrodefinitionen</a> &#124;
<a href="#enum-members">Aufzählungen</a> &#124;
<a href="#func-members">Funktionen</a>  </div>
  <div class="headertitle">
<div class="title">I2C<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Datenstrukturen</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Makrodefinitionen</h2></td></tr>
<tr class="memitem:ga71176768512ab2836eb4dc41973c1339"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga71176768512ab2836eb4dc41973c1339">XMC_I2C0_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a></td></tr>
<tr class="separator:ga71176768512ab2836eb4dc41973c1339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbbadccd3da1cbecf1aac59dd54035dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafbbadccd3da1cbecf1aac59dd54035dd">XMC_I2C0_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a></td></tr>
<tr class="separator:gafbbadccd3da1cbecf1aac59dd54035dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ffc942d7d7d6a1a2653c4406f265a16"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9ffc942d7d7d6a1a2653c4406f265a16">XMC_I2C1_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a></td></tr>
<tr class="separator:ga9ffc942d7d7d6a1a2653c4406f265a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b7a66d60a6dc718f09b5245187b9fec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8b7a66d60a6dc718f09b5245187b9fec">XMC_I2C1_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a></td></tr>
<tr class="separator:ga8b7a66d60a6dc718f09b5245187b9fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd192d1e612ccd4143ec299966a11f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadbd192d1e612ccd4143ec299966a11f0">XMC_I2C2_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a></td></tr>
<tr class="separator:gadbd192d1e612ccd4143ec299966a11f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d470379c765ee393530da6b97372122"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7d470379c765ee393530da6b97372122">XMC_I2C2_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a></td></tr>
<tr class="separator:ga7d470379c765ee393530da6b97372122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156f3aa37787f3b6b73c58a742e64302"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga156f3aa37787f3b6b73c58a742e64302">XMC_I2C_10BIT_ADDR_GROUP</a>&#160;&#160;&#160;(0x7800U)</td></tr>
<tr class="separator:ga156f3aa37787f3b6b73c58a742e64302"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Aufzählungen</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funktionen</h2></td></tr>
<tr class="memitem:gab922e97164d14898b92df3d30c10fe83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab922e97164d14898b92df3d30c10fe83">XMC_I2C_CH_ClearStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t flag)</td></tr>
<tr class="separator:gab922e97164d14898b92df3d30c10fe83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63149dd65f853cc69ed57add87f34627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga63149dd65f853cc69ed57add87f34627">XMC_I2C_CH_ConfigExternalInputSignalToBRG</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t pdiv, const uint32_t oversampling, const <a class="el" href="group___u_s_i_c.html#ga4c50ae5a7f12a5496d82d2bc665e1db2">XMC_USIC_CH_INPUT_COMBINATION_MODE_t</a> combination_mode)</td></tr>
<tr class="separator:ga63149dd65f853cc69ed57add87f34627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7a2f143c3f07c35b39174d6e802be6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4d7a2f143c3f07c35b39174d6e802be6">XMC_I2C_CH_DisableAcknowledgeAddress0</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga4d7a2f143c3f07c35b39174d6e802be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d0b7e575a13d2fdd2ead33d96d9e15b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7d0b7e575a13d2fdd2ead33d96d9e15b">XMC_I2C_CH_DisableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t event)</td></tr>
<tr class="separator:ga7d0b7e575a13d2fdd2ead33d96d9e15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49923f2679d64f4980518491d844bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae49923f2679d64f4980518491d844bec">XMC_I2C_CH_EnableAcknowledgeAddress0</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gae49923f2679d64f4980518491d844bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868f80d9e08a0518c38100dda3f77882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga868f80d9e08a0518c38100dda3f77882">XMC_I2C_CH_EnableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t event)</td></tr>
<tr class="separator:ga868f80d9e08a0518c38100dda3f77882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f0983dca84031814fcbcb52991ee63"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga50f0983dca84031814fcbcb52991ee63">XMC_I2C_CH_GetReceivedData</a> (const <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga50f0983dca84031814fcbcb52991ee63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1168655888146acb741b9e6aac04c4e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad1168655888146acb741b9e6aac04c4e">XMC_I2C_CH_GetReceiverStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gad1168655888146acb741b9e6aac04c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9131749645c421ff4b8bc80d0c93b691"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9131749645c421ff4b8bc80d0c93b691">XMC_I2C_CH_GetSlaveAddress</a> (const <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga9131749645c421ff4b8bc80d0c93b691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddc87a65cf16a2bf717f650a29506cef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaddc87a65cf16a2bf717f650a29506cef">XMC_I2C_CH_GetStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaddc87a65cf16a2bf717f650a29506cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbab6cabacc65e03592b1c5d6cece11d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafbab6cabacc65e03592b1c5d6cece11d">XMC_I2C_CH_Init</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:gafbab6cabacc65e03592b1c5d6cece11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e1a8e56b356c2fc246c8b3b95bfb74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad5e1a8e56b356c2fc246c8b3b95bfb74">XMC_I2C_CH_MasterReceiveAck</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gad5e1a8e56b356c2fc246c8b3b95bfb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5960060afec908c91cd8e4a78e5eae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae5960060afec908c91cd8e4a78e5eae9">XMC_I2C_CH_MasterReceiveNack</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gae5960060afec908c91cd8e4a78e5eae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770a5f71ceb3b447f21a8b129df6486e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga770a5f71ceb3b447f21a8b129df6486e">XMC_I2C_CH_MasterRepeatedStart</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t addr, const <a class="el" href="group___i2_c.html#gaf81b9bb81ece318669b08149f1fd7f4b">XMC_I2C_CH_CMD_t</a> command)</td></tr>
<tr class="separator:ga770a5f71ceb3b447f21a8b129df6486e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd425a409b805d4571e75f793317070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaebd425a409b805d4571e75f793317070">XMC_I2C_CH_MasterStart</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t addr, const <a class="el" href="group___i2_c.html#gaf81b9bb81ece318669b08149f1fd7f4b">XMC_I2C_CH_CMD_t</a> command)</td></tr>
<tr class="separator:gaebd425a409b805d4571e75f793317070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a48dbbe2be7fce74bd328bae5db5141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6a48dbbe2be7fce74bd328bae5db5141">XMC_I2C_CH_MasterStop</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga6a48dbbe2be7fce74bd328bae5db5141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga701835880c9d134de09af56c12ee3383"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t data)</td></tr>
<tr class="separator:ga701835880c9d134de09af56c12ee3383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0caf9dbe9035171cc4826ad279a857a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0caf9dbe9035171cc4826ad279a857a3">XMC_I2C_CH_SelectInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_c.html#ga797641917b01a783e6e7aac5d25a298f">XMC_I2C_CH_INTERRUPT_NODE_POINTER_t</a> interrupt_node, const uint32_t service_request)</td></tr>
<tr class="separator:ga0caf9dbe9035171cc4826ad279a857a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da1b672c78d08d3ffdb83316d1443cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0da1b672c78d08d3ffdb83316d1443cb">XMC_I2C_CH_SetBaudrate</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t rate)</td></tr>
<tr class="separator:ga0da1b672c78d08d3ffdb83316d1443cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358214504f42dac696c4519efa19307b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_c.html#ga76b49d68cc6d179beaf1dfe2998230bd">XMC_I2C_CH_INPUT_t</a> input, const uint8_t source)</td></tr>
<tr class="separator:ga358214504f42dac696c4519efa19307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2c698290a70ed692f067756ececd4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gada2c698290a70ed692f067756ececd4d">XMC_I2C_CH_SetInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t service_request)</td></tr>
<tr class="separator:gada2c698290a70ed692f067756ececd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9df234c44378c3fc10f0423d71aec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaec9df234c44378c3fc10f0423d71aec9">XMC_I2C_CH_SetSlaveAddress</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t address)</td></tr>
<tr class="separator:gaec9df234c44378c3fc10f0423d71aec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd7192c5a6b3fa481f293fb0a574665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafdd7192c5a6b3fa481f293fb0a574665">XMC_I2C_CH_SlaveTransmit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t data)</td></tr>
<tr class="separator:gafdd7192c5a6b3fa481f293fb0a574665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3de1b923c1a3c0a2b1ea9a8d9ff1d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad3de1b923c1a3c0a2b1ea9a8d9ff1d91">XMC_I2C_CH_Start</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gad3de1b923c1a3c0a2b1ea9a8d9ff1d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eeda18d28c90e527c309726ff5d3cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4eeda18d28c90e527c309726ff5d3cb9">XMC_I2C_CH_Stop</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga4eeda18d28c90e527c309726ff5d3cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d5d08ec30a105175f9a789ab38c1c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga72d5d08ec30a105175f9a789ab38c1c7">XMC_I2C_CH_TriggerServiceRequest</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t service_request_line)</td></tr>
<tr class="separator:ga72d5d08ec30a105175f9a789ab38c1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Ausführliche Beschreibung</h2>
<p>USIC IIC Features: <br />
</p><ul>
<li>Two-wire interface, with one line for shift clock transfer and synchronization (shift clock SCL), the other one for the data transfer (shift data SDA) <br />
</li>
<li>Communication in standard mode (100 kBit/s) or in fast mode (up to 400 kBit/s) <br />
</li>
<li>Support of 7-bit addressing, as well as 10-bit addressing <br />
</li>
<li>Master mode operation, where the IIC controls the bus transactions and provides the clock signal. <br />
</li>
<li>Slave mode operation, where an external master controls the bus transactions and provides the clock signal.<br />
</li>
<li>Multi-master mode operation, where several masters can be connected to the bus and bus arbitration can take place, i.e. the IIC module can be master or slave. <br />
 The master/slave operation of an IIC bus participant can change from frame to frame. <br />
</li>
<li>Efficient frame handling (low software effort), also allowing DMA transfers <br />
</li>
<li>Powerful interrupt handling due to multitude of indication flags <br />
 </li>
</ul>
<h2 class="groupheader">Makro-Dokumentation</h2>
<a class="anchor" id="ga71176768512ab2836eb4dc41973c1339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C0_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 0 base address </p>

</div>
</div>
<a class="anchor" id="gafbbadccd3da1cbecf1aac59dd54035dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C0_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 1 base address </p>

</div>
</div>
<a class="anchor" id="ga9ffc942d7d7d6a1a2653c4406f265a16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C1_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 0 base address </p>

</div>
</div>
<a class="anchor" id="ga8b7a66d60a6dc718f09b5245187b9fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C1_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 1 base address </p>

</div>
</div>
<a class="anchor" id="gadbd192d1e612ccd4143ec299966a11f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C2_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 0 base address </p>

</div>
</div>
<a class="anchor" id="ga7d470379c765ee393530da6b97372122"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C2_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 1 base address </p>

</div>
</div>
<a class="anchor" id="ga156f3aa37787f3b6b73c58a742e64302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C_10BIT_ADDR_GROUP&#160;&#160;&#160;(0x7800U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value to verify the address is 10-bit or not </p>

</div>
</div>
<h2 class="groupheader">Dokumentation der Aufzählungstypen</h2>
<a class="anchor" id="gaf81b9bb81ece318669b08149f1fd7f4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gaf81b9bb81ece318669b08149f1fd7f4b">XMC_I2C_CH_CMD_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C commands. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf81b9bb81ece318669b08149f1fd7f4baf3c121d840b85087f675d717adf27dc5"></a>XMC_I2C_CH_CMD_WRITE&#160;</td><td class="fielddoc">
<p>I2C Command Write </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf81b9bb81ece318669b08149f1fd7f4ba31d1b9749ef1daa181a908bbf2f28087"></a>XMC_I2C_CH_CMD_READ&#160;</td><td class="fielddoc">
<p>I2C Command Read </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4142054abf4133012810875bc5ac4f48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga4142054abf4133012810875bc5ac4f48">XMC_I2C_CH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C events. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48a07ea52a7379c4bf4825453b3d210b0be"></a>XMC_I2C_CH_EVENT_RECEIVE_START&#160;</td><td class="fielddoc">
<p>Receive start event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48a3f9ea9390840a184c4b611aa5fe1ce6d"></a>XMC_I2C_CH_EVENT_DATA_LOST&#160;</td><td class="fielddoc">
<p>Data lost event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48afd7666e256e93f0e533f879a83284f54"></a>XMC_I2C_CH_EVENT_TRANSMIT_SHIFT&#160;</td><td class="fielddoc">
<p>Transmit shift event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48a5e8ecaf6874fb8996dc7a527e183c8d8"></a>XMC_I2C_CH_EVENT_TRANSMIT_BUFFER&#160;</td><td class="fielddoc">
<p>Transmit buffer event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48aa3535a887f7de062e4e3d0eaa95e421c"></a>XMC_I2C_CH_EVENT_STANDARD_RECEIVE&#160;</td><td class="fielddoc">
<p>Receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48a2d0b99a3d3e49439e6a6d58776b028d1"></a>XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE&#160;</td><td class="fielddoc">
<p>Alternate receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48ab99891a610ff5ad0a7fdfb8037981da8"></a>XMC_I2C_CH_EVENT_BAUD_RATE_GENERATOR&#160;</td><td class="fielddoc">
<p>Baudrate generator event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48ad4539a3f5b3d43af665dcb2a5816ed82"></a>XMC_I2C_CH_EVENT_START_CONDITION_RECEIVED&#160;</td><td class="fielddoc">
<p>Start condition received event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48acf9e7500f6357d8821e4ef18c935e751"></a>XMC_I2C_CH_EVENT_REPEATED_START_CONDITION_RECEIVED&#160;</td><td class="fielddoc">
<p>Repeated start condition received event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48a8b8ef502b35abb43ea12a87e497a28d3"></a>XMC_I2C_CH_EVENT_STOP_CONDITION_RECEIVED&#160;</td><td class="fielddoc">
<p>Stop condition received event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48a8cffe5232278c8f126ebfbc8487a1c26"></a>XMC_I2C_CH_EVENT_NACK&#160;</td><td class="fielddoc">
<p>NACK received event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48a0ef9afd8b09cb8e99bcc7d342c0a38ee"></a>XMC_I2C_CH_EVENT_ARBITRATION_LOST&#160;</td><td class="fielddoc">
<p>Arbitration lost event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48a5b951bd38436773cb0e772c1db7dc997"></a>XMC_I2C_CH_EVENT_SLAVE_READ_REQUEST&#160;</td><td class="fielddoc">
<p>Slave read request event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48a43faef54c5b0282fd188a4d374a18bdc"></a>XMC_I2C_CH_EVENT_ERROR&#160;</td><td class="fielddoc">
<p>Error condition event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4142054abf4133012810875bc5ac4f48abcff76a9225d94f13a62d8fd613abe62"></a>XMC_I2C_CH_EVENT_ACK&#160;</td><td class="fielddoc">
<p>ACK received event </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga76b49d68cc6d179beaf1dfe2998230bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga76b49d68cc6d179beaf1dfe2998230bd">XMC_I2C_CH_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C input stage selection. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga76b49d68cc6d179beaf1dfe2998230bdaba2847f3ec9aeb06277abdea4a9a51bc"></a>XMC_I2C_CH_INPUT_SDA&#160;</td><td class="fielddoc">
<p>selection of sda input stage </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga76b49d68cc6d179beaf1dfe2998230bdaabd01419bb4afb47c665b94b4441dca9"></a>XMC_I2C_CH_INPUT_SCL&#160;</td><td class="fielddoc">
<p>selection of scl input stage </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga797641917b01a783e6e7aac5d25a298f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga797641917b01a783e6e7aac5d25a298f">XMC_I2C_CH_INTERRUPT_NODE_POINTER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C channel interrupt node pointers </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga797641917b01a783e6e7aac5d25a298fafd73773ef7c86cc9030d4766b6dad775"></a>XMC_I2C_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT&#160;</td><td class="fielddoc">
<p>Node pointer for transmit shift interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga797641917b01a783e6e7aac5d25a298fa30e7d3a2e8ad4bb38a00f428454b517c"></a>XMC_I2C_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER&#160;</td><td class="fielddoc">
<p>Node pointer for transmit buffer interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga797641917b01a783e6e7aac5d25a298fa7d9ed5feb1378602a157a765470f55bb"></a>XMC_I2C_CH_INTERRUPT_NODE_POINTER_RECEIVE&#160;</td><td class="fielddoc">
<p>Node pointer for receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga797641917b01a783e6e7aac5d25a298fab01fc29cb67b7bf5c6cd96d4ab25aa61"></a>XMC_I2C_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE&#160;</td><td class="fielddoc">
<p>Node pointer for alternate receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga797641917b01a783e6e7aac5d25a298fa21d86beba6a0b2719c4a280f6e0c483b"></a>XMC_I2C_CH_INTERRUPT_NODE_POINTER_PROTOCOL&#160;</td><td class="fielddoc">
<p>Node pointer for protocol related interrupts </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga0f5cc56c100494c399620dc165e74ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga0f5cc56c100494c399620dc165e74ee9">XMC_I2C_CH_RECEIVER_STATUS_FLAG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C receiver status. The received data byte is available at the bit positions RBUF[7:0], whereas the additional information is monitored at the bit positions RBUF[12:8]. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="gga0f5cc56c100494c399620dc165e74ee9ae99b1cd7f47070702c4c8608eee3ea5b"></a>XMC_I2C_CH_RECEIVER_STATUS_FLAG_ACK&#160;</td><td class="fielddoc">
<p>Bit 8: Value of Received Acknowledgement bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0f5cc56c100494c399620dc165e74ee9a94b6f93bb9548e17750f7ca5c1ead596"></a>XMC_I2C_CH_RECEIVER_STATUS_FLAG_FIN&#160;</td><td class="fielddoc">
<p>Bit 9: A 1 at this bit position indicates that after a (repeated) start condition followed by the address reception the first data byte of a new frame has been received. A 0 at this bit position indicates further data bytes </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0f5cc56c100494c399620dc165e74ee9a4f00ab2699087f6404bb326a8a40432f"></a>XMC_I2C_CH_RECEIVER_STATUS_FLAG_MODE&#160;</td><td class="fielddoc">
<p>Bit 10: A 0 at this bit position indicates that the data byte has been received when the device has been in slave mode, whereas a 1 indicates a reception in master mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0f5cc56c100494c399620dc165e74ee9a1561cdb73356e1167878f2c171a59c03"></a>XMC_I2C_CH_RECEIVER_STATUS_FLAG_ERR&#160;</td><td class="fielddoc">
<p>Bit 11: A 1 at this bit position indicates an incomplete/erroneous data byte in the receive buffer </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0f5cc56c100494c399620dc165e74ee9acdd6f7f3796679921b546e194b25329e"></a>XMC_I2C_CH_RECEIVER_STATUS_FLAG_ADR&#160;</td><td class="fielddoc">
<p>Bit 12: A 0 at this bit position indicates that the programmed address has been received. A 1 indicates a general call address. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae922e0696a07a1809a0d8e80248ce497"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gae922e0696a07a1809a0d8e80248ce497">XMC_I2C_CH_STATUS_FLAG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C status. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a9064574003e7488ab0abb7ff5ab24afb"></a>XMC_I2C_CH_STATUS_FLAG_SLAVE_SELECT&#160;</td><td class="fielddoc">
<p>Slave select status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a755a5fd93caa9ce9256fb9b1af28f83b"></a>XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND&#160;</td><td class="fielddoc">
<p>Wrong TDF status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a70622c04d56ea2eb020f6d284a6ab3cb"></a>XMC_I2C_CH_STATUS_FLAG_START_CONDITION_RECEIVED&#160;</td><td class="fielddoc">
<p>Start condition received status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a756fc8a9aeeb892d313cb974a3d0177b"></a>XMC_I2C_CH_STATUS_FLAG_REPEATED_START_CONDITION_RECEIVED&#160;</td><td class="fielddoc">
<p>Repeated start condition received status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a4664181ff09534b6db48dea42858e898"></a>XMC_I2C_CH_STATUS_FLAG_STOP_CONDITION_RECEIVED&#160;</td><td class="fielddoc">
<p>Stop condition received status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497ab44e1045125702fdfd9dcf9285ef17cb"></a>XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED&#160;</td><td class="fielddoc">
<p>NACK received status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a9423024bda96a10cd3c46715cd9ca9df"></a>XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST&#160;</td><td class="fielddoc">
<p>Arbitration lost status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a7b0ee1867bcc1f8341b092ae4eb67511"></a>XMC_I2C_CH_STATUS_FLAG_SLAVE_READ_REQUESTED&#160;</td><td class="fielddoc">
<p>Slave read requested status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a2da70d78de866416d369528e6219429f"></a>XMC_I2C_CH_STATUS_FLAG_ERROR&#160;</td><td class="fielddoc">
<p>Error status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497ab08a526647c7f9bd1bcad252e6a195c3"></a>XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED&#160;</td><td class="fielddoc">
<p>ACK received status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a942fb1f070d531f75611d7ea2780b895"></a>XMC_I2C_CH_STATUS_FLAG_RECEIVER_START_INDICATION&#160;</td><td class="fielddoc">
<p>Receive start indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497ae799d0f1665c26de8a6e698c68e5b2cb"></a>XMC_I2C_CH_STATUS_FLAG_DATA_LOST_INDICATION&#160;</td><td class="fielddoc">
<p>Data lost indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a277ffd76549e58155dbe9bb950a2827c"></a>XMC_I2C_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION&#160;</td><td class="fielddoc">
<p>Transmit shift indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a852f66a227d76d83ce213ff503666566"></a>XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION&#160;</td><td class="fielddoc">
<p>Transmit buffer indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a66815c4a86a9c2db3486177c992a559d"></a>XMC_I2C_CH_STATUS_FLAG_RECEIVE_INDICATION&#160;</td><td class="fielddoc">
<p>Receive indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a47e992f985807bd7e44c6a1692221454"></a>XMC_I2C_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION&#160;</td><td class="fielddoc">
<p>Alternate receive indication status </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae922e0696a07a1809a0d8e80248ce497a592e3d84375f9921674e4e5a46a2544d"></a>XMC_I2C_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION&#160;</td><td class="fielddoc">
<p>Baud rate generator indication status </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gacba9683fdb659e012642e66bc96a406d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Status. </p>
<table class="fieldtable">
<tr><th colspan="2">Aufzählungswerte</th></tr><tr><td class="fieldname"><a class="anchor" id="ggacba9683fdb659e012642e66bc96a406dad4a9d28840691950dde4b05dad36f276"></a>XMC_I2C_CH_STATUS_OK&#160;</td><td class="fielddoc">
<p>Status OK </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacba9683fdb659e012642e66bc96a406da60c441b462f4212da785420bb921734d"></a>XMC_I2C_CH_STATUS_ERROR&#160;</td><td class="fielddoc">
<p>Status ERROR </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacba9683fdb659e012642e66bc96a406da27fb280a26d46055901bc598c7e02f2f"></a>XMC_I2C_CH_STATUS_BUSY&#160;</td><td class="fielddoc">
<p>Status BUSY </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Dokumentation der Funktionen</h2>
<a class="anchor" id="gab922e97164d14898b92df3d30c10fe83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_ClearStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">flag</td><td>Status flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the status flag of I2C <em>channel</em> by setting the input parameter <em>flag</em> in PSCR register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#gaddc87a65cf16a2bf717f650a29506cef">XMC_I2C_CH_GetStatusFlag()</a><br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a725284f672801993f9ab5dcf3ef1e5c7">XMC_USIC_CH_t::PSCR</a>.</p>

</div>
</div>
<a class="anchor" id="ga63149dd65f853cc69ed57add87f34627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_ConfigExternalInputSignalToBRG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>pdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>oversampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga4c50ae5a7f12a5496d82d2bc665e1db2">XMC_USIC_CH_INPUT_COMBINATION_MODE_t</a>&#160;</td>
          <td class="paramname"><em>combination_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_c.html#ga71176768512ab2836eb4dc41973c1339">XMC_I2C0_CH0</a>, <a class="el" href="group___i2_c.html#gafbbadccd3da1cbecf1aac59dd54035dd">XMC_I2C0_CH1</a>,<a class="el" href="group___i2_c.html#ga9ffc942d7d7d6a1a2653c4406f265a16">XMC_I2C1_CH0</a>,<a class="el" href="group___i2_c.html#ga8b7a66d60a6dc718f09b5245187b9fec">XMC_I2C1_CH1</a>,<a class="el" href="group___i2_c.html#gadbd192d1e612ccd4143ec299966a11f0">XMC_I2C2_CH0</a>,<a class="el" href="group___i2_c.html#ga7d470379c765ee393530da6b97372122">XMC_I2C2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Zu beachten</dt><dd>Availability of I2C1 and I2C2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdiv</td><td>Desired divider for the external frequency input. <b>Range:</b> minimum value = 1, maximum value = 1024 <br />
</td></tr>
    <tr><td class="paramname">oversampling</td><td>Required oversampling. The value indicates the number of time quanta for one symbol of data. <br />
 This can be related to the number of samples for each logic state of the data signal. <br />
 <b>Range:</b> 1 to 32. Value should be chosen based on the protocol used. </td></tr>
    <tr><td class="paramname">combination_mode</td><td>USIC channel input combination mode <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the external frequency input for the Baudrate Generator and configures the divider, oversampling and the combination mode of the USIC channel. <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga2876a325930da4b77ef46ec4e0acda0d">XMC_USIC_CH_SetBRGInputClockSource()</a>, <a class="el" href="group___u_s_i_c.html#gaeef58e03c1253fce5b8a456f5d8c6da6">XMC_USIC_CH_SetInputTriggerCombinationMode()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#ga00c6419dfc0f8ed4c4eab13ded598144">XMC_USIC_CH_ConfigExternalInputSignalToBRG()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d7a2f143c3f07c35b39174d6e802be6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_DisableAcknowledgeAddress0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This bit defines that slave device should not be sensitive to the slave address 00H.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#gae49923f2679d64f4980518491d844bec">XMC_I2C_CH_EnableAcknowledgeAddress0()</a><br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a99f9d9accabbec49d9242277b26b8bde">XMC_USIC_CH_t::PCR_IICMode</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d0b7e575a13d2fdd2ead33d96d9e15b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">event</td><td>ORed values of <a class="el" href="group___i2_c.html#ga4142054abf4133012810875bc5ac4f48">XMC_I2C_CH_EVENT_t</a> enum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the input parameter <a class="el" href="group___i2_c.html#ga4142054abf4133012810875bc5ac4f48">XMC_I2C_CH_EVENT_t</a> event using PCR_IICMode register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga868f80d9e08a0518c38100dda3f77882">XMC_I2C_CH_EnableEvent()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#gad1168655888146acb741b9e6aac04c4e">XMC_I2C_CH_GetReceiverStatusFlag()</a>.</p>

</div>
</div>
<a class="anchor" id="gae49923f2679d64f4980518491d844bec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_EnableAcknowledgeAddress0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the status byte of I2C <em>channel</em> using PSR_IICMode register.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga4d7a2f143c3f07c35b39174d6e802be6">XMC_I2C_CH_DisableAcknowledgeAddress0()</a><br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a99f9d9accabbec49d9242277b26b8bde">XMC_USIC_CH_t::PCR_IICMode</a>.</p>

</div>
</div>
<a class="anchor" id="ga868f80d9e08a0518c38100dda3f77882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">event</td><td>ORed values of <a class="el" href="group___i2_c.html#ga4142054abf4133012810875bc5ac4f48">XMC_I2C_CH_EVENT_t</a> enum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the input parameter <a class="el" href="group___i2_c.html#ga4142054abf4133012810875bc5ac4f48">XMC_I2C_CH_EVENT_t</a> event using PCR_IICMode register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga7d0b7e575a13d2fdd2ead33d96d9e15b">XMC_I2C_CH_DisableEvent()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#gad1168655888146acb741b9e6aac04c4e">XMC_I2C_CH_GetReceiverStatusFlag()</a>.</p>

</div>
</div>
<a class="anchor" id="ga50f0983dca84031814fcbcb52991ee63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XMC_I2C_CH_GetReceivedData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>uint8_t OUTR/RBUF register data<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Reads the data from I2C <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Data is read by using OUTR/RBUF register based on FIFO/non-FIFO modes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gad1168655888146acb741b9e6aac04c4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XMC_I2C_CH_GetReceiverStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>uint8_t Receiver status flag<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the receiver status of I2C <em>channel</em> using RBUF register of bits 8-12 which gives information about receiver status.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a><br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a40ae57e054b61a2ff08b68b84ddc1f86">XMC_USIC_CH_t::RBUF</a>, <a class="el" href="group___i2_c.html#ga7d0b7e575a13d2fdd2ead33d96d9e15b">XMC_I2C_CH_DisableEvent()</a> und <a class="el" href="group___i2_c.html#ga868f80d9e08a0518c38100dda3f77882">XMC_I2C_CH_EnableEvent()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9131749645c421ff4b8bc80d0c93b691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_I2C_CH_GetSlaveAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>uint16_t Slave address<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the I2C <em>channel</em> slave address.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Returns the address using PCR_IICMode register by checking if it is in 10-bit address group or 7-bit address group.<br />
 (If first five bits of address are assigned with 0xF0, then address mode is considered as 10-bit mode otherwise it is 7-bit mode)</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#gaec9df234c44378c3fc10f0423d71aec9">XMC_I2C_CH_SetSlaveAddress()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gaddc87a65cf16a2bf717f650a29506cef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_I2C_CH_GetStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>uint32_t Status byte<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the status byte of I2C <em>channel</em> using PSR_IICMode register.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#gab922e97164d14898b92df3d30c10fe83">XMC_I2C_CH_ClearStatusFlag()</a><br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a220e89d84bc3e419c31264149c6daf02">XMC_USIC_CH_t::PSR_IICMode</a>.</p>

</div>
</div>
<a class="anchor" id="gafbab6cabacc65e03592b1c5d6cece11d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">config</td><td>Constant pointer to I2C channel config structure of type <a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes the I2C <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Configures the data format in SCTR register. Sets the slave address, baud rate. Enables transmit data valid, clears status flags and disables parity generation.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga0567321036170adb335fef9b36dc3b71">XMC_USIC_CH_Enable()</a><br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gad5e1a8e56b356c2fc246c8b3b95bfb74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterReceiveAck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sends the Ack request from I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIFO/non-FIFO modes using Master Receive Ack command.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gae5960060afec908c91cd8e4a78e5eae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterReceiveNack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sends the Nack request from I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIFO/non-FIFO modes using Master Receive Nack command.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga770a5f71ceb3b447f21a8b129df6486e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterRepeatedStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_c.html#gaf81b9bb81ece318669b08149f1fd7f4b">XMC_I2C_CH_CMD_t</a>&#160;</td>
          <td class="paramname"><em>command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">addr</td><td>I2C master address </td></tr>
    <tr><td class="paramname">command</td><td>read/write command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sends the repeated start condition from I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Sends the repeated start condition with read/write command by updating IN/TBUF register based on FIFO/non-FIFO modes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a>, <a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gaebd425a409b805d4571e75f793317070"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_c.html#gaf81b9bb81ece318669b08149f1fd7f4b">XMC_I2C_CH_CMD_t</a>&#160;</td>
          <td class="paramname"><em>command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">addr</td><td>I2C master address </td></tr>
    <tr><td class="paramname">command</td><td>read/write command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Starts the I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Sends the Start condition with read/write command by updating IN/TBUF register based on FIFO/non-FIFO modes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a>, <a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a48dbbe2be7fce74bd328bae5db5141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Stops the I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIFO/non-FIFO modes using Stop command.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a>, <a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga701835880c9d134de09af56c12ee3383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterTransmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">data</td><td>data to transmit from I2C <em>channel</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Transmit the data from the I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIFO/non-FIFO modes using Master Send command.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0caf9dbe9035171cc4826ad279a857a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SelectInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_c.html#ga797641917b01a783e6e7aac5d25a298f">XMC_I2C_CH_INTERRUPT_NODE_POINTER_t</a>&#160;</td>
          <td class="paramname"><em>interrupt_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_c.html#ga71176768512ab2836eb4dc41973c1339">XMC_I2C0_CH0</a>, <a class="el" href="group___i2_c.html#gafbbadccd3da1cbecf1aac59dd54035dd">XMC_I2C0_CH1</a>,<a class="el" href="group___i2_c.html#ga9ffc942d7d7d6a1a2653c4406f265a16">XMC_I2C1_CH0</a>,<a class="el" href="group___i2_c.html#ga8b7a66d60a6dc718f09b5245187b9fec">XMC_I2C1_CH1</a>,<a class="el" href="group___i2_c.html#gadbd192d1e612ccd4143ec299966a11f0">XMC_I2C2_CH0</a>,<a class="el" href="group___i2_c.html#ga7d470379c765ee393530da6b97372122">XMC_I2C2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Zu beachten</dt><dd>Availability of I2C1 and I2C2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt_node</td><td>Interrupt node pointer to be configured. <br />
 <b>Range:</b> <a class="el" href="group___s_p_i.html#gga6396e4407b48373dd88ce24c1e229635adbf85c1c2d8fef17554d399c4d3ffd77">XMC_SPI_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT</a>, <a class="el" href="group___s_p_i.html#gga6396e4407b48373dd88ce24c1e229635acef45b4e93a44535a1e05154d5078b9a">XMC_SPI_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER</a> etc. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number.<br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for USIC channel events. <br />
<br />
For an event to generate interrupt, node pointer should be configured with service request(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so.<br />
 Note: NVIC node should be separately enabled to generate the interrupt.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga868f80d9e08a0518c38100dda3f77882">XMC_I2C_CH_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0da1b672c78d08d3ffdb83316d1443cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a> XMC_I2C_CH_SetBaudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">rate</td><td>baud rate of I2C channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the rate of I2C <em>channel</em>.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Standard over sampling is considered if rate &lt;= 100KHz and fast over sampling is considered if rate &gt; 100KHz.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gac9feec95c73b09889e494ec6d6898f4f">XMC_USIC_CH_SetBaudrate()</a><br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga358214504f42dac696c4519efa19307b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SetInputSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_c.html#ga76b49d68cc6d179beaf1dfe2998230bd">XMC_I2C_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">input</td><td>I2C channel input stage of type <a class="el" href="group___i2_c.html#ga76b49d68cc6d179beaf1dfe2998230bd">XMC_I2C_CH_INPUT_t</a> </td></tr>
    <tr><td class="paramname">source</td><td>Input source select for the input stage(0-&gt;DX0A, 1-&gt;DX1A, .. 7-&gt;DX7G) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the input source for I2C <em>channel</em>.<br />
 Defines the input stage for the corresponding input line.</dd></dl>
<dl class="section note"><dt>Zu beachten</dt><dd>After configuring the input source for corresponding channel, interrupt node pointer is set.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_USIC_CH_SetInptSource(), <a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a> </dd></dl>

<p>Benutzt <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a>, <a class="el" href="group___i2_c.html#ga50f0983dca84031814fcbcb52991ee63">XMC_I2C_CH_GetReceivedData()</a>, <a class="el" href="group___i2_c.html#ga9131749645c421ff4b8bc80d0c93b691">XMC_I2C_CH_GetSlaveAddress()</a>, <a class="el" href="group___i2_c.html#gad5e1a8e56b356c2fc246c8b3b95bfb74">XMC_I2C_CH_MasterReceiveAck()</a>, <a class="el" href="group___i2_c.html#gae5960060afec908c91cd8e4a78e5eae9">XMC_I2C_CH_MasterReceiveNack()</a>, <a class="el" href="group___i2_c.html#ga770a5f71ceb3b447f21a8b129df6486e">XMC_I2C_CH_MasterRepeatedStart()</a>, <a class="el" href="group___i2_c.html#gaebd425a409b805d4571e75f793317070">XMC_I2C_CH_MasterStart()</a>, <a class="el" href="group___i2_c.html#ga6a48dbbe2be7fce74bd328bae5db5141">XMC_I2C_CH_MasterStop()</a>, <a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a>, <a class="el" href="group___i2_c.html#gaec9df234c44378c3fc10f0423d71aec9">XMC_I2C_CH_SetSlaveAddress()</a>, <a class="el" href="group___i2_c.html#gafdd7192c5a6b3fa481f293fb0a574665">XMC_I2C_CH_SlaveTransmit()</a> und <a class="el" href="group___u_s_i_c.html#ga7986fcfe3fd6bf9982e43b1eaabb02c2">XMC_USIC_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gada2c698290a70ed692f067756ececd4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number in the range of 0-5 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the interrupt node for protocol interrupt.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>To generate interrupt for an event, node pointer should be configured with service request number(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so.<br />
</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>NVIC node should be separately enabled to generate the interrupt. After setting the node pointer, desired event must be enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga868f80d9e08a0518c38100dda3f77882">XMC_I2C_CH_EnableEvent()</a>, NVIC_SetPriority(), NVIC_EnableIRQ(), <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a><br />
 </dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#gga074b5b1abff43f98316c7a5b69523e62a3b99d0d6e93882ea791e8952cc993a7b">XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL</a> und <a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaec9df234c44378c3fc10f0423d71aec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SetSlaveAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">address</td><td>I2C slave address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the I2C <em>channel</em> slave address.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Address is set in PCR_IICMode register by checking if it is in 10-bit address group or 7-bit address group. (If first five bits of address are assigned with 0xF0, then address mode is 10-bit mode otherwise it is 7-bit mode)</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga9131749645c421ff4b8bc80d0c93b691">XMC_I2C_CH_GetSlaveAddress()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gafdd7192c5a6b3fa481f293fb0a574665"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SlaveTransmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">data</td><td>data to transmit from I2C <em>channel</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Transmit the data from the I2C slave <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIFO/non-FIFO modes using Slave Send command.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a>,<a class="el" href="group___i2_c.html#gab922e97164d14898b92df3d30c10fe83">XMC_I2C_CH_ClearStatusFlag()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gad3de1b923c1a3c0a2b1ea9a8d9ff1d91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Starts the I2C <em>channel</em>.</dd></dl>
<dl class="section user"><dt></dt><dd>Sets the USIC input operation mode to I2C mode using CCR register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga8c04c213fd44c14b1bed871bb658683c">XMC_USIC_CH_SetMode()</a><br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___i2_c.html#ga4eeda18d28c90e527c309726ff5d3cb9">XMC_I2C_CH_Stop()</a>, <a class="el" href="group___u_s_i_c.html#ggac052842418ff3dda00900219ebda5de7a4dad9ad4de2fe7406c1685606a651503">XMC_USIC_CH_OPERATING_MODE_I2C</a> und <a class="el" href="group___u_s_i_c.html#ga8c04c213fd44c14b1bed871bb658683c">XMC_USIC_CH_SetMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4eeda18d28c90e527c309726ff5d3cb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a> XMC_I2C_CH_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t<br />
</a></dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Stops the I2C <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Sets the USIC input operation to IDLE mode using CCR register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga8c04c213fd44c14b1bed871bb658683c">XMC_USIC_CH_SetMode()</a><br />
<br />
</dd></dl>

<p>Wird benutzt von <a class="el" href="group___i2_c.html#gad3de1b923c1a3c0a2b1ea9a8d9ff1d91">XMC_I2C_CH_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga72d5d08ec30a105175f9a789ab38c1c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_TriggerServiceRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_c.html#ga71176768512ab2836eb4dc41973c1339">XMC_I2C0_CH0</a>, <a class="el" href="group___i2_c.html#gafbbadccd3da1cbecf1aac59dd54035dd">XMC_I2C0_CH1</a>,<a class="el" href="group___i2_c.html#ga9ffc942d7d7d6a1a2653c4406f265a16">XMC_I2C1_CH0</a>,<a class="el" href="group___i2_c.html#ga8b7a66d60a6dc718f09b5245187b9fec">XMC_I2C1_CH1</a>,<a class="el" href="group___i2_c.html#gadbd192d1e612ccd4143ec299966a11f0">XMC_I2C2_CH0</a>,<a class="el" href="group___i2_c.html#ga7d470379c765ee393530da6b97372122">XMC_I2C2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Zu beachten</dt><dd>Availability of I2C1 and I2C2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_request_line</td><td>service request number of the event to be triggered. <br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Trigger a I2C interrupt service request.<br />
<br />
When the I2C service request is triggered, the NVIC interrupt associated with it will be generated if enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga0caf9dbe9035171cc4826ad279a857a3">XMC_I2C_CH_SelectInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

<p>Benutzt <a class="el" href="group___u_s_i_c.html#ga6fa0313a4dfcade23a7098631edefc50">XMC_USIC_CH_TriggerServiceRequest()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Erzeugt am Mit Jun 22 2016 11:36:59 für XMC Peripheral Library for XMC4000 Family von &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
