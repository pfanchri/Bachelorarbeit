/*
 * Init.c
 *
 *  Created on: Jun 16, 2016
 *      Author Christof Pfannenmüller (student06)
 */
#include "Header_general.h" //including all Header files

//aditional functions
void delay (unsigned long delay)
{
  while (delay--)
  {
    __NOP();
  }
}




//init

void init(void){

	//sets LED Pins as Outputs
	XMC_GPIO_SetMode(XMC_GPIO_PORT6, PIN_LED_1, XMC_GPIO_MODE_OUTPUT_PUSH_PULL); //LED1
	XMC_GPIO_SetMode(XMC_GPIO_PORT6, PIN_LED_2, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetMode(XMC_GPIO_PORT6, PIN_LED_3, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetMode(XMC_GPIO_PORT6, PIN_LED_4, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetMode(XMC_GPIO_PORT6, PIN_LED_5, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetMode(XMC_GPIO_PORT6, PIN_LED_6, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetMode(XMC_GPIO_PORT6, PIN_LED_7, XMC_GPIO_MODE_OUTPUT_PUSH_PULL); //LED7

	//set P_ON Pins as Output
	XMC_GPIO_SetMode(XMC_GPIO_PORT0, PIN_P_ON_TDA_1,
			XMC_GPIO_MODE_OUTPUT_PUSH_PULL); //TDA1
	XMC_GPIO_SetMode(XMC_GPIO_PORT1, PIN_P_ON_TDA_2,
			XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetMode(XMC_GPIO_PORT5, PIN_P_ON_TDA_3,
			XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetMode(XMC_GPIO_PORT5, PIN_P_ON_TDA_4,
			XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetMode(XMC_GPIO_PORT3, PIN_P_ON_TDA_5,
			XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
	XMC_GPIO_SetMode(XMC_GPIO_PORT0, PIN_P_ON_TDA_6,
			XMC_GPIO_MODE_OUTPUT_PUSH_PULL); //TDA6

}

void general_test(void){
	//uint8_t i = 0;
	//i=tda5340_transfer(0, 0x05, 0xD0 , 0);
	//
	//if(i==0){
	//	led_on(i);i=0;
	//}
	//test für TDA Lib von Felix

	//tda5340_gpio_init(0);
	//tda5340_init(0);
	//uint32_t serialnumber = tda5340_get_serial_number(0);

	//serialnumber -> LEDs
	//for (int var = 0; var < 32; var++) {
	//		if (serialnumber & (1 << var)) {
	//			led_on(5);
	//		}
	//		led_on(6);
	//		delay(4000000);
	//		led_off(5);
	//		led_off(6);
	//}


	set_TDA_status(0,1);
	delay(40000);

	spi_init(spi_master_ch);
	delay(40000);

	tda5340_transfer(4, READ_FROM_CHIP, IS2, 0xFF);
	delay(40000);
	tda5340_transfer(4,READ_FROM_CHIP,0xDB,0);

	tda5340_transfer(4, READ_FROM_CHIP, IS2, 0xFF);
	delay(40000);
	tda5340_transfer(4,READ_FROM_CHIP,0xDB,0);

	//
	//	uint16_t spi_array_tx[SPI_TX_ARRAY_LENGH] = { 0 };
	//	spi_array_tx[0] =0x05;
	//	spi_array_tx[1] =0xD3;
	//	uint16_t spi_array_rx[SPI_RX_ARRAY_LENGH] = { 0 };
	//	led_on(2);
	//
	//
	//	set_TDA_status(0,1);
	//
	//
	//led_on(6);
	//led_on(7);
	//
	//			if (spi_array_rx[0]  ==  0 &&spi_array_rx[1]  ==  0&&spi_array_rx[2]  ==  0&&spi_array_rx[3]  ==  0&&spi_array_rx[4]  ==  0&&spi_array_rx[5]  ==  0
	//					&& spi_array_rx[6]  ==  0 &&spi_array_rx[7]  ==  0&&spi_array_rx[7]  ==  0&&spi_array_rx[8]  ==  0&&spi_array_rx[9]  ==  0	) {
	//				led_off(6);
	//			}
	//
	//
	//spi_init(spi_master_ch);
	//	spi_transfer(spi_master_ch, 0, spi_array_tx, spi_array_rx, 20);
	//
	//
	//
	//	for (int var = 0; var < SPI_RX_ARRAY_LENGH; var++) {
	//		if (spi_array_rx[var]  !=  0) {
	//			led_on(5);
	//		}
	//	}

}
